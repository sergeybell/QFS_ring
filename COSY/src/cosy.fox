{******************************************************************************
*                                                                             *
*                                  cosy.fox                                   *
*                                                                             *
*                             COSY MACRO PACKAGE                              *
*                                                                             *
*                           PART OF THE COSY SYSTEM                           *
*                                                                             *
*                                 VERSION 10.1                                *
*                                                                             *
*                          UPDATED IN FEBRUARY, 2018                          *
*                                                                             *
*     COPYRIGHT (C) MICHIGAN STATE UNIVERSITY, MARTIN BERZ, KYOKO MAKINO 2018 *
*     SUBJECT TO LICENSING AGREEMENT - NOT TO BE DISTRIBUTED                  *
*                                                                             *
*     DISTRIBUTED BY M. BERZ AND K. MAKINO                                    *
*     DEPARTMENT OF PHYSICS AND ASTRONOMY                                     *
*     MICHIGAN STATE UNIVERSITY                                               *
*     EAST LANSING, MI 48824, USA                                             *
*     BERZ@MSU.EDU                                                            *
*     517-884-5583 (PHONE)                                                    *
*                                                                             *
******************************************************************************}
BEGIN ;

{COSY GLOBAL VARIABLES}
{*********************}
{ON SMALLER SYSTEMS, ALL DECLARATIONS WITH LENGTH 4000 CAN BE REPLACED BY 500}
   VARIABLE AMU 1 ; VARIABLE AMUMEV 1 ; VARIABLE EZERO 1 ; VARIABLE CLIGHT 1 ;
   VARIABLE PI  1 ; VARIABLE DEGRAD 1 ; VARIABLE TRUE 1 ; VARIABLE FALSE 1 ;
                                                            {CONST - SET IN DEF}

   VARIABLE E0 100 ; VARIABLE M0 100 ; VARIABLE Z0 100 ; VARIABLE V0 100 ;
   VARIABLE P0 100 ; VARIABLE G0 100 ; VARIABLE CHIM 500 ; VARIABLE CHIE 500 ;
   VARIABLE ETA 500 ; VARIABLE HFAC 500 ; VARIABLE TFAC 1 ;    {REF PART-SEE RP}

   VARIABLE MAP 4000 8 ; VARIABLE MSC 4000 8 ;  {MOMENTARY AND SCRATCH COSY MAP}
   VARIABLE SPNR 4000 3 3 ; VARIABLE SSCR 4000 3 3 ; VARIABLE LSPN 1 ;    {SPIN}
   VARIABLE RAY 10001 8 ; VARIABLE RSC 10001 8 ; VARIABLE RCOL 10001 ;    {RAYS}
   VARIABLE SPI 10001 3 ; VARIABLE SSC 10001 3 ;
   VARIABLE REMAIN 10001 ; VARIABLE REMOVE 10001 ;
   {THE MAX NUMBER OF RAYS: 10001. CAN BE INCREASED IN THE ABOVE TWO LINES.}
   VARIABLE NRAY 1 ; VARIABLE NSPN 1 ; VARIABLE XCUT 1 2 ; VARIABLE LCUT 1 ;
   VARIABLE NCT 1 ; VARIABLE NCCT 1 ; VARIABLE XCT 1 2 10 ; VARIABLE LCT 1 10 ;
   VARIABLE MCT 4000 20 ;
   VARIABLE ESC 1 ; VARIABLE ENC 1 ;
   VARIABLE ERAY 1 4 ; VARIABLE ERSC 1 4 ; VARIABLE EMAX 1 2 ;        {ENVELOPE}
   VARIABLE AXP 1000 3 ; VARIABLE AXD 1000 6 ;  VARIABLE SPOS 1000 ;  {AXIS COO}
   VARIABLE XLOC 20 ; VARIABLE ZLOC 20 ; VARIABLE PLOC 20 ; VARIABLE SLOC 20 ;
   VARIABLE VLOC 20 ; VARIABLE TLOC 20 ;                        {LOCAL AXIS COO}
   VARIABLE SYS 20000 ; VARIABLE CE 10 ; VARIABLE TRA 1000 251 ;       {PICTURE}
   VARIABLE NRAYTRA0 1 ;          {NRAYTRA0: THE ARRAY LENGTH OF TRA, SET IN OV}
   VARIABLE NRAYTRA 1 ;
   VARIABLE ETRA 1000 ; VARIABLE SYS0 200 ; VARIABLE TRTST 200 ;
   VARIABLE GPLOC 1 ;                                             {GLOBAL ANGLE}

   {CHANGE LSCT IN OV ACCORDING TO THE MAX OF SYS AND TRA}
   VARIABLE LSCR 1 ; VARIABLE LSCT 1 ; VARIABLE LTRA 20 3 ; VARIABLE GTRA 20 3 ;

   VARIABLE EFX 4000 ; VARIABLE EFY 4000 ; VARIABLE EFZ 4000 ; VARIABLE V 4000 ;
   VARIABLE BFX 4000 ; VARIABLE BFY 4000 ; VARIABLE BFZ 4000 ; VARIABLE W 4000 ;
   VARIABLE H 4000 ; VARIABLE CHIM1 1 ; VARIABLE CHIE1 1 ; VARIABLE TP1 1 ;

   VARIABLE PMM 20 40 ; VARIABLE PEM 20 40 ; VARIABLE LM 1 ;  {MULTIPOLE FIELDS}
   VARIABLE PPOL 20 36 ; VARIABLE MPOL 20 30 ; VARIABLE NPOL 1 ; VARIABLE LS 1 ;
   VARIABLE NSDP 1 ; VARIABLE LCCT 1 ; VARIABLE LOFF 1 ;
   VARIABLE ENGEC 2 20 2 2 6 ; VARIABLE LE 1 ;               {ENGE COEFFICIENTS}
   VARIABLE GFF2 40 2 6 10 ; VARIABLE LFF2 400 2 6 10 ;
   VARIABLE DATFF2 1 2 6 10 ;                       {SYMPLECTIC SCALING FF MODE}
   VARIABLE INP 1 ; VARIABLE NN 1 ; VARIABLE SN 10  100 ; VARIABLE HN 25 100 ;
   VARIABLE VN 25 100 ; VARIABLE WN 25 100 ; VARIABLE PN 1 40 ; VARIABLE NPG 1 ;
   VARIABLE DR 10 ; VARIABLE DMAX 1 ; VARIABLE MFP 1 8 ; VARIABLE MFD 6 700 30;
   VARIABLE BETHEBLOCHC 1 6 ; VARIABLE BXNOB 1 5 ; VARIABLE BXBDT 1 5 7 ;
   VARIABLE BXNOD 1 5 ; VARIABLE BXDDT 1 5 7 ; VARIABLE BXBOXID 1 70 ;
   VARIABLE BXIBOX 1 ; VARIABLE BX1BOXPN 1 70 4 ; VARIABLE BX1BOXP 1 70 4 2 3 ;
   VARIABLE A 1 13 ; VARIABLE B 1 13 12 ; VARIABLE C 1 13 ; VARIABLE D 1 13 ;
   VARIABLE HSQR 1 ; VARIABLE LRKCO 1 ; VARIABLE LRKO 1 ; VARIABLE RKO 2 ;
   VARIABLE EPS 1 ; VARIABLE WAF 1 ;

   VARIABLE DD 1 20 ; VARIABLE DX 1 20 ; VARIABLE XX 15 30 ; VARIABLE DEPS 1 ;

   VARIABLE NO  1 ; VARIABLE NV  1 ; VARIABLE ND 1 ; VARIABLE TWOND 1 ;
   VARIABLE NOC 1 ; VARIABLE NM1 1 ; VARIABLE NM2 1 ; VARIABLE NM3 1 ;
   VARIABLE NMP 1 ; VARIABLE NP 1 ;

   VARIABLE LOV 1 ; VARIABLE LRP 1 ; VARIABLE LUM 1 ; VARIABLE LFR 1 ;
   VARIABLE LPS 1 ; VARIABLE LPI 1 ; VARIABLE LPG 1 ; VARIABLE LCB 1 ;
   VARIABLE LFR2 1 ; VARIABLE LCR 1 ; VARIABLE LKC 1 ;
   VARIABLE LENV 1 ; VARIABLE LSYS 1 ; VARIABLE LCE 1 ; VARIABLE LAX 1 ;
   VARIABLE LWA 1 ; VARIABLE LCO 1 ;                        {FLOW CONTROL FLAGS}
   VARIABLE LTR 1 ; VARIABLE LTRR 1 ; VARIABLE LTRI 1 ;
   VARIABLE LTRPRAY 1 ; VARIABLE LTRPRAYU 1 ;
   VARIABLE LTRPSPI 1 ; VARIABLE LTRPSPIU 1 ;
   VARIABLE LWNDANF 1 ; VARIABLE LWNTS 1 ; VARIABLE LWNTR 1 ;

   VARIABLE DIRSETFLAG 1; {if 1 UTILITIES.FOX: DIRSET doesn't ask questions @AA}

   VARIABLE PHSP 1 8 ; VARIABLE PARS 1 8 ; VARIABLE PHSR 1 3 ;
   {PHASE SPACE AND PARAMETER DATA}

{LOW LEVEL TOOLS}
{***************}

   PROCEDURE VESORT VEC; {*** performs insertion sort on a vector argument @AA ***}
     VARIABLE I 1; VARIABLE POS 1; VARIABLE CURVAL 1; VARIABLE TEST 1;
     LOOP I 2 LENGTH(VEC);
       CURVAL := VEC|I; POS := I;
       TEST:=(VEC|(POS-1))>CURVAL;
       WHILE TEST;
         VELSET VEC POS VEC|(POS-1);
         POS:=POS-1;
         IF POS>1; TEST:=(VEC|(POS-1))>CURVAL; ELSEIF LO(1); TEST:=LO(0); ENDIF;
       ENDWHILE;
       VELSET VEC POS CURVAL;
     ENDLOOP;
   ENDPROCEDURE; {END OF VESORT}
   FUNCTION L2NORM ARR LEN; {*** L2 NORM FOR ARRAYS @AA ***}
     VARIABLE I 1; VARIABLE DUM NM1;
     LOOP I 1 LEN; DUM := DUM + SQR(ARR(I)); ENDLOOP;
     L2NORM := SQRT(DUM);
   ENDFUNCTION;
   FUNCTION VEL2NORM VEC; VEL2NORM := SQRT(ABS(SQR(VEC)));  ENDFUNCTION; {*** L2 norm FOR VECTORS @AA ***}
   FUNCTION MAX I J ; MAX := VMAX(I&J) ; ENDFUNCTION ;
   FUNCTION MIN I J ; MIN := VMIN(I&J) ; ENDFUNCTION ;
   FUNCTION MOD I1 I2 ; MOD := I1-INT(I1/I2)*I2 ; ENDFUNCTION ;
   FUNCTION SIG I ; SIG := 1 ; IF I#0 ; SIG := I/ABS(CONS(I)) ; ENDIF ;   {SIGN}
      ENDFUNCTION ;
   FUNCTION VSIG VEC; {vector SIGN function @AA}
     VARIABLE RES NM1; VARIABLE N 1; VARIABLE I 1;
     RES := VEC;
     LOOP I 1 LENGTH(RES);  VELSET RES I SIG(RES|I); ENDLOOP;
     VSIG := RES;
   ENDFUNCTION; {END OF VSIG}
   FUNCTION VEMEDIAN VEC; {*** Computes the median @AA ***}
     VARIABLE N 1; VARIABLE I0 1;
     N := LENGTH(VEC); I0 := NINT(N/2);
     VESORT VEC;
     IF MOD(N, 2)=1; VEMEDIAN := VEC|I0;
     ELSEIF LO(1); VEMEDIAN := .5*(VEC|I0 + VEC|(I0+1)); ENDIF;
   ENDFUNCTION; {END OF VEMEDIAN}
   FUNCTION IM X ; IM := CM(0&1)*X ; ENDFUNCTION ;
   FUNCTION ATAN2 Y X ; VARIABLE XC 1 ; VARIABLE YC 1 ;     {ATAN(Y/X) [-pi,pi]}
      XC := CONS(X) ; YC := CONS(Y) ; IF (XC=0)*(YC=0) ; ATAN2 := 0 ;
      ELSEIF ABS(YC)>ABS(XC) ; ATAN2 := ATAN(X/Y) ; IF YC>0 ;
      ATAN2 := PI*0.5-ATAN2 ; ELSEIF 1=1 ; ATAN2 := -PI*0.5-ATAN2 ; ENDIF ;
      ELSEIF 1=1 ; ATAN2 := ATAN(Y/X) ; IF XC<0 ; IF YC<0 ; ATAN2 := -PI+ATAN2 ;
      ELSEIF 1=1 ; ATAN2 := PI+ATAN2 ; ENDIF ; ENDIF ; ENDIF ; ENDFUNCTION ;
   FUNCTION VATAN2 Y X ; VARIABLE I 1 ; VATAN2 := Y ; LOOP I 1 LENGTH(Y) ;
      VELSET VATAN2 I ATAN2(Y|I,X|I) ; ENDLOOP ; ENDFUNCTION ;

   FUNCTION SS A I1 I2 ; SS := A|(I1&I2) ;      ENDFUNCTION ;        {SUBSTRING}
   FUNCTION R S I1 I2 ;  STCRE (S|(I1&I2)) R ;  ENDFUNCTION ;   {STRING TO REAL}
   FUNCTION S  R ;       RECST R '(G23.16)' S ; ENDFUNCTION ;   {REAL TO STRING}
   FUNCTION SF R FORM ;  RECST R FORM SF ;      ENDFUNCTION ;   {REAL TO STRING}
   FUNCTION SI I ; VARIABLE J 1 ; VARIABLE K 1 ; K := ABS(I) ;  {INTEGER STRING}
      SI := SF(K-10*INT(K/10),'(I1)') ; LOOP J 1 LOG(K+.1)/LOG(10) ;
      K := INT(K/10) ; SI := SF(K-10*INT(K/10),'(I1)')&SI ; ENDLOOP ;
      IF I<0 ; SI := '-'&SI ; ENDIF ; ENDFUNCTION ;
   FUNCTION COEF X I ;   DAPEE X I COEF ;         ENDFUNCTION ;    {COEFFICIENT}
   FUNCTION WABS X W ;   DANOW X+0*DD(1) W WABS ; ENDFUNCTION ;  {WEIGHTED NORM}
   FUNCTION DER I V ;    DER := V%I ;             ENDFUNCTION ;     {DERIVATION}
   FUNCTION INTEG I V ;  INTEG := V%(-I) ;        ENDFUNCTION ;    {INTEGRATION}

   PROCEDURE CONTINUE ;  PI := PI ; ENDPROCEDURE ;                {NO OPERATION}
   PROCEDURE SVSCR ; LSCR := -1 ; SCRLEN LSCR ; ENDPROCEDURE ;     {SAVE SCRLEN}

   FUNCTION ILAST A IA1 IA2 ;                 {LAST NONBLANK POSITION IN STRING}
      VARIABLE I 1 ; VARIABLE CH 1 ; CH := ' ' ; I := IA2+1 ;
      WHILE (CH=' ')*(I>IA1) ; I := I-1 ; CH := SS(A,I,I) ; ENDWHILE ;
      ILAST := I ; ENDFUNCTION ;
   FUNCTION IPOS C A ;                 {FIRST POSITION OF CHARACTER C IN STRING}
      VARIABLE LEN 1 ; VARIABLE I 1 ; LEN := LENGTH(A) ; IPOS := 0 ; I := 0 ;
      WHILE I<LEN ; I := I+1 ; IF C=(A|I) ; IPOS := I ; I := LEN ; ENDIF ;
         ENDWHILE ; ENDFUNCTION ;
   PROCEDURE TRCAP A ;              {CONVERT SMALL LETTERS TO CAPITAL IN STRING}
      VARIABLE AC 26 ; VARIABLE AS 26 ;
      VARIABLE LS 1 ; VARIABLE IA 1 ; VARIABLE I 1 ;
      AC := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; AS := 'abcdefghijklmnopqrstuvwxyz' ;
      LS := ILAST(A,1,LENGTH(A)) ;
      IF LS>1 ; LOOP I 2 LS-1 ; IA := IPOS((A|I),AS) ;
         IF IA>0 ; A := (A|(1&(I-1)))&(AC|IA)&(A|((I+1)&LS)) ; ENDIF ; ENDLOOP ;
       I := 1 ; IA := IPOS((A|I),AS) ;
         IF IA>0 ; A := (AC|IA)&(A|((I+1)&LS)) ; ENDIF ;
       I := LS ; IA := IPOS((A|I),AS) ;
         IF IA>0 ; A := (A|(1&(I-1)))&(AC|IA) ; ENDIF ;
      ELSEIF LS=1 ; IA := IPOS((A|1),AS) ;
         IF IA>0 ; A := (AC|IA) ; ENDIF ; ENDIF ; ENDPROCEDURE ;
   PROCEDURE WORDS A N WORD SEP ;   {DELIMIT STRING TO N WORDS SEPARATED BY SEP}
      VARIABLE I 1 ; VARIABLE J 1 ;                   {THE K-TH WORD: A|WORD(K)}
      VARIABLE L 1 ; L := ILAST(A,1,LENGTH(A)) ; N := 0 ; J := 0 ; I := 0 ;
      WHILE I<L ; I := I+1 ;
         IF     (J=0)*((A|I)#SEP) ; J := 1 ; N := N+1 ; WORD(N) := I ;
         ELSEIF (J=1)*((A|I)=SEP) ; J := 0 ; WORD(N) := WORD(N)&(I-1) ; ENDIF ;
         ENDWHILE ;
      IF J=0 ; N := N+1 ; WORD(N) := I ; ENDIF ; WORD(N) := WORD(N)&I ;
      ENDPROCEDURE ;
   PROCEDURE FIELDS A N FIELD SEP ;{DELIMIT STRING TO N FIELDS SEPARATED BY SEP}
      VARIABLE I 1 ; VARIABLE J 1 ;                 {THE K-TH FIELD: A|FIELD(K)}
      VARIABLE L 1 ; L := LENGTH(A) ; N := 0 ; J := 1 ; I := 0 ;
      WHILE I<L ; I := I+1 ;
         IF ((A|I)=SEP) ; N := N + 1; IF I>J ; FIELD(N) := J&(I-1) ;
            ELSEIF LO(1) ; FIELD(N) := 0&0 ; ENDIF ; J := I+1 ; ENDIF ;
         ENDWHILE ; N := N + 1;
      IF I>J ; FIELD(N) := J&I ; ELSEIF LO(1) ; FIELD(N) := 0&0 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE MI M N L IER NO NV NM1 ;                  {INVERTS DA MAP M INTO N}
     {NO,NV,NM1: The current computational order, DA dimension, DA size.}
      VARIABLE C 2 L ; VARIABLE AL 1 L L ; VARIABLE AI 1 L L ; VARIABLE CL 1 L ;
      VARIABLE AN NM1 L ; VARIABLE SM NM1 L ; VARIABLE DDA 1 L ;
      VARIABLE SCR NM1 ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      IF L>NV ; WRITE 6 ' *** ERROR in MI, dim too large' ; QUIT 0 ; ENDIF ;
      LOOP I 1 L ; DDA(I) := DA(I) ; DANOT 1 ; SCR := M(I) ; DANOT NO ;
         C(I) := CONS(SCR) ; AN(I) := M(I)-SCR ; DACLIW SCR L CL ;
         LOOP J 1 L ; AL(I,J) := CL(J) ; ENDLOOP ; N(I) := 0 ; ENDLOOP ;
      LINV AL AI L L IER ; IF IER#0 ; IER := 1 ; ENDIF ;
      IF NO>1 ; POLVAL 101 AN L N L N L ; ENDIF ;
      LOOP I 1 L ; N(I) := 0 ;
         LOOP J 1 L ; N(I) := N(I) + AI(I,J)*DDA(J) ; ENDLOOP ; ENDLOOP ;
      LOOP I 2 NO ; DANOT I ; POLVAL 0 AN L N L N L ;
         LOOP J 1 L ; SM(J) := 0 ; LOOP K 1 L ;
            SM(J) := SM(J) + AI(J,K)*(DDA(K)-N(K)) ; ENDLOOP ; ENDLOOP ;
         LOOP J 1 L ; N(J) := SM(J) ; ENDLOOP ; ENDLOOP ;
      LOOP I 1 L ; SM(I) := DDA(I) - C(I) ; ENDLOOP ; POLVAL 1 N L SM L N L ;
      ENDPROCEDURE ;

   PROCEDURE FOURIERTRANS D L FTO FTA FTP ;
     {ONE DIMENSIONAL FOURIER TRANSFORM ON L EVENLY SPACED DATA POINTS ON
      [0,2*PI) GIVEN IN D()
      RETURNS FTO+1 AMPLITUDE AND PHASES PAIRS IN ARRAYS FTA AND FTP.
      EACH FOURIER ORDER IS GIVEN BY FTA(K)+SIN((K-1)*PHI+FTP(K))}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE DEL 1 ;
      VARIABLE RS LENGTH(D(1)) ; VARIABLE RC LENGTH(D(1)) ;
      RS := 0 ; LOOP J 1 L ; RS := RS + D(J) ; ENDLOOP ;
      FTA(1) := RS/L ; FTP(1) := 0*RS+PI/2 ;
      LOOP I 1 FTO ; DEL := I*2*PI/L ; RS := (D(1)-D(L))*COS(-0.5*DEL) ;
         RC := (D(L)-D(1))*SIN(-0.5*DEL) ; LOOP J 1 L-1 ;
            RS := RS + (D(J+1)-D(J))*COS((J-0.5)*DEL) ;
            RC := RC + (D(J)-D(J+1))*SIN((J-0.5)*DEL) ; ENDLOOP ;
         RS := RS/(PI*I) ; RC := RC/(PI*I) ;
         FTA(I+1) := SQRT(SQR(RS)+SQR(RC)) ;
         FTP(I+1) := VATAN2(RC,RS) ; ENDLOOP ; ENDPROCEDURE ;

{COSY TOOLS}
{**********}

   FUNCTION ME M I ; DAPEE MAP(M) I ME ; ENDFUNCTION ;          {MATRIX ELEMENT}
   FUNCTION MEP M I ; DAPEP MAP(M) I TWOND MEP ; ENDFUNCTION ; {ME W/ PARAMETER}
   FUNCTION MA M II ;                                               {ABERRATION}
      VARIABLE I 1 ; VARIABLE K 1 ; I := II ; DAPEE MAP(M) I MA ;
      WHILE I#0 ; I := I/10 ; K := I ; I := INT(I+.01) ; K := NINT(10*(K-I)) ;
      IF K>TWOND ; MA := MA*PARS(K-TWOND) ;
         ELSEIF TRUE ; MA := MA*PHSP(K) ;  ENDIF ; ENDWHILE ; ENDFUNCTION ;
   FUNCTION PB X Y ; VARIABLE I 1 ; PB := 0 ;                  {POISSON BRACKET}
      LOOP I 1 TWOND 2 ; PB := PB + DER(I,X)*DER(I+1,Y) - DER(I+1,X)*DER(I,Y) ;
         ENDLOOP ; ENDFUNCTION ;
   FUNCTION LEXP A B ; VARIABLE I 1 ; VARIABLE XP NM1 TWOND ;     {LIE EXPONENT}
      LOOP I 1 TWOND 2 ; XP(I) := -DER(I+1,A) ; XP(I+1) := DER(I,A) ; ENDLOOP ;
      DAFLO XP B LEXP TWOND ; ENDFUNCTION ;

   PROCEDURE CPOLVAL LTR POL NPOL ARG NARG RES NRES ;
      VARIABLE RIPOL NM1 2*NPOL ; VARIABLE RIRES 2*NM1 2*NRES ;
      VARIABLE J 1 ; VARIABLE I 2 ; IMUNIT I ;
      LOOP J 1 NPOL ; RIPOL(2*J-1) := REAL(POL(J)) ;
                      RIPOL(2*J  ) := IMAG(POL(J)) ; ENDLOOP ;
      POLVAL LTR RIPOL 2*NPOL ARG NARG RIRES 2*NRES ;
      LOOP J 1 NPOL ; RES(J) := RIRES(2*J-1) + I*RIRES(2*J  ) ; ENDLOOP ;
      ENDPROCEDURE ;

   FUNCTION POLY X Y P IS ;    {EVALUATES POLYNOMIAL(OF ORDER=IS) WITH COEF Pij}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE X1 NM1 ;
      VARIABLE Y1 NM1 ; POLY := 0 ; X1 := 1 ; LOOP I 1 IS+1 ; Y1 := 1 ;
         LOOP J 1 IS+1 ; POLY := POLY + P(I,J)*X1*Y1 ; Y1 := Y*Y1 ;
         ENDLOOP ; X1 := X*X1 ; ENDLOOP ; ENDFUNCTION ;

   PROCEDURE POTI F NF P ;                           {COMPUTES A POTENTIAL TO F}
      VARIABLE I 1 ; VARIABLE K 1 ; VARIABLE FF NM1 ; VARIABLE SCR NM1 ;
      P := 0 ; LOOP I 1 NF ; FF := F(I) ;
         LOOP K I+1 NF ; DAPLU FF K 0 SCR ; FF := SCR ; ENDLOOP ;
         P := P + INTEG(I,FF) ; ENDLOOP ;   DANOT NOC-1 ;
      SCR := 0 ; LOOP I 1 NF ; SCR := SCR + WABS(DER(I,P)-F(I),WAF) ; ENDLOOP ;
      IF SCR>1E-5 ;
         WRITE 6 ' --- WARNING in POTI, error norm = '&S(SCR) ; ENDIF;
      DANOT NOC ; ENDPROCEDURE ;

   FUNCTION FACT N ; VARIABLE I 1 ; FACT := 1 ;                      {FACTORIAL}
      LOOP I 1 N ; FACT := FACT*I ; ENDLOOP ; ENDFUNCTION ;

   FUNCTION NMON NO NV ; VARIABLE I 1 ; NMON := 1 ;        {NUMBER OF MONOMIALS}
      LOOP I 1 NO ; NMON := NMON*(NV+I)/I ; ENDLOOP ; ENDFUNCTION ;

   FUNCTION GAUSS1 X NX DX SIGMA IP MFD ERR ;        {1D GAUSSIAN INTERPOLATION}
      VARIABLE NG  1 ; VARIABLE IXN 1 ; VARIABLE IX  1 ; VARIABLE IXM 1 ;
      NG := NINT(8*SIGMA) ; GAUSS1 := 0 ; IXN := NINT(1+CONS(X)/DX) ;
      IF ((IXN-NG<1)+(IXN+NG>NX)) ;
         ERR := 1 ; LOOP IX IXN-NG IXN+NG ;
         IXM := IX ; IF IX<1 ; IXM := 1 ; ELSEIF IX>NX ; IXM := NX ; ENDIF ;
         GAUSS1 := GAUSS1+MFD(IP,IXM)*EXP(-SQR((IX-1-X/DX)/SIGMA)) ;
         ENDLOOP ;
      ELSEIF TRUE ; ERR := 0 ; LOOP IX IXN-NG IXN+NG ;
         GAUSS1 := GAUSS1+MFD(IP,IX)*EXP(-SQR((IX-1-X/DX)/SIGMA)) ;
         ENDLOOP ;
      ENDIF ; GAUSS1 := GAUSS1/(SQRT(PI)*SIGMA) ; ENDFUNCTION ;

   FUNCTION GAUSS X Z NX NZ DX DZ SIGMA MFD ERR ;    {2D GAUSSIAN INTERPOLATION}
      VARIABLE NG  1 ; VARIABLE IXN 1 ; VARIABLE IZN 1 ; VARIABLE SUMZ NM2 ;
      VARIABLE IX  1 ; VARIABLE IZ  1 ; VARIABLE IXM 1 ; VARIABLE IZM 1 ;
      NG := NINT(8*SIGMA) ; GAUSS := 0 ;
      IXN := NINT(1+CONS(X)/DX) ; IZN := NINT(1+CONS(Z)/DZ) ;
      IF ((IXN-NG<1)+(IXN+NG>NX)+(IZN-NG<1)+(IZN+NG>NZ)) ;
         ERR := 1 ; LOOP IX IXN-NG IXN+NG ; SUMZ := 0 ;
         IXM := IX ; IF IX<1 ; IXM := 1 ; ELSEIF IX>NX ; IXM := NX ; ENDIF ;
         LOOP IZ IZN-NG IZN+NG ;
         IZM := IZ ; IF IZ<1 ; IZM := 1 ; ELSEIF IZ>NZ ; IZM := NZ ; ENDIF ;
         SUMZ := SUMZ+MFD(IXM,IZM)*EXP(-SQR((IZ-1-Z/DZ)/SIGMA)) ; ENDLOOP ;
         GAUSS := GAUSS+SUMZ*EXP(-SQR((IX-1-X/DX)/SIGMA)) ; ENDLOOP ;
      ELSEIF TRUE ; ERR := 0 ; LOOP IX IXN-NG IXN+NG ; SUMZ := 0 ;
         LOOP IZ IZN-NG IZN+NG ;
         SUMZ := SUMZ+MFD(IX,IZ)*EXP(-SQR((IZ-1-Z/DZ)/SIGMA)) ; ENDLOOP ;
         GAUSS := GAUSS+SUMZ*EXP(-SQR((IX-1-X/DX)/SIGMA)) ; ENDLOOP ;
      ENDIF ; GAUSS := GAUSS/(PI*SIGMA*SIGMA) ; ENDFUNCTION ;

   PROCEDURE WSET W ; WAF := W ; ENDPROCEDURE ;
   PROCEDURE ESET E ; EPS := E ; ENDPROCEDURE ;
   PROCEDURE DSET E ; DAEPS E ; DEPS := E ; ENDPROCEDURE ;

  PROCEDURE CG PIC X Y N ;                            {DRAWS POLYGON IN PICTURE}
      VARIABLE I 1 ; GRMOVE X(1) Y(1) 0 PIC ;
      LOOP I 2 N ; GRDRAW X(I) Y(I) 0 PIC ; ENDLOOP ; ENDPROCEDURE ;

{COSY PHYSICS}
{************}

   FUNCTION ENGE IMP IEE IEM S ; {COMPUTES THE ENGE FUNCTION OF THE ENTRANCE
      OR EXIT (IEE) FRINGE FIELD OF AN MAGN OR ELEC (IEM) 2*IMP POLE USING
      THE ENGE COEFFICIENTS IN ENGEC}
      IF CONS(S)<-3 ; ENGE := 1+0*S ; ELSEIF CONS(S)>5 ; ENGE := 0*S ;
      ELSEIF LO(1) ;                                   {Check the S value range}
         ENGE :=      ENGEC(IMP,IEE,IEM,1) + S*( ENGEC(IMP,IEE,IEM,2)
                + S*( ENGEC(IMP,IEE,IEM,3) + S*( ENGEC(IMP,IEE,IEM,4)
                + S*( ENGEC(IMP,IEE,IEM,5) + S*  ENGEC(IMP,IEE,IEM,6) )))) ;
         IF     CONS(ENGE)<-60 ; ENGE := -60 ;
         ELSEIF CONS(ENGE)>30  ; ENGE :=  30 ; ENDIF ;
         ENGE := 1/(1+EXP(ENGE)) ; ENDIF ; ENDFUNCTION ;

   PROCEDURE FC IMP IEE IEM C1 C2 C3 C4 C5 C6 ;   {SETS ENGE FRINGE FIELD COEFF}
      VARIABLE S 1 ; VARIABLE IFER 1 ; VARIABLE F0 1 ; VARIABLE F 1 ;
      ENGEC(IMP,IEE,IEM,1) := C1 ; ENGEC(IMP,IEE,IEM,2) := C2 ;
      ENGEC(IMP,IEE,IEM,3) := C3 ; ENGEC(IMP,IEE,IEM,4) := C4 ;
      ENGEC(IMP,IEE,IEM,5) := C5 ; ENGEC(IMP,IEE,IEM,6) := C6 ;
      IFER := 0 ; F0 := ENGE(IMP,IEE,IEM,5) ;
      LOOP S 4 -3 -1 ; F:= ENGE(IMP,IEE,IEM,S) ;
         IF F<F0 ; IFER := 1 ; ENDIF ; F0 := F ; ENDLOOP ;
      IF IFER=1 ; WRITE 6 ' *** ERROR in FC, not monotonic.' ; ENDIF ;
      IF ABS(ENGE(IMP,IEE,IEM,5))>0.001 ; IFER := 1 ;
         WRITE 6 ' *** ERROR in FC, not 0 outside.' ; ENDIF ;
      IF ABS(ENGE(IMP,IEE,IEM,-3)-1)>0.001 ; IFER := 1 ;
         WRITE 6 ' *** ERROR in FC, not 1 inside.' ; ENDIF ;
      IF IFER=1 ;
      WRITE 6 '   S=z/D   Enge function: outside(S=5) to inside(S=-3)' ;
      LOOP S 5 -3 -1 ; F:= ENGE(IMP,IEE,IEM,S) ;
      WRITE 6 SF(S,'(F6.0)')&SF(F,'(G16.4)') ; ENDLOOP ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE FP IMP IEE IEM TL ID IU ;           {DRAW PICTURE OF ENGE FUNCTION}
      VARIABLE PIC 1000 ; VARIABLE X1 1 ; VARIABLE X2 1 ; VARIABLE XD 1 ;
      VARIABLE X10 1 ; VARIABLE X20 1 ; VARIABLE XP 10 ; VARIABLE I 1 ;
      VARIABLE Y1 1 ; VARIABLE Y2 1 ; VARIABLE YD 1 ; VARIABLE YP 30 ;
      VARIABLE X 1 201 ; VARIABLE Y 1 201 ; VARIABLE NI 1 ; VARIABLE JD 1 NV ;
      VARIABLE T 100 ; VARIABLE TMP 10 ; T := 'Enge Function' ;
      IF ID>0 ; IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before FP.' ; QUIT 0 ;
         ELSEIF ID>NO ; WRITE 6 ' *** ERROR in FP, order > NO.' ; QUIT 0 ;
         ENDIF ; LOOP I 1 NV ; JD(I) := 0 ; ENDLOOP ; JD(1) := ID ;
         T := T&' Derivative '&SI(ID) ; ENDIF ;
      IF      IMP=1 ; TMP := 'Di' ;    ELSEIF IMP=2 ; TMP := 'Quadru' ;
       ELSEIF IMP=3 ; TMP := 'Sextu' ; ELSEIF IMP=4 ; TMP := 'Octu' ;
       ELSEIF IMP=5 ; TMP := 'Deca' ;  ELSEIF IMP=6 ; TMP := 'Duodeca' ;
       ELSEIF (IMP>6)*(IMP<16) ; TMP := SI(2*IMP)&'-' ;
       ELSEIF 1=1 ; WRITE 6
         ' *** ERROR in FP, not supported. IMP='&SI(IMP) ; QUIT 0 ; ENDIF ;
      T := T&', ' ; IF IEM=2 ; T := T&'E-' ; ENDIF ; T := T&TMP&'pole, ' ;
      IF IEE=1 ; T := T&'Entrance' ; ELSEIF IEE=2 ; T := T&'Exit' ; ENDIF ;
      IF TYPE(TL)=TYPE(' ') ; IF TL#' ' ; T := T&': '&TL ; ENDIF ; ENDIF ;
      NI := 200 ; X1 := -3.5 ; X2 := 5.5 ; XD := X2-X1 ; X10 := -3 ; X20 := 5 ;
      IF ID>0 ; Y1 := 1.D30 ; Y2 := -1.D30 ; XP := X1+DA(1) ;
         LOOP I 1 NI+1 ; X(I) := CONS(XP) ; YP := ENGE(IMP,IEE,IEM,XP) ;
            DAPEA YP JD NV TMP ; Y(I) := TMP ;
            Y1 := MIN(Y1,TMP) ; Y2 := MAX(Y2,TMP) ; XP := XP+XD/NI ; ENDLOOP ;
       ELSEIF 1=1 ; Y1 := 0 ; Y2 := 1 ; XP := X1 ;
         LOOP I 1 NI+1 ; X(I) := XP ; Y(I) := ENGE(IMP,IEE,IEM,XP) ;
            XP := XP+XD/NI ; ENDLOOP ; ENDIF ;      YD := Y2-Y1 ;
      CLEAR PIC ; GRCOLR 5 PIC ; GRMOVE X1 0 0 PIC ; GRDRAW X2 0 0 PIC ;
      GRMOVE   0 Y1-0.1*YD 0 PIC ; GRDRAW   0 Y2+0.1*YD 0 PIC ;
      GRMOVE X10 Y1-0.1*YD 0 PIC ; GRDRAW X10 Y2+0.1*YD 0 PIC ;
      GRMOVE X20 Y1-0.1*YD 0 PIC ; GRDRAW X20 Y2+0.1*YD 0 PIC ;
      IF ID<1 ; GRMOVE X1 Y2 0 PIC ; GRDRAW X2 Y2 0 PIC ; ENDIF ;
      GRCOLR 1 PIC ; GRMOVE X1 Y1-0.1*YD 0 PIC ; GRDRAW X2 Y1-0.1*YD 0 PIC ;
      GRDRAW X2 Y2+0.1*YD 0 PIC ; GRDRAW X1 Y2+0.1*YD 0 PIC ;
      GRDRAW X1 Y1-0.1*YD 0 PIC ; CG PIC X Y NI+1 ; GRCOLR 2 PIC ;
      IF ID>0 ; TMP := '(G10.3)' ; ELSEIF ID<1 ; TMP := '(I2)' ; ENDIF ;
      GRMOVE   X2+0.005*XD Y2-0.01*YD 0 PIC ; GRCHAR SF(Y2,TMP) PIC ;
      GRMOVE   X2+0.005*XD Y1-0.01*YD 0 PIC ; GRCHAR SF(Y1,TMP) PIC ;
      GRMOVE   X2+0.005*XD   -0.01*YD 0 PIC ; GRCHAR ' 0'       PIC ;
      GRMOVE   X2-0.025*XD Y1-0.15*YD 0 PIC ; GRCHAR SF(X2,'(F3.1)') PIC ;
      GRMOVE   X1-0.035*XD Y1-0.15*YD 0 PIC ; GRCHAR SF(X1,'(F4.1)') PIC ;
      GRMOVE  X20-0.007*XD Y1-0.15*YD 0 PIC ; GRCHAR SI(X20)    PIC ;
      GRMOVE  X10-0.015*XD Y1-0.15*YD 0 PIC ; GRCHAR SI(X10)    PIC ;
      GRMOVE     -0.007*XD Y1-0.15*YD 0 PIC ; GRCHAR '0'        PIC ;
      GRMOVE X20/2-0.05*XD Y1-0.15*YD 0 PIC ; GRCHAR 'outside'  PIC ;
      GRMOVE X10/2-0.04*XD Y1-0.15*YD 0 PIC ; GRCHAR 'inside'   PIC ;
      GRMOVE X2+0.07*XD    Y1-0.15*YD 0 PIC ; GRCHAR 'x 2d'     PIC ;
      GRMOVE X2+0.15*XD 0 0 PIC ;
      GRMOVE X1 Y2+0.15*YD 0 PIC ; GRCHAR T PIC ; WRITE IU PIC ; ENDPROCEDURE ;

   PROCEDURE FD ; {SETS DEFAULT FRINGE FIELD COEFFICIENTS;
      MEASURED DATA FROM PEP AT SLAC. REFERENCE: K.L. BROWN AND J. E. SPENCER,
      IEEE TRANS. NUCL. SCI., VOL.NS-28, NO. 3, JUNE 1981}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ; LOOP J 1 2 ; LOOP K 1 2 ;
      FC 1 J K 0.478959 1.911289 -1.185953 1.630554 -1.082657 0.318111 ;
      FC 2 J K 0.296471 4.533219 -2.270982 1.068627 -0.036391 0.022261 ;
      LOOP I 3 15 ;
      FC I J K 0.176659 7.153079 -3.113116 3.444311 -1.976740 0.540068 ;
      ENDLOOP ; ENDLOOP ; ENDLOOP ; LE := 1 ; ENDPROCEDURE ;

   PROCEDURE DEF ;
      AMU := 1.66053873D-27 ; EZERO := 1.602176462D-19 ; CLIGHT:= 2.99792458D8 ;
      AMUMEV := AMU*SQR(CLIGHT)/EZERO*1D-6 ;
      PI := 3.1415926535897932384626433832795028842 ; DEGRAD := PI / 180 ;
      ESET 1E-10 ; WSET .1 ; DSET 1E-16 ; LTRUE TRUE ; LFALSE FALSE ;
      ENDPROCEDURE ;

   PROCEDURE CR ; VARIABLE I 1 ;                               {CLEARS ALL RAYS}
      LOOP I 1 8 ; RAY(I) := 0 ; RSC(I) := 0 ; ENDLOOP ; NRAY := 0 ;
      LOOP I 1 3 ; SPI(I) := 0 ; SSC(I) := 0 ; ENDLOOP ; NSPN := 0 ; LCR := 1 ;
      RCOL := 1 ; REMAIN := 1 ; REMOVE := 0 ; LENV := 0 ; ENDPROCEDURE ;

   PROCEDURE CO NNO ; NOC := NNO ;  DANOT NOC ;  ENDPROCEDURE ;   {ORDER CHANGE}
   PROCEDURE OV ORD NND NNP ; VARIABLE I 1 ;   {SETS ORDER, NUMBER OF VARIABLES}
      IF NND>3 ;      WRITE 6 ' *** ERROR in OV, ND > 3 ' ; QUIT 0 ;
      ELSEIF NND<0 ;  WRITE 6 ' *** ERROR in OV, ND < 0 ' ; QUIT 0 ;
      ELSEIF NNP<0 ;  WRITE 6 ' *** ERROR in OV, NP < 0 ' ; QUIT 0 ; ENDIF ;
      NO := ORD ; ND := NND ; TWOND := 2*ND ; NP := NNP ; NV := TWOND + NP ;
      IF LWA<0 ; LWA := -LWA ; NV := NV+1 ; ENDIF ;
      IF NV>40 ; IF LWA=0 ; WRITE 6 '*** ERROR in OV, 2*ND+NP > 40 ' ;
             ELSEIF LWA#0 ; WRITE 6 '*** ERROR in OV, 2*ND+NP > 39 ' ; ENDIF ;
         QUIT 0 ; ENDIF ;
      DEF ; IF ND=0 ; DAINI NO NV 0 NM1 ;
         ELSEIF TRUE ; DAINI NO+1 MAX(NV,3) 0 NM1 ; ENDIF ;
      NM2 := NMON(NO,TWOND+NP) ; NM3 := NMON(NO+1,3) ;
      NMP := NMON(NO,NP) ; LOOP I NV+1 20 ; DD(I) := 0 ; ENDLOOP ;
      SVSCR ; LSCR := MAX(50000,LSCR) ; LSCR := MAX(LSCR,2*NM1) ; SCRLEN LSCR ;
      LSCT := 50000 ; LOOP I 1 MAX(NV,3) ; DD(I) := DA(I) ; ENDLOOP ;
      DSET 1E-16 ; CO NO ; LOV := 1 ; LRP := 0 ; LUM := 0 ; LPI := 0 ;
      LCB := 1 ; LPG := 0 ; LPS := 0 ; LM := 0 ; LFR := 0 ; LFR2 := 0 ;
      LENV := 0 ; LSYS := 1 ; LCR := 0 ; LCE := 1 ;
      LAX := 1 ; LTRR := 0 ; LTRI := 0 ;
      LTRPRAY := 0 ; LTRPSPI := 0 ; CR ; NRAYTRA0 := 251 ;  NRAYTRA := NRAY ;
      FD ; ENDPROCEDURE ;

   FUNCTION PARA I ;                                  {SET PARAMETER IDENTIFIER}
      PARA := 1 ;
      IF     LWA=1 ; IF TWOND+I<NV ;   PARA := 1+DA(TWOND+I) ; ENDIF ;
      ELSEIF LWA#1 ; IF TWOND+I<NV+1 ; PARA := 1+DA(TWOND+I) ; ENDIF ; ENDIF ;
      ENDFUNCTION ;

   PROCEDURE SB PX PA R12 PY PB R34 PT PD R56 PG PZ ;  {SETS PHASE SPACE WIDTHS}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before SB' ; QUIT 0 ; ENDIF ;
      PHSP(1) := PX ; PHSP(2) := PA ; PHSP(3) := PY ; PHSP(4) := PB ;
      PHSP(5) := PT ; PHSP(6) := PD ; PHSP(7) := PG ; PHSP(8) := PZ ;
      PHSR(1) := R12 ; PHSR(2) := R34 ; PHSR(3) := R56 ; LPS := 1 ;
      ENDPROCEDURE ;

   PROCEDURE SP P1 P2 P3 P4 P5 P6 ;                      {SETS PARAMETER WIDTHS}
      PARS(1) := P1 ; PARS(2) := P2 ; PARS(3) := P3 ; PARS(4) := P4 ;
      PARS(5) := P5 ; PARS(6) := P6 ; ENDPROCEDURE ;

   PROCEDURE LOCTRA X Y Z T P A NAP ;
      {TRANSFORMATION MAP FROM FINAL TO INITIAL SYSTEM}
      VARIABLE CT NMP ; VARIABLE ST NMP ; VARIABLE CP NMP ; VARIABLE SP NMP ;
      VARIABLE CA NMP ; VARIABLE SA NMP ; VARIABLE CB NMP ; VARIABLE SB NMP ;
      VARIABLE CM NMP ; VARIABLE SM NMP ; VARIABLE N NMP ;
      CT := COS(T) ; ST := SIN(T) ; CP := COS(P) ;
      SP := SIN(P) ; CA := COS(A) ; SA := SIN(A) ;
      IF ABS(ST*SP)=1 ; CB := 0 ; SB := 1 ; ELSEIF TRUE ;
      N := SQRT(1-SQR(ST)*SQR(SP)) ; CB := CP/N ; SB := CT*SP/N ; ENDIF ;
      CM := CA*CB+SA*SB ; SM := SA*CB-CA*SB ;
      NAP(1) := X+(CM*CT*CP-SM*SP)*DD(1)-(CM*SP+SM*CT*CP)*DD(2)+(ST*CP)*DD(3) ;
      NAP(2) := Y+(CM*CT*SP+SM*CP)*DD(1)+(CM*CP-SM*CT*SP)*DD(2)+(ST*SP)*DD(3) ;
      NAP(3) := Z-(CM*ST         )*DD(1)+(      SM*ST   )*DD(2)+(CT   )*DD(3) ;
      ENDPROCEDURE ;

   PROCEDURE LOCSET X Z P S V T ;     {SETS LOCAL CARTESIAN COORDINATES OF AXIS}
      XLOC := X ; ZLOC := Z ; PLOC := P ; SLOC := S ; VLOC := V ;
      TLOC := T ; ENDPROCEDURE ;

   PROCEDURE MR NAP LAP ;                                  {REVERSES NAP TO LAP}
      VARIABLE COD 1 NV ; VARIABLE NUM 1 ; VARIABLE I 1 ;  VARIABLE MM NM1 NV ;
      NUM := MIN(TWOND,4) ; LOOP I 1 TWOND ; MM(I) := NAP(I) ; ENDLOOP ;
      LOOP I TWOND+1 NV ; MM(I) := DD(I) ; ENDLOOP ; MI MM MM NV I NOC NV NM1 ;
      IF I#0 ; WRITE 6 ' *** ERROR in REV, no inverse' ; QUIT 0 ; ENDIF ;
      LOOP I 2 NUM 2 ; COD(I-1) := DD(I-1) ; COD(I) := -DD(I) ;
      MM(I) := -MM(I) ; ENDLOOP ; LOOP I NUM+1 NV ; COD(I) := DD(I) ; ENDLOOP ;
      IF ND>2 ; COD(5) := -DD(5) ; MM(5) := -MM(5) ; ENDIF ;
      POLVAL 1 MM TWOND COD NV LAP TWOND ; ENDPROCEDURE ;

   PROCEDURE MT IAP NAP PHI ; VARIABLE R 1 4 4 ;        {MAP OF ROTATED ELEMENT}
      VARIABLE COD NM1 NV ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE S 1 ;
      VARIABLE C 1 ; IF PHI=0 ; C := 1 ; S := 0 ; ELSEIF ABS(PHI+90)=180 ;
      C := 0 ; S := 1 ; ELSEIF ABS(PHI)=180 ; C := -1 ; S := 0 ;
      ELSEIF ABS(PHI-90)=180 ; C := 0 ; S := -1 ; ELSEIF TRUE ;
      C := COS(PHI*DEGRAD) ; S := SIN(PHI*DEGRAD) ; ENDIF ;
      IF (TWOND=1)*(S#0) ; WRITE 6 ' *** ERROR in MT, ND too low' ; QUIT 0 ;
      ENDIF ; LOOP I 1 4 ; LOOP J 1 4 ; R(I,J) := 0 ; ENDLOOP ; R(I,I) := C ;
      ENDLOOP ; LOOP I 1 2 ; R(I,I+2) := S ; R(I+2,I) := -S ; ENDLOOP ;
      LOOP I 1 4 ; COD(I) := 0 ; LOOP J 1 4 ; COD(I) := COD(I)+R(I,J)*DD(J) ;
         ENDLOOP ; ENDLOOP ; LOOP I 5 NV ; COD(I) := DD(I) ; ENDLOOP ;
      POLVAL 1 IAP TWOND COD NV NAP TWOND ; LOOP I 1 4 ; COD(I) := 0 ;
      LOOP J 1 4 ; COD(I) := COD(I)+R(J,I)*NAP(J) ; ENDLOOP ; ENDLOOP ;
      LOOP I 1 4 ; NAP(I) := COD(I) ; ENDLOOP ; ENDPROCEDURE ;

   FUNCTION SIGMA I J ; VARIABLE K 1 ;                     {BEAMS SIGMA MATRIX}
      IF (I=J)*(INT(I/2)#I/2) ;
         SIGMA := SQR(PHSP(I)*ME(I,I))+SQR(PHSP(I+1)*ME(I,I+1))
         +2*PHSP(I)*PHSP(I+1)*PHSR((I+1)/2)*ME(I,I)*ME(I,I+1) ;
      ELSEIF (I=J)*(INT(I/2)=I/2) ;
         SIGMA := SQR(PHSP(I-1)*ME(I,I-1))+SQR(PHSP(I)*ME(I,I))
         +2*PHSP(I-1)*PHSP(I)*PHSR(I/2)*ME(I,I-1)*ME(I,I) ;
      ELSEIF (ABS(I-J)=1)*(INT(MAX(J,I)/2)*2=MAX(J,I)) ; K := MIN(I,J) ;
         SIGMA := SQR(PHSP(K))*ME(K,K)*ME(K+1,K)
         +SQR(PHSP(K+1))*ME(K,K+1)*ME(K+1,K+1) ; SIGMA := SIGMA
         +PHSP(K)*PHSP(K+1)*PHSR((K+1)/2)*(ME(K,K)*ME(K+1,K+1)
         +ME(K,K+1)*ME(K+1,K)) ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR in SIGMA, wrong element' ; QUIT 0 ;
      ENDIF ; ENDFUNCTION ;

   PROCEDURE UPDATEMAP MAPT MAPO MAPU SPNT SPNO SPNU ;       {UPDATES MAP, SPIN}
     {Let the momentary set (MAPT,SPNT) act on the previous set (MAPO,SPNO),
      resulting in the updated set (MAPU,SONU).}
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE I 1 ;
      PROCEDURE SPNMUL ; VARIABLE J 1 ; VARIABLE K 1 ;
         VARIABLE SM NM2 3 3 ; VARIABLE SV NM2 9 ; VARIABLE SVO NM2 9 ;
         LOOP I 1 3 ; LOOP J 1 3 ; SM(I,J) := SPNO(I,J) ;
            SVO(3*(I-1)+J) := SPNT(I,J) ; ENDLOOP ; ENDLOOP ;
         POLVAL 2 SVO 9 MS NV SV 9 ;
         LOOP I 1 3 ; LOOP J 1 3 ; SPNU(I,J) := 0 ;
            LOOP K 1 3 ; SPNU(I,J) := SPNU(I,J) + SV(3*(I-1)+K)*SM(K,J) ;
               ENDLOOP ; ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;
      LOOP I 1 TWOND ; MS(I) := MAPO(I) ; ENDLOOP ;
      LOOP I TWOND+1 NV ; MS(I) := DD(I) ; ENDLOOP ;
      POLVAL 1 MAPT TWOND MS NV MAPU TWOND ;
      IF LSPN=1 ; SPNMUL ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE UPDATE IM IR ;      {UPDATES MAP, SPIN, RAY, AXIS, SYSTEM GRAPHICS}
      VARIABLE PIC LSCT ; VARIABLE RB 1 ; VARIABLE COD 1 3 ;
      VARIABLE XF 1 ; VARIABLE YF 1 ; VARIABLE ZF 1 ; VARIABLE SF 1 ;
      VARIABLE I 1 ; VARIABLE J 1 ;
      PROCEDURE SPNVEC ; VARIABLE SVO NM2 9 ; VARIABLE SSCM NRAY 9 ;
         VARIABLE SCRV NRAY 3 ; VARIABLE SCR NRAY ;
         IF LCR=1 ; LCR := 0 ;                {AN INITIAL CHECK OF SPIN VECTORS}
            SCR := 0 ; LOOP I 1 3 ; SCR := SCR+SQR(SPI(I)) ; ENDLOOP ;
            VELSET SCR 1 1 ; IF VMIN(SCR)<1E-3 ;
               WRITE 6 ' *** ERROR in UPDATE, there is a zero spin vector' ;
               QUIT 0 ; ENDIF ; ENDIF ;
         LOOP I 1 3 ; LOOP J 1 3 ; SVO(3*(I-1)+J) := SSCR(I,J) ; ENDLOOP ;
            ENDLOOP ; POLVAL 2 SVO 9 RAY 8 SSCM 9 ; SCR := 0 ;
         LOOP I 1 3 ; SCRV(I) := 0 ;
            LOOP J 1 3 ; SCRV(I) := SCRV(I)+SSCM(3*(I-1)+J)*SPI(J) ; ENDLOOP ;
            SCR := SCR+SQR(SCRV(I)) ; ENDLOOP ;
         SCR := SQRT(SCR) ; VELSET SCR 1 1 ;
         LOOP I 1 3 ; SPI(I) := SCRV(I)/SCR ; ENDLOOP ; ENDPROCEDURE ;
      PROCEDURE NEWENV ;
         LOOP I 1 MIN(TWOND,4) 2 ; J := (I+1)/2 ;
            ERAY(I) := SQRT(SQR(PHSP(I)*ME(I,I))+SQR(PHSP(I+1)*ME(I,I+1))
                       +2*PHSP(I)*PHSP(I+1)*PHSR(J)*ME(I,I)*ME(I,I+1)) ;
            ERAY(I+1) := SQR(PHSP(I))*ME(I,I)*ME(I+1,I)
                        +SQR(PHSP(I+1))*ME(I,I+1)*ME(I+1,I+1) ;
            ERAY(I+1) := (PHSP(I)*PHSP(I+1)*PHSR(J)*
                         (ME(I,I)*ME(I+1,I+1)+ME(I,I+1)*ME(I+1,I))
                        +ERAY(I+1))/ERAY(I) ;
            EMAX(J) := MAX(EMAX(J),ERAY(I)) ; ENDLOOP ; ENDPROCEDURE ;
      PROCEDURE CTR X Y Z ; COD(1) := X ; COD(2) := Y ; COD(3) := Z ;
         POLVAL -1 GTRA 3 COD 3 COD 3 ;
         XF := COD(1) ; YF := COD(2) ; ZF := COD(3) ; ENDPROCEDURE ;
      PROCEDURE CURV X2 Y2 A1 B1 A2 B2 PIC ;
        {Draw a curve from the previous point in PIC to (X2,Y2)
         with the starting angle (A1,B1) and the ending angle (A2,B2).
         (X2,Y2), (A1,B1), (A2,B2) are in the local beam dynamics coordinates.}
         VARIABLE T1X 1 ; VARIABLE T1Y 1 ; VARIABLE T1Z 1 ;
         VARIABLE T2X 1 ; VARIABLE T2Y 1 ; VARIABLE T2Z 1 ;
         IF LPG#0 ; CTR X2*LPG Y2*LPG 0 ;
            T1X := COS(GPLOC-PLOC)*A1*LPG-SIN(GPLOC-PLOC) ; T1Y := B1*LPG ;
            T1Z := COS(GPLOC-PLOC)+SIN(GPLOC-PLOC)*A1*LPG ;
            T2X := COS(GPLOC)*A2*LPG-SIN(GPLOC) ;           T2Y := B2*LPG ;
            T2Z := COS(GPLOC) +SIN(GPLOC)*A2*LPG ;
           ELSEIF TRUE ; XF := X2 ; YF := Y2 ; ZF := SF ;
            T1X := A1 ; T1Y := B1 ; T1Z := 1 ;
            T2X := A2 ; T2Y := B2 ; T2Z := 1 ; ENDIF ;
         GRCURV ZF XF YF T1Z T1X T1Y T2Z T2X T2Y PIC ; ENDPROCEDURE ;
      PROCEDURE LINE IS P X Y Z SZ ;
        {Draw a line (IS=1, move only with IS=0) to (X,Y,Z,SZ).}
         IF LPG#0 ;
            IF P#0 ; CTR (RB+X*LPG)*COS(PLOC)-RB Y*LPG -(RB+X*LPG)*SIN(PLOC) ;
               ELSEIF TRUE ; CTR X*LPG Y*LPG Z ; ENDIF ;
            ELSEIF TRUE ; XF := X ; YF := Y ; ZF := SZ ; ENDIF ;
         IF IS=0 ;        GRMOVE ZF XF YF SYS ;
            ELSEIF TRUE ; GRDRAW ZF XF YF SYS ; ENDIF ; ENDPROCEDURE ;
      PROCEDURE ELEM ; IF MAX(ABS(DR*LPG),ABS(DR))>1E-10 ;    {DRAW ELEMENT BOX}
         RB := 1D6 ; IF PLOC#0 ; RB := SLOC/PLOC ; ENDIF ;
         LINE 0 PLOC -DR -DR -SLOC SPOS ;    {The starting box in the X-Y plane}
         LINE 1 PLOC  DR -DR -SLOC SPOS ; LINE 1 PLOC  DR  DR -SLOC SPOS ;
         LINE 1 PLOC -DR  DR -SLOC SPOS ; LINE 1 PLOC -DR -DR -SLOC SPOS ;
         IF ABS(SLOC)>1E-5 ;
            LINE 0 PLOC  DR  DR -SLOC SPOS ; CURV  DR  DR 0 0 0 0 SYS ;
            LINE 0 PLOC -DR -DR -SLOC SPOS ; CURV -DR -DR 0 0 0 0 SYS ;
            LINE 0 PLOC  DR -DR -SLOC SPOS ; CURV  DR -DR 0 0 0 0 SYS ;
            LINE 0 PLOC -DR  DR -SLOC SPOS ; CURV -DR  DR 0 0 0 0 SYS ;
            IF LCE#0 ;                                        {The element name}
               XF := -DR*.98 ; YF := -DR*.98 ; ZF := DR/10 ;
               IF LPG=0 ; ZF := ZF+SPOS ;
               ELSEIF PLOC=0 ; CTR XF*LPG YF*LPG ZF*LPG-SLOC ;
               ELSEIF TRUE ; CTR (RB+XF*LPG)*COS(PLOC*(1-ZF*LPG/SLOC))-RB
                         YF*LPG -(RB+XF*LPG)*SIN(PLOC*(1-ZF*LPG/SLOC)) ; ENDIF ;
               GRMOVE ZF XF YF SYS ; GRCHAR CE SYS ; ENDIF ;
            LINE 0 0 -DR  DR 0 SF ;            {The ending box in the X-Y plane}
            LINE 1 0 -DR -DR 0 SF ; LINE 1 0  DR -DR 0 SF ;
            LINE 1 0  DR  DR 0 SF ; LINE 1 0 -DR  DR 0 SF ; ENDIF ; ENDIF ;
         ENDPROCEDURE ;
      IF IM#0 ; UPDATEMAP MSC MAP MAP SSCR SPNR SPNR ; ENDIF ;
      IF IR*NRAY#0 ; IF (LSPN=1)*(NSPN>0) ; SPNVEC ; ENDIF ;
         POLVAL 1 MSC TWOND RAY 8 RAY TWOND ; ENDIF ;
      IF LENV=1 ; NEWENV ; ENDIF ;
      XLOC := XLOC*LCB ; PLOC := PLOC*LCB ;
      GPLOC := GPLOC+PLOC ; SF := SPOS+SLOC ;
      LOCTRA XLOC 0 ZLOC -PLOC 0 0 LTRA ; POLVAL 1 GTRA 3 LTRA 3 GTRA 3 ;
      IF LPI#0 ; POLVAL 101 GTRA 3 LTRA 3 COD 3 ;
         IF LSYS#0 ; ELEM ; ENDIF ;
        {Update rays}
         RAY(1) := RAY(1)*LCB ; RAY(2) := RAY(2)*LCB ; RSC(2) := RSC(2)*LCB ;
         LOOP I 1 NRAYTRA ; PIC := TRA(I) ;
            CURV RAY(1)|I RAY(3)|I RSC(2)|I RSC(4)|I RAY(2)|I RAY(4)|I PIC ;
            TRA(I) := PIC ; ENDLOOP ;
         RAY(1) := RAY(1)*LCB ; RAY(2) := RAY(2)*LCB ; RSC(2) := RSC(2)*LCB ;
        {Update envelope}
         IF LENV=1 ;
            CURV ERAY(1) ERAY(3) ERSC(2) ERSC(4) ERAY(2) ERAY(4) ETRA ; ENDIF ;
         ENDIF ;
      SPOS := SF ; XLOC := XLOC*LCB ; PLOC := PLOC*LCB ;
      IF LPI*IR#0 ; LOOP I 1 8 ; RSC(I) := RAY(I) ; ENDLOOP ;
         LOOP I 1 4 ; ERSC(I) := ERAY(I) ; ENDLOOP ;
         IF NSPN>0 ; LOOP I 1 3 ; SSC(I) := SPI(I) ; ENDLOOP ; ENDIF ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE UMS ; VARIABLE I 1 ; VARIABLE J 1 ;             {SETS MSC TO UNITY}
      IF LRP=0 ; WRITE 6 ' *** ERROR, call RP before UMS ' ; QUIT 0 ; ENDIF ;
      LOOP I 1 8 ; MSC(I) := XX(I) ; ENDLOOP ;
      IF LSPN=1 ; LOOP I 1 3 ; LOOP J 1 3 ; SSCR(I,J) := 0*DD(1) ; ENDLOOP ;
         SSCR(I,I) := 1 + 0*DD(1) ; ENDLOOP ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE UM ; VARIABLE I 1 ; VARIABLE J 1 ;              {SETS MAP TO UNITY}
      IF LRP=0 ; WRITE 6 ' *** ERROR, call RP before UM ' ; QUIT 0 ; ENDIF ;
      LOOP I 1 8 ; MAP(I) := XX(I) ; MSC(I) := MAP(I) ; ENDLOOP ;
      LOOP I 1 3 ; AXP(I) := 0 ; AXD(I) := 0 ; ENDLOOP ;
      LTRA(1) := DD(1) ; LTRA(2) := DD(2) ; LTRA(3) := DD(3) ;
      GTRA(1) := DD(1) ; GTRA(2) := DD(2) ; GTRA(3) := DD(3) ;
      IF LSPN=1 ; LOOP I 1 3 ; LOOP J 1 3 ; SPNR(I,J) := 0 ; SSCR(I,J) := 0 ;
         ENDLOOP ; SPNR(I,I) := 1 ; SSCR(I,I) := 1 ; ENDLOOP ; ENDIF ;
      LUM := 1 ; SPOS := 0 ; GPLOC := 0 ; NCT := 0 ; NCCT := 0 ; ENDPROCEDURE ;

   PROCEDURE SM M ;                               {SAVES THE MOMENTARY MAP TO M}
      VARIABLE I 1 ; LOOP I 1 TWOND ; M(I) := MAP(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE SNM N M ;                                    {SAVES THE MAP N TO M}
      VARIABLE I 1 ; LOOP I 1 TWOND ; M(I) := N(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE SSM M ;                         {SAVES THE MOMENTARY SPIN MAP TO M}
      VARIABLE I 1 ; VARIABLE J 1 ; LOOP I 1 3 ; LOOP J 1 3 ;
         M(I,J) := SPNR(I,J) ; ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE SSNM N M ; VARIABLE I 1 ; VARIABLE J 1 ;{SAVES THE SPIN MAP N TO M}
      LOOP I 1 3 ; LOOP J 1 3 ; M(I,J) := N(I,J) ; ENDLOOP ; ENDLOOP ;
      ENDPROCEDURE ;

   PROCEDURE AM M ;                       {LETS M ACT ON MOMENTARY MAP AND RAYS}
      VARIABLE I 1 ; LOOP I 1 TWOND ; MSC(I) := M(I) ; ENDLOOP ;
      LOCSET 0 0 0 0 0 0 ; UPDATE 1 1 ; ENDPROCEDURE ; {** i added AM1 to utilities.fox}
      {** it does the exact same thing as AM here, but}
      {**                          (1) clears MSC, SSCR prior to anything else}
      {**                          (2) accepts a second argument, which is written to SSCR}
      {** hence, upon UPDATE 1 1; both maps act on the momentary orbital and spin transfer maps}
      {** I also think UMS MUST be called here, b/c SSCR hasnt been initialized to the identity @AA}

   PROCEDURE ANM N M O ;                    {LETS N ACT ON M, SAVES RESULT IN O}
      VARIABLE I 1 ; VARIABLE MM NM1 NV ; LOOP I 1 TWOND ; MM(I) := M(I) ;
      ENDLOOP ; LOOP I TWOND+1 NV ; MM(I) := DD(I)+0*MM(1) ; ENDLOOP ;
      POLVAL 1 N TWOND MM NV O TWOND ; ENDPROCEDURE ;

   PROCEDURE PM IU ; VARIABLE I 1 ; VARIABLE M NM1 5 ;   {PRINTS MAP TO UNIT IU}
      LOOP I 1 5 ; M(I) := MAP(I) + 0*DD(1) ; ENDLOOP ;
      DAPRV M 5 6 TWOND IU ; ENDPROCEDURE ;

   PROCEDURE PSM IU ;                               {PRINTS SPIN MAP TO UNIT IU}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE M NM2 3 ;
      LOOP I 1 3 ; LOOP J 1 3 ; M(J) := SPNR(I,J) + 0*DD(1) ; ENDLOOP ;
         DAPRV M 3 6 TWOND IU ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE WM IU ; VARIABLE I 10 ; I := '(E24.16)' ;   {PRINTS MAP TO UNIT IU}
      WRITE IU ' L  '&SF(SPOS,I) ;
      WRITE IU ' P ('&SF(XLOC,I)&','&SF(0,I)&','&SF(ZLOC,I)&')' ;
      WRITE IU ' A ('&SF(PLOC,I)&','&SF(0,I)&','&SF(0,I)&')' ;
      LOOP I 1 8 ; WRITE IU MAP(I)+0*DD(1) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE PNM IU NAP ; VARIABLE I 1 ; VARIABLE M NM1 5 ;         {PRINTS NAP}
      LOOP I 1 MIN(5,TWOND) ; M(I) := NAP(I) + 0*DD(1) ; ENDLOOP ;
      LOOP I TWOND+1 5 ; M(I) := 0*DD(1) ; ENDLOOP ; DAPRV M 5 6 TWOND IU ;
      ENDPROCEDURE ;

   PROCEDURE WNM IU NAP ; VARIABLE I 10 ; I := '(E24.16)' ;         {PRINTS NAP}
      WRITE IU ' L  '&SF(0,I) ;
      WRITE IU ' P ('&SF(0,I)&','&SF(0,I)&','&SF(0,I)&')' ;
      WRITE IU ' A ('&SF(0,I)&','&SF(0,I)&','&SF(0,I)&')' ;
      LOOP I 1 TWOND ; WRITE IU NAP(I)+0*DD(1) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE DMAP IU MAPA MAPB AC ;              {OUTPUTS DIFFRENCE OF TWO MAPS}
      VARIABLE I 1 ; VARIABLE C NM1 MAX(5,TWOND) ; VARIABLE DEPSP 1 ;
      DEPSP := DEPS ; DAEPS AC ; LOOP I 1 TWOND ;
      C(I) := MAPA(I)-MAPB(I)+0*DD(1) ; ENDLOOP ; LOOP I TWOND+1 5 ;
      C(I) := 0*DD(1) ; ENDLOOP ; DAPRV C 5 6 TWOND IU ;
      IF ND>2 ; WRITE IU MAPA(6)-MAPB(6) ; ENDIF ; DSET DEPSP ; ENDPROCEDURE ;

   PROCEDURE DSMAP IU MAPA MAPB AC ;        {OUTPUTS DIFFRENCE OF TWO SPIN MAPS}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE DEPSP 1 ; VARIABLE M NM2 3 ;
      DEPSP := DEPS ; DAEPS AC ;
      LOOP I 1 3 ; LOOP J 1 3 ; M(J) := MAPA(I,J)-MAPB(I,J)+0*DD(1) ; ENDLOOP ;
         DAPRV M 3 6 TWOND IU ; ENDLOOP ; DSET DEPSP ; ENDPROCEDURE ;

   PROCEDURE CATR IAP NAP LGH ;   {CONVERTS CANONICAL MAP TO TRANSPORT STANDARD}
      VARIABLE NC 1 ; VARIABLE PC 1 ; VARIABLE VN NM1 ; VARIABLE LT NM1 ;
      VARIABLE GM NM1 ; VARIABLE MG NM1 ; VARIABLE COP NM1 NV ;
      VARIABLE DOP NM1 NV ;
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before CATR' ; QUIT 0 ; ENDIF ;
      PC := CONS(P0) ;
      IF ND>2 ; GM := SQRT(1+SQR(DD(2))+SQR(DD(4)))/(1+DD(6)) ;
      ELSEIF ND>0 ; GM := SQRT(1+SQR(DD(2))+SQR(DD(4)))*PC/P0 ; ENDIF ;
      IF ND>1 ; MG := SQRT(SQR(P0/PC)-SQR(IAP(2))-SQR(IAP(4))) ;
      ELSEIF ND>0 ; MG := SQRT(SQR(P0/PC)-SQR(IAP(2))) ; ENDIF ;
      IF ND>0 ; COP(1) :=  DD(1) ; COP(2) :=  DD(2)/GM ;
                DOP(1) := IAP(1) ; DOP(2) := IAP(2)/MG ;
      IF ND>1 ; COP(3) :=  DD(3) ; COP(4) :=  DD(4)/GM ;
                DOP(3) := IAP(3) ; DOP(4) := IAP(4)/MG ;
      IF ND>2 ; COP(5) := DD(5) ;
      NC := CONS(ETA) ; VN := V0/CONS(V0) ; LT := -(1+NC)/(2+NC)/VN ;
      COP(6) := (SQRT(SQR(PC*(1+DD(6))/M0/AMUMEV)+1)-1)*M0*AMUMEV/CONS(E0)-1 ;
      DOP(5) := DD(5)-(IAP(5)-DD(5))/LT-(VN-1)*LGH ; DOP(6) := P0/PC-1 ;
      ENDIF ; ENDIF ; ENDIF ; ANM DOP COP NAP ; ENDPROCEDURE ;

   PROCEDURE TRCA IAP NAP LGH ;   {CONVERTS TRANSPORT STANDARD TO CANONICAL MAP}
      VARIABLE NC 1 ; VARIABLE PC 1 ; VARIABLE VN NM1 ; VARIABLE LT NM1 ;
      VARIABLE GM NM1 ; VARIABLE MG NM1 ; VARIABLE COP NM1 NV ; VARIABLE I 1 ;
      VARIABLE DOP NM1 NV ;
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before TRCA' ; QUIT 0 ; ENDIF ;
      PC := CONS(P0) ;
      IF ND>2 ; GM := SQRT(1+SQR(IAP(2))+SQR(IAP(4)))/(1+DD(6)) ;
      ELSEIF ND>1 ; GM := SQRT(1+SQR(IAP(2))+SQR(IAP(4)))*PC/P0 ;
      ELSEIF ND>0 ; GM := SQRT(1+SQR(IAP(2)))*PC/P0 ; ENDIF ;
      MG := SQRT(SQR(P0/PC)-SQR(DD(2))-SQR(DD(4))) ;
      IF ND>0 ; COP(1) :=  DD(1) ; COP(2) :=  DD(2)/MG ;
                DOP(1) := IAP(1) ; DOP(2) := IAP(2)/GM ;
      IF ND>1 ; COP(3) :=  DD(3) ; COP(4) :=  DD(4)/MG ;
                DOP(3) := IAP(3) ; DOP(4) := IAP(4)/GM ;
      IF ND>2 ; COP(5) := DD(5) ; COP(6) := P0/PC-1 ;
      NC := CONS(ETA) ; VN := PC/M0/AMUMEV*(1+DD(6)) ;
      VN := VN/SQRT(1+SQR(VN)) ; VN := VN/CONS(VN) ; LT := -(1+NC)/(2+NC)/VN ;
      DOP(6) := (SQRT(SQR(PC*(1+IAP(6))/M0/AMUMEV)+1)-1)*M0*AMUMEV/CONS(E0)-1 ;
      DOP(5) := DD(5)-(IAP(5)-DD(5)+(VN-1)*LGH)*LT ; ENDIF ; ENDIF ; ENDIF ;
      ANM DOP COP NAP ; ENDPROCEDURE ;

   PROCEDURE COCR IAP NAP ;                            {COSY TO CIRCULAR REPRES}
     VARIABLE LAP 2*NM1 TWOND ; VARIABLE COD 5 NV ; VARIABLE I 2 ; IMUNIT I ;
     IF ND<2 ; WRITE 6 ' *** ERROR in COCR, ND too small' ; QUIT 0 ; ENDIF ;
     COD(1) := (DD(1)+DD(2))/2 ; COD(3) := (DD(1)-DD(2))/2/I ;
     COD(2) := (DD(3)+DD(4))/2 ; COD(4) := (DD(3)-DD(4))/2/I ;
     LAP(1) := IAP(1)+I*IAP(3) ; LAP(2) := IAP(1)-I*IAP(3) ;
     LAP(3) := IAP(2)+I*IAP(4) ; LAP(4) := IAP(2)-I*IAP(4) ;
     LOOP I 5 TWOND ; COD(I) := DD(I) ; LAP(I) := IAP(I) ; ENDLOOP ;
     LOOP I TWOND+1 NV ; COD(I) := DD(I) ; ENDLOOP ;
     CPOLVAL 1 LAP TWOND COD NV NAP TWOND ; ENDPROCEDURE ;

   PROCEDURE CRCO IAP NAP ; VARIABLE DUM 1 ;           {CIRCULAR REPRES TO COSY}
     VARIABLE LAP 2*NM1 TWOND ; VARIABLE COD 5 NV ; VARIABLE I 2 ; IMUNIT I ;
     IF ND<2 ; WRITE 6 ' *** ERROR in CRCO, ND too small' ; QUIT 0 ; ENDIF ;
     COD(1) := DD(1)+I*DD(3) ; COD(2) := DD(1)-I*DD(3) ;
     COD(3) := DD(2)+I*DD(4) ; COD(4) := DD(2)-I*DD(4) ;
     LAP(1) := (IAP(1)+IAP(2))/2 ; LAP(3) := (IAP(1)-IAP(2))/2/I ;
     LAP(2) := (IAP(3)+IAP(4))/2 ; LAP(4) := (IAP(3)-IAP(4))/2/I ;
     LOOP I 5 TWOND ; COD(I) := DD(I) ; LAP(I) := IAP(I) ; ENDLOOP ;
     LOOP I TWOND+1 NV ; COD(I) := DD(I) ; ENDLOOP ;
     CPOLVAL 1 LAP TWOND COD NV NAP TWOND ;
     DUM := 0 ; LOOP I 1 TWOND ; DUM := DUM + ABS(IMAG(NAP(I))) ;
     NAP(I) := REAL(NAP(I)) ; ENDLOOP ; IF DUM>1E-12 ;
     WRITE 6 ' --- WARNING in CRCO, map not in circular representation' ;
     ENDIF ; ENDPROCEDURE ;

   PROCEDURE PT IU ; VARIABLE M NM1 TWOND ;    {PRINTS TRANSPORT MAP TO UNIT IU}
      VARIABLE I 1 ; VARIABLE MM NM1 MAX(NV,6) ;
      CATR MAP M SPOS ; LOOP I TWOND NV ; MM(I) := DD(I) ; ENDLOOP ;
      LOOP I 1 TWOND 2 ; MM(I) := .01*DD(I) ; MM(I+1) := .001*DD(I+1) ;
         ENDLOOP ; IF ND>2 ; MM(6) := .01*DD(6) ; ENDIF ;
      POLVAL 1 M TWOND MM NV MM TWOND ; LOOP I 1 TWOND 2 ; MM(I) :=  100*MM(I) ;
         MM(I+1) :=  1000*MM(I+1) ; ENDLOOP ; IF ND>2 ; MM(6) := .1*MM(6) ;
         ENDIF ; LOOP I 1 5 ; MM(I) := MM(I) + 0*DD(1) ; ENDLOOP ;
      DAPRV MM 5 6 TWOND IU ; ENDPROCEDURE ;

   PROCEDURE PA IU ; VARIABLE I 1 ; VARIABLE MM NM1 MAX(NV,5) ;    {ABERRATIONS}
      LOOP I 1 TWOND ;    MM(I) := PHSP(I)*DD(I) ; ENDLOOP ;
      LOOP I TWOND+1 NV ; MM(I) := PARS(I-TWOND)*DD(I) ; ENDLOOP ;
      POLVAL 1 MAP TWOND MM NV MM TWOND ;
      LOOP I TWOND+1 5 ; MM(I) := 0*DD(1) ; ENDLOOP ;
      DAPRV MM 5 6 TWOND IU ; ENDPROCEDURE ;

   PROCEDURE FM M XF MF IER ;   {COMPUTES FIXED POINT OF M AND MAP MF AROUND IT}
      VARIABLE N NM1 NV ; VARIABLE NI NM1 NV ; VARIABLE C NM1 NV ;
      VARIABLE I 1 ; VARIABLE PEP NM1 ; VARIABLE COR 1 ; VARIABLE GEO 1 ;
      VARIABLE P 1 ; P := 0 ; IF TWOND=5 ; COR := 4 ; ELSEIF TRUE ;
      COR := TWOND ; ENDIF ; LOOP I 1 COR ; DAPEP M(I) 0 COR PEP ;
      P:= P + ABS(PEP) ; ENDLOOP ; IF P=0 ; LOOP I 1 TWOND ; MF(I) := M(I) ;
      XF(I) := 0 ; ENDLOOP ; IER := 0 ; ELSEIF P#0 ;
         LOOP I 1 COR ;    C(I) := 0*DD(1) ; N(I) := M(I)-DD(I) ; ENDLOOP ;
         LOOP I COR+1 NV ; C(I) := DD(I) ;   N(I) := DD(I) ;      ENDLOOP ;
         MI N NI NV IER NOC NV NM1 ;
         IF IER#0 ; WRITE 6 ' --- WARNING in FM, no fixed point' ; ENDIF ;
         POLVAL 1 NI NV C NV XF NV ;  POLVAL 1 M TWOND XF NV C TWOND ;
         LOOP I 1 COR ; XF(I) := XF(I) + DD(I) ; ENDLOOP ;
         POLVAL 0 M TWOND XF NV MF TWOND ;
         LOOP I 1 COR ; MF(I) := MF(I)-C(I) ; XF(I) := XF(I)-DD(I) ; ENDLOOP ;
         IF TWOND=5 ; XF(5) := C(5) ; MF(5) := MF(5)-C(5)+DD(5) ;
            MF(6) := DD(6) ; ENDIF ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE RR M   X A Y B D  PR AR N   OR MR RES ; {TRAJECTORY RECONSTRUCTION}
      PROCEDURE REC ; VARIABLE NN 1 ; VARIABLE S MAX(NM1,N+1) ;
      VARIABLE I 1 ; VARIABLE M4 NM1 4 ; VARIABLE CM 1 6 ;
      VARIABLE RI N 6 ; VARIABLE RO N 4 ; VARIABLE RB N 4 ; VARIABLE RE N 4 ;
      VARIABLE IRAN 1 ; VARIABLE J NM1 ; VARIABLE NOM 1 ; VARIABLE IER 1 ;
      FUNCTION RAN IRAN ; RAN := 98765*IRAN+.12345 ; RAN := 2*(RAN-NINT(RAN)) ;
         IRAN := RAN ; ENDFUNCTION ; IRAN := 0 ;
      IF OR>0 ; LOOP I 1 4 ; DAPLU M(I) 1 0 S ; M4(I) := S ; CM(I+1) := DD(I) ;
         ENDLOOP ; NOM := NOC ; CO OR ; CM(1) := 0*DD(1) ; CM(6) := 0*DD(1) ;
         IF ND=3 ; CM(6) := DD(4) ; CM(5) := 0*DD(1) ; ENDIF ;
         POLVAL 1 M4 4 CM 6 M4 4 ; MI M4 MR 4 IER NOC NV NM1 ; CO NOM ; ENDIF ;
      S := 0 ; LOOP I 1 N-1 ; S := S&0 ; ENDLOOP ;
      LOOP I 1 N ; VELSET S I X*RAN(IRAN) ; ENDLOOP ; RI(1) := S ;
      LOOP I 1 N ; VELSET S I A*RAN(IRAN) ; ENDLOOP ; RI(2) := S ;
      LOOP I 1 N ; VELSET S I Y*RAN(IRAN) ; ENDLOOP ; RI(3) := S ;
      LOOP I 1 N ; VELSET S I B*RAN(IRAN) ; ENDLOOP ; RI(4) := S ;
      LOOP I 1 N ; VELSET S I D*RAN(IRAN) ; ENDLOOP ; RI(5) := S ;
      RI(6) := S ;  POLVAL 1 M 4 RI 6 RO 4 ;
      LOOP I 1 N ; VELSET S I PR*RAN(IRAN) ; ENDLOOP ; RE(1) := S ;
      LOOP I 1 N ; VELSET S I AR*RAN(IRAN) ; ENDLOOP ; RE(2) := S ;
      LOOP I 1 N ; VELSET S I PR*RAN(IRAN) ; ENDLOOP ; RE(3) := S ;
      LOOP I 1 N ; VELSET S I AR*RAN(IRAN) ; ENDLOOP ; RE(4) := S ;
      RO(1) := RO(1) + RE(1) ; RO(2) := RO(2) + RE(2) ;
      RO(3) := RO(3) + RE(3) ; RO(4) := RO(4) + RE(4) ;
      POLVAL 1 MR 4 RO 4 RB 4 ;  RE(1) := RI(2)-RB(1) ; RE(2) := RI(3)-RB(2) ;
      RE(3) := RI(4)-RB(3) ; RE(4) := RI(6)-RB(4) ;
      LOOP J 1 4 ; RES(J) := 0 ; NN := 0 ; LOOP I 1 N ; VELGET RE(J) I S ;
         IF S#0 ; RES(J) := RES(J) + ABS(S) ; NN := NN + 1 ; ENDIF ; ENDLOOP ;
         RES(J) := NN/(RES(J)+1E-20)/4 ; IF IER#0 ; RES(J) := 0 ; ENDIF ;
         ENDLOOP ; ENDPROCEDURE ;
      SVSCR ; NM1 := MAX(NM1,N) ; SCRLEN 2*NM1 ; REC ; NM1 := NMON(NO+1,NV) ;
      SCRLEN LSCR ; ENDPROCEDURE ;

   PROCEDURE AR M   X A Y B D   PR N   RES ;           {SPECTROGRAPH RESOLUTION}
     VARIABLE I 1 ; VARIABLE MR NM1 4 ; VARIABLE RS 1 4 ;
     DAPEE M(1) 2 RES ; RR M X A Y B D PR RES*A N 1 MR RS ; RES := RS(4) ;
     ENDPROCEDURE ;

   PROCEDURE RM IU ;                           {READS TRANSFER MAP FROM UNIT IU}
      VARIABLE LIN 80 ; VARIABLE DUM NM1 ; VARIABLE I 1 ;
      READ IU LIN ; IF SS(LIN,1,3)=' L ' ; SLOC := R(LIN,5,28) ; READ IU LIN ;
      XLOC := R(LIN,5,28) ; I := R(LIN,30,53) ; ZLOC := R(LIN,55,78) ;
      READ IU LIN ; PLOC := R(LIN,5,28) ; I := R(LIN,30,53) ;
      I := R(LIN,55,78) ; LOCSET XLOC ZLOC PLOC SLOC 0 0 ;
      LOOP I 1 8 ; DAREA IU DUM NV ; MSC(I) := DUM ; ENDLOOP ;
      ELSEIF TRUE ; BACKF IU ; DAREV MSC 5 6 TWOND IU ; MSC(6) := DD(6) ;
      LOCSET 0 0 0 0 0 0 ; ENDIF ; UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE RNM IU NAP ;                               {READS NAP FROM UNIT IU}
      VARIABLE LIN 80 ; VARIABLE DUM NM1 ; VARIABLE I 1 ; VARIABLE IAP NM1 8 ;
      READ IU LIN ; IF SS(LIN,1,3)=' L ' ; READ IU LIN ; READ IU LIN ;
      LOOP I 1 8 ; DAREA IU DUM NV ; IAP(I) := DUM ; ENDLOOP ;
      ELSEIF TRUE ; BACKF IU ; DAREV IAP 5 6 TWOND IU ; IAP(6) := DD(6) ;
      ENDIF ; LOOP I 1 TWOND ; NAP(I) := IAP(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE SR X A Y B T D G Z COL ; VARIABLE I 1 ;                 {SETS RAYS}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before SR' ; QUIT 0 ; ENDIF ;
      IF LPI=1 ; WRITE 6 ' *** ERROR, call SR before BP' ; QUIT 0 ; ENDIF ;
      NRAY := NRAY + 1 ; IF NRAY=1 ; NRAY := 2 ; ENDIF ;
      RAY(1) := RAY(1)&X ; RAY(2) := RAY(2)&A ; RAY(3) := RAY(3)&Y ;
      RAY(4) := RAY(4)&B ; RAY(5) := RAY(5)&T ; RAY(6) := RAY(6)&D ;
      RAY(7) := RAY(7)&G ; RAY(8) := RAY(8)&Z ; RCOL := RCOL&COL ;
      LOOP I 1 8 ; RSC(I) := RAY(I) ; ENDLOOP ;
      REMAIN := REMAIN&1 ; REMOVE := REMOVE&0 ; ENDPROCEDURE ;

   PROCEDURE SBE EX EY ET ; VARIABLE E 1 3 ; VARIABLE I 1 ; VARIABLE J 1 ;
      VARIABLE K 1 ; VARIABLE DUM 1 ; VARIABLE X 1 3 ; VARIABLE A 1 3 ;
      VARIABLE R 1 3 ; E(1) := EX ; E(2) := EY ; E(3) := ET ;
      LOOP I 1 ND ; K := 2*I ; J := K-1 ; IF ABS(ME(J,J)+ME(K,K))<(2-1E-10) ;
      DUM := E(I)/PI/SQRT(1-SQR(ME(J,J)+ME(K,K))/4) ;
      X(I) := SQRT(DUM*ABS(ME(J,K))) ; A(I) := SQRT(DUM*ABS(ME(K,J))) ;
      R(I) := (ME(K,K)-ME(J,J))/2*SIG(ME(J,K))/SQRT(ABS(ME(J,K)*ME(K,J))) ;
      ELSEIF TRUE ; X(I) := 0 ; A(I) := 0 ; R(I) := 0 ;
      WRITE 6 ' --- WARNING in SBE, map unstable' ; ENDIF ; ENDLOOP ;
      SB X(1) A(1) R(1) X(2) A(2) R(2) X(3) A(3) R(3) 0 0 ; ENDPROCEDURE ;

   PROCEDURE ENVEL ; VARIABLE I 1 ; SR 0 0 0 0 0 0 0 0 1 ;        {SET ENVELOPE}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before ENVEL' ; QUIT 0 ; ENDIF ;
      ERAY(1) := PHSP(1) ; EMAX(1) := PHSP(1) ;
      ERAY(2) := PHSR(1)*PHSP(2) ; ERAY(3) := PHSP(3) ; EMAX(2) := PHSP(3) ;
      ERAY(4) := PHSR(2)*PHSP(4) ; LOOP I 1 4 ; ERSC(I) := ERAY(I) ; ENDLOOP ;
      LENV := 1 ; ENDPROCEDURE ;

   PROCEDURE ENCL DISP ;                     {SET ENERGY DEPENDENT CLOSED ORBIT}
      VARIABLE I 1 ; VARIABLE MF NM1 8 ; VARIABLE XF NM1 8 ;
      TWOND := 5 ; FM MAP XF MF I ; TWOND := 2*ND ;
      LOOP I 1 NV ; MF(I) := 0 ; ENDLOOP ; MF(6) := DISP ;
      POLVAL 1 XF NV MF NV MF NV ;
      SR 0 0 0 0 0 0 0 0 1 ; SR MF(1) MF(2) MF(3) MF(4) MF(5) MF(6) 0 0 1 ;
      ENDPROCEDURE ;

   PROCEDURE SCDE ;                {SETS SIN, COS RAYS, DISPERSION AND ENVELOPE}
      {EMITTANCE IS PI*PX*PA*SQRT(1-SQR(R12)) AND PI*PY*PB*SQRT(1-SQR(R34))}
      VARIABLE I 1 ;
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before SCDE' ; QUIT 0 ; ENDIF ;
      I := SQRT(1-SQR(PHSR(1))) ; SR PHSP(1)*I 0 0 0 0 0 0 0 1 ;
      SR 0 PHSP(2)*I 0 0 0 0 0 0 1 ; I := SQRT(1-SQR(PHSR(2))) ;
      SR 0 0 PHSP(3)*I 0 0 0 0 0 1 ; SR 0 0 0 PHSP(4)*I 0 0 0 0 1 ;
      SR 0 0 0 0 0 PHSP(6) 0 0 2 ; ERAY(1) := PHSP(1) ; EMAX(1) := PHSP(1) ;
      ERAY(2) := PHSR(1)*PHSP(2) ; ERAY(3) := PHSP(3) ; EMAX(2) := PHSP(3) ;
      ERAY(4) := PHSR(2)*PHSP(4) ; LOOP I 1 4 ; ERSC(I) := ERAY(I) ; ENDLOOP ;
      LENV := 1 ; ENDPROCEDURE ;

   PROCEDURE SSR X Y Z ;                                             {SETS SPIN}
      VARIABLE SCR 3 ; VARIABLE I 1 ;
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before SSR' ; QUIT 0 ; ENDIF ;
      IF LPI=1 ; WRITE 6 ' *** ERROR, call SSR before BP' ; QUIT 0 ; ENDIF ;
      NSPN := NSPN + 1 ; IF NSPN=1 ; NSPN := 2 ; ENDIF ; SCR := X&Y&Z ;
      IF NSPN#NRAY ; WRITE 6 ' *** ERROR, call SSR after each matching SR' ;
         QUIT 0 ; ENDIF ;
      IF CONS(SCR)=0 ; WRITE 6 ' *** ERROR in SSR, give non zero spin vector.' ;
         QUIT 0 ; ENDIF ;
      VEUNIT SCR SCR ;
      LOOP I 1 3 ; SPI(I) := SPI(I)&(SCR|I) ; SSC(I) := SPI(I) ; ENDLOOP ;
      ENDPROCEDURE ;

   PROCEDURE ER NX NA NY NB NT ND NG NZ ;                {SETS ENSEMBLE OF RAYS}
      VARIABLE IX 1 ; VARIABLE IA 1 ; VARIABLE IY 1 ; VARIABLE IB 1 ;
      VARIABLE IT 1 ; VARIABLE ID 1 ; VARIABLE IG 1 ; VARIABLE IZ 1 ;
      VARIABLE VX 1 ; VARIABLE VA 1 ; VARIABLE VY 1 ; VARIABLE VB 1 ;
      VARIABLE VT 1 ; VARIABLE VD 1 ; VARIABLE VG 1 ; VARIABLE VZ 1 ;
      VARIABLE I  1 ; VARIABLE COL 1 ND ;
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before ER' ; QUIT 0 ; ENDIF ;
      IF LPI=1 ; WRITE 6 ' *** ERROR, call ER before BP' ; QUIT 0 ; ENDIF ;
      IF LPS=0 ; WRITE 6 ' *** ERROR, call SB before ER ' ; QUIT 0 ; ENDIF ;
      IF INT(ND/2)#ND/2 ; COL((ND+1)/2) := 5 ; ENDIF ;
      LOOP I 1 ND/2 ; COL(I) := 3 ; ENDLOOP ;
      LOOP I ND ND/2+1 -1 ; COL(I) :=  2 ; ENDLOOP ;
      LOOP IX 1 NX ; LOOP IA 1 NA ; LOOP IY 1 NY ; LOOP IB 1 NB ;
      LOOP IT 1 NT ; LOOP ID 1 ND ; LOOP IG 1 NG ; LOOP IZ 1 NZ ;
      VX := PHSP(1)*(2*IX-NX-1)/MAX(1,NX-1) ;
      VA := PHSP(2)*(2*IA-NA-1)/MAX(1,NA-1) ;
      VY := PHSP(3)*(2*IY-NY-1)/MAX(1,NY-1) ;
      VB := PHSP(4)*(2*IB-NB-1)/MAX(1,NB-1) ;
      VT := PHSP(5)*(2*IT-NT-1)/MAX(1,NT-1) ;
      VD := PHSP(6)*(2*ID-ND-1)/MAX(1,ND-1) ;
      VG := PHSP(7)*(2*IG-NG-1)/MAX(1,NG-1) ;
      VZ := PHSP(8)*(2*IZ-NZ-1)/MAX(1,NZ-1) ;
      SR VX VA VY VB VT VD VG VZ COL(ID) ; ENDLOOP ; ENDLOOP ; ENDLOOP ;
      ENDLOOP ; ENDLOOP ; ENDLOOP ; ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE PR IU ; VARIABLE I 1 ;                     {PRINTS RAYS TO UNIT IU}
      LOOP I 1 8 ; WRITE IU RAY(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE PRAY IU ;                                  {PRINTS RAYS TO UNIT IU}
     {THE FIRST RAY IS THE REFERENCE}
      VARIABLE NR 1 ; VARIABLE STR 150 ; VARIABLE I 1 ; VARIABLE J 1 ;
      NR := LENGTH(RAY(1)) ; IF NR=1 ; NR := 0 ; ENDIF ;         {SEE CR AND SR}
      WRITE IU '# number of rays:'&SF(NR,'(I8)')&'  (including the reference)' ;
      IF NR>0 ;
         WRITE IU ('#   ray              X              A              Y              B'&
         '              T              D              G              Z'&
         '    REMAIN    REMOVE') ; {added 'ray' @AA}
         LOOP J 1 NR ;
            I := 1 ; STR := SF(J-1, '(I7)')&SF((RAY(I)|J),'(E15.7)') ; {added 'ray' @AA}
            LOOP I 2 8 ; STR := STR&SF((RAY(I)|J),'(E15.7)') ; ENDLOOP ;
            STR := STR&SF(REMAIN|J,'(I10)')&SF(REMOVE|J,'(I10)') ;
            WRITE IU STR ; ENDLOOP ;    ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE WRAY IU ;                                  {PRINTS RAYS TO UNIT IU}
     {THE FIRST RAY IS THE REFERENCE}
      VARIABLE NR 1 ; VARIABLE LABL 1 8 ; VARIABLE I 1 ; VARIABLE J 1 ;
      LABL(1) := 'X' ; LABL(2) := 'A' ; LABL(3) := 'Y' ; LABL(4) := 'B' ;
      LABL(5) := 'T' ; LABL(6) := 'D' ; LABL(7) := 'G' ; LABL(8) := 'Z' ;
      NR := LENGTH(RAY(1)) ; IF NR=1 ; NR := 0 ; ENDIF ;         {SEE CR AND SR}
      WRITE IU '# number of rays:'&SF(NR,'(I8)')&'  (including the reference)' ;
      IF NR>0 ;
         LOOP I 1 8 ; WRITE IU '# '&LABL(I) ;
            LOOP J 1 NR ; WRITE IU RAY(I)|J ; ENDLOOP ;
            WRITE IU '' ; ENDLOOP ;
         WRITE IU '#   REMAIN    REMOVE' ;
            LOOP J 1 NR ; WRITE IU SF(REMAIN|J,'(I10)')&SF(REMOVE|J,'(I10)') ;
               ENDLOOP ;    WRITE IU '' ;    ENDIF ;
      ENDPROCEDURE ;{ END OF PRAY1 }

   PROCEDURE RRAY IU ;                                 {READS RAYS FROM UNIT IU}
     {CALL CR BEFORE CALLING RRAY.
      RRAY OVERWRITES NRAY, RAY(), RSC(), RCOL, REMAIN, REMOVE.}
      VARIABLE STR 200 ; VARIABLE LABL 1 8 ; VARIABLE I 1 ; VARIABLE J 1 ;
      VARIABLE LHEAD 1 ; VARIABLE LRR 1 ;
      READ IU STR ; NRAY := R(STR,18,25) ; LRR := LO(0) ;
      IF NRAY>0 ;
         READS IU STR ; LHEAD := LENGTH(STR) ;
         IF LHEAD>3 ;                           {THE DATA WAS PRODUCED BY PRAY.}
            IF (STR|((LHEAD-3)&(LHEAD)))='MOVE' ; LRR := LO(1) ; ENDIF ;
            READ IU STR ;
               LOOP I 1 8 ; RAY(I) := R(STR,15*(I-1)+1,15*I) ; ENDLOOP ;
               IF LRR ; REMAIN := R(STR,121,130) ;
                        REMOVE := R(STR,131,140) ; ENDIF ;
            LOOP J 2 NRAY ; READ IU STR ;
               LOOP I 1 8 ; RAY(I) := RAY(I)&R(STR,15*(I-1)+1,15*I) ; ENDLOOP ;
               IF LRR ; REMAIN := REMAIN&R(STR,121,130) ;
                        REMOVE := REMOVE&R(STR,131,140) ; ENDIF ; ENDLOOP ;
         ELSEIF LO(1) ;                                       {THE DATA BY WRAY}
            LABL(1) := 'X' ; LABL(2) := 'A' ; LABL(3) := 'Y' ; LABL(4) := 'B' ;
            LABL(5) := 'T' ; LABL(6) := 'D' ; LABL(7) := 'G' ; LABL(8) := 'Z' ;
            IF STR#('# '&LABL(1)) ; WRITE 6 (' *** ERROR in RRAY, '&
               'the wrong line is input:') STR ; QUIT 0 ; ENDIF ;
            LOOP I 1 8 ;
               IF I>1 ; READS IU STR ;
                  IF STR#('# '&LABL(I)) ; WRITE 6 (' *** ERROR in RRAY, '&
                     'the wrong line is input:') STR ; QUIT 0 ; ENDIF ;  ENDIF ;
               READ IU STR ; RAY(I) := STR ;
               LOOP J 2 NRAY ; READ IU STR ; RAY(I) := RAY(I)&STR ; ENDLOOP ;
               READ IU STR ; ENDLOOP ;
            READS IU STR ;
            IF STR='#   REMAIN    REMOVE' ; LRR := LO(1) ;
               READS IU STR ; REMAIN := R(STR,1,10) ; REMOVE := R(STR,11,20) ;
               LOOP J 2 NRAY ; READS IU STR ;
                  REMAIN := REMAIN&R(STR,1,10) ; REMOVE := REMOVE&R(STR,11,20) ;
                  ENDLOOP ; ENDIF ;
         ENDIF ;    ENDIF ;
      IF NOT(LRR) ; REMOVE := 0*RAY(1) ; REMAIN := 1+REMOVE ; ENDIF ;
      LOOP I 1 8 ; RSC(I) := RAY(I) ; ENDLOOP ;
      RCOL := 1+0*RAY(1) ; ENDPROCEDURE ;

   PROCEDURE SRAY R ;                                          {SAVES RAYS TO R}
      VARIABLE I 1 ; LOOP I 1 8 ; R(I) := RAY(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE LRAY R ;                                        {LOADS RAYS FROM R}
     {CALL CR BEFORE CALLING LRAY.
      LRAY OVERWRITES NRAY, RAY(), RSC(), RCOL, REMAIN, REMOVE.}
      VARIABLE I 1 ;
      NRAY := LENGTH(R(1)) ; IF NRAY=1 ; NRAY := 0 ; ENDIF ;
      LOOP I 1 8 ; RAY(I) := R(I) ; RSC(I) := R(I) ; ENDLOOP ;
      REMOVE := 0*RAY(1) ; REMAIN := 1+REMOVE ; RCOL := REMAIN ; ENDPROCEDURE ;

   PROCEDURE DRAY IU RAYA RAYB AC ;     {OUTPUTS DIFFERENCE OF TWO SETS OF RAYS}
      VARIABLE I 1 ; VARIABLE SCR LENGTH(RAYA(1)) ;
      LOOP I 1 TWOND ; SCR := RAYA(I)-RAYB(I) ;
      IF ABS(SCR)>AC ;  WRITE IU SCR ;
         ELSEIF LO(1) ; WRITE IU '    ---' ; ENDIF ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE ARAY IU ;     {APPENDS RAYS FROM UNIT IU, PRODUCED BY PRAY OR WRAY}
     {UNLIKE RRAY, DO NOT CALL CR BEFORE CALLING ARAY.
      ARAY OVERWRITES NRAY, AND APPENDS RAY(), RSC(), RCOL, REMAIN, REMOVE.
      THE REFERENCE RAY OF THE APPENDING RAYS VIA IU IS IGNORED.
      THE IU READ-IN RAYS ARE COPIED TO THE BEGINNING, AND
      THE PRE-EXISTED RAYS ARE SHIFTED TOWARD THE END.}
      VARIABLE NRAY0 1 ; VARIABLE I 1 ; VARIABLE RANGE 2 ;
      VARIABLE RAY0 NRAY+1 8 ; VARIABLE RSC0 NRAY+1 8 ; VARIABLE RCOL0 NRAY+1 ;
      VARIABLE REMAIN0 NRAY+1 ; VARIABLE REMOVE0 NRAY+1 ;
      NRAY0 := NRAY ; RCOL0 := RCOL ; REMAIN0 := REMAIN ; REMOVE0 := REMOVE ;
      LOOP I 1 8 ; RAY0(I) := RAY(I) ; RSC0(I) := RSC(I) ; ENDLOOP ;
      RRAY IU ;
      IF NRAY=0 ; NRAY := NRAY0 ;
         LOOP I 1 8 ; RAY(I) := RAY0(I) ; RSC(I) := RSC0(I) ; ENDLOOP ;
         RCOL := RCOL0 ; REMAIN := REMAIN0 ; REMOVE := REMOVE0 ;
      ELSEIF LO(1) ; IF NRAY0>0 ; NRAY := NRAY+NRAY0-1 ; RANGE := 2&NRAY0 ;
         LOOP I 1 8 ; RAY(I) := RAY(I)&(RAY0(I)|RANGE) ;
                      RSC(I) := RSC(I)&(RSC0(I)|RANGE) ; ENDLOOP ;
         RCOL := RCOL&(RCOL0|RANGE) ; REMAIN := REMAIN&(REMAIN0|RANGE) ;
         REMOVE := REMOVE&(REMOVE0|RANGE) ; ENDIF ;    ENDIF ; ENDPROCEDURE ;

   PROCEDURE ADDRAYS FN1 FN2 FN ;     {ADD RAYS IN FN1 AND FN2, RESULTING IN FN}
     {THE REFERENCE RAY IN FN2 IS IGNORED.}
      CR ; OPENF 77 FN2 'OLD' ; RRAY 77 ; CLOSEF 77 ;
      OPENF 77 FN1 'OLD' ; ARAY 77 ; CLOSEF 77 ;
      OPENF 77 FN 'UNKNOWN' ; PRAY 77 ; CLOSEF 77 ; ENDPROCEDURE ;

   PROCEDURE PSPI IU ;                          {PRINTS SPIN VECTORS TO UNIT IU}
     {THE FIRST VECTOR IS THE REFERENCE, HAVING 0.}
      VARIABLE NS 1 ; VARIABLE STR 55 ; VARIABLE I 1 ; VARIABLE J 1 ;
      NS := LENGTH(SPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;        {SEE CR AND SSR}
      WRITE IU ('# number of spin vectors:'&SF(NS,'(I8)')&
                '  (including the reference)') ;
      IF NS>0 ;
         WRITE IU '#   vector  S_X            S_Y            S_Z' ; {added 'vector' @AA}
         LOOP J 1 NS ;
            I := 1 ; STR := SF(J-1, '(I10)')&SF((SPI(I)|J),'(E15.7)') ; {added 'vector' @AA}
            LOOP I 2 3 ; STR := STR&SF((SPI(I)|J),'(E15.7)') ; ENDLOOP ;
            WRITE IU STR ; ENDLOOP ;    ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE WSPI IU ;                          {PRINTS SPIN VECTORS TO UNIT IU}
     {THE FIRST VECTOR IS THE REFERENCE, HAVING 0.}
      VARIABLE NS 1 ; VARIABLE LABL 1 3 ; VARIABLE I 1 ; VARIABLE J 1 ;
      LABL(1) := 'X' ; LABL(2) := 'Y' ; LABL(3) := 'Z' ;
      NS := LENGTH(SPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;        {SEE CR AND SSR}
      WRITE IU ('# number of spin vectors:'&SF(NS,'(I8)')&
                '  (including the reference)') ;
      IF NS>0 ;
         LOOP I 1 3 ; WRITE IU '# S_'&LABL(I) ;
            LOOP J 1 NS ; WRITE IU SPI(I)|J ; ENDLOOP ;
            WRITE IU '' ; ENDLOOP ;    ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE RSPI IU ;                         {READS SPIN VECTORS FROM UNIT IU}
     {CALL CR BEFORE CALLING RSPI. RSPI OVERWRITES NSPN, SPI(), SSC().}
      VARIABLE STR 45 ; VARIABLE LABL 1 3 ; VARIABLE I 1 ; VARIABLE J 1 ;
      READ IU STR ; NSPN := R(STR,26,33) ;
      IF NSPN>0 ;
         READ IU STR ;
         IF LENGTH(STR)>5 ;                     {THE DATA WAS PRODUCED BY PSPI.}
            READ IU STR ;
               LOOP I 1 3 ; SPI(I) := R(STR,15*(I-1)+1,15*I) ; ENDLOOP ;
            LOOP J 2 NSPN ; READ IU STR ;
               LOOP I 1 3 ; SPI(I) := SPI(I)&R(STR,15*(I-1)+1,15*I) ; ENDLOOP ;
               ENDLOOP ;
          ELSEIF TRUE ;                         {THE DATA WAS PRODUCED BY WSPI.}
            LABL(1) := 'X' ; LABL(2) := 'Y' ; LABL(3) := 'Z' ;
            IF STR#('# S_'&LABL(1)) ; WRITE 6 (' *** ERROR in RSPI, '&
               'the wrong line is input:') STR ; QUIT 0 ; ENDIF ;
            LOOP I 1 3 ;
               IF I>1 ; READ IU STR ;
                  IF STR#('# S_'&LABL(I)) ; WRITE 6 (' *** ERROR in RSPI, '&
                     'the wrong line is input:') STR ; QUIT 0 ; ENDIF ;  ENDIF ;
               READ IU STR ; SPI(I) := STR ;
               LOOP J 2 NSPN ; READ IU STR ; SPI(I) := SPI(I)&STR ; ENDLOOP ;
               IF I<3 ; READ IU STR ; ENDIF ;    ENDLOOP ;
          ENDIF ;    ENDIF ;
      LOOP I 1 3 ; SSC(I) := SPI(I) ; ENDLOOP ;
      ENDPROCEDURE ;

   PROCEDURE SSPI S ;                                  {SAVES SPIN VECTORS TO S}
      VARIABLE I 1 ; LOOP I 1 3 ; S(I) := SPI(I) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE LSPI S ;                                {LOADS SPIN VECTORS FROM S}
     {CALL CR BEFORE CALLING LSPI. LSPI OVERWRITES NSPN, SPI(), SSC().}
      VARIABLE I 1 ;
      NSPN := LENGTH(S(1)) ; IF NSPN=1 ; NSPN := 0 ; ENDIF ;
      LOOP I 1 3 ; SPI(I) := S(I) ; SSC(I) := S(I) ; ENDLOOP ;
      ENDPROCEDURE ;

   PROCEDURE DSPI IU SA SB AC ;          {OUTPUTS DIFFRENCE OF TWO SPIN VECTORS}
      VARIABLE I 1 ; VARIABLE SCR LENGTH(SA(1)) ;
      LOOP I 1 3 ; SCR := SA(I)-SB(I) ;
      IF ABS(SCR)>AC ;  WRITE IU SCR ;
         ELSEIF LO(1) ; WRITE IU '    ---' ; ENDIF ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE ASPI IU ;{APPENDS SPIN VECTORS FROM UNIT IU, PRODUCED BY PSPI/WSPI}
     {UNLIKE RSPI, DO NOT CALL CR BEFORE CALLING ASPI.
      ASPI OVERWRITES NSPN, AND APPENDS SPI(), SSC().
      THE REFERENCE OF THE APPENDING SPIN VECTORS VIA IU IS IGNORED.}
      VARIABLE NSPN0 1 ; VARIABLE I 1 ; VARIABLE RANGE 2 ;
      VARIABLE SPI0 NSPN+1 3 ; VARIABLE SSC0 NSPN+1 3 ;
      NSPN0 := NSPN ;
      LOOP I 1 3 ; SPI0(I) := SPI(I) ; SSC0(I) := SSC(I) ; ENDLOOP ;
      RSPI IU ;
      IF NSPN=0 ; NSPN := NSPN0 ;
         LOOP I 1 3 ; SPI(I) := SPI0(I) ; SSC(I) := SSC0(I) ; ENDLOOP ;
      ELSEIF LO(1) ; IF NSPN0>0 ; NSPN := NSPN+NSPN0-1 ; RANGE := 2&NSPN0 ;
         LOOP I 1 3 ; SPI(I) := SPI(I)&(SPI0(I)|RANGE) ;
                      SSC(I) := SSC(I)&(SSC0(I)|RANGE) ; ENDLOOP ; ENDIF ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE ADDSPIS FN1 FN2 FN ;{ADD SPIN VECTORS IN FN1 AND FN2, RESULTING FN}
     {THE REFERENCE RAY IN FN2 IS IGNORED.}
      CR ; OPENF 77 FN2 'OLD' ; RSPI 77 ; CLOSEF 77 ;
      OPENF 77 FN1 'OLD' ; ASPI 77 ; CLOSEF 77 ;
      OPENF 77 FN 'UNKNOWN' ; PSPI 77 ; CLOSEF 77 ; ENDPROCEDURE ;

   PROCEDURE FG PIC XL XR YB YT DX DY TITLE I ;          {FRAME FOR 2D GRAPHICS}
     {XL,XR,YB,YT: CORNERS; DX,DY: SCALE; I=0: 1X1.5 FRAME, I=1: 1X1 FRAME}
      VARIABLE N 1 ; CLEAR PIC ;
      IF I=1 ; GRMOVE XL*1.5 YB 0 PIC ; GRMOVE XR*1.5 YT 0 PIC ; ENDIF ;
      GRMOVE XL YB 0 PIC ; GRDRAW XL YT 0 PIC ; GRDRAW XR YT 0 PIC ;
      GRDRAW XR YB 0 PIC ; GRDRAW XL YB 0 PIC ;          {DRAW SCALES ON WINDOW}
      N := INT(XR/DX) ; IF N<0 ; N := N-1 ; ENDIF ; WHILE (N*DX)>XL ;
      GRMOVE N*DX YB 0 PIC ; GRDRAW N*DX ABS(YT-YB)/100+YB 0 PIC ;
      GRMOVE N*DX YT 0 PIC ; GRDRAW N*DX -ABS(YT-YB)/100+YT 0 PIC ;
      N := N-1 ; ENDWHILE ; N := INT(YT/DY) ; IF N<0 ; N := N-1 ; ENDIF ;
      WHILE (N*DY)>YB ; GRMOVE XL N*DY 0 PIC ;
      GRDRAW  ABS(XR-XL)/100+XL N*DY 0 PIC ; GRMOVE XR N*DY 0 PIC ;
      GRDRAW -ABS(XR-XL)/100+XR N*DY 0 PIC ; N := N-1 ; ENDWHILE ;
      IF (YT>0)*(YB<0) ;                                         {DRAW X-Y AXIS}
      GRMOVE XL 0 0 PIC ; GRDRAW XR 0 0 PIC ;            {DRAW SCALES ON X-AXIS}
      N := INT(XR/DX) ; IF N<0 ; N := N-1 ; ENDIF ; WHILE (N*DX)>XL ;
         GRMOVE N*DX 0 0 PIC ; GRDRAW N*DX (YT-YB)/100 0 PIC ; N := N-1 ;
         ENDWHILE ; ENDIF ;
      IF (XR>0)*(XL<0) ; GRMOVE 0 YB 0 PIC ; GRDRAW 0 YT 0 PIC ;
      N := INT(YT/DY) ; IF N<0 ; N := N-1 ; ENDIF ;      {DRAW SCALES ON Y-AXIS}
      WHILE N*DY>YB ; GRMOVE 0 N*DY 0 PIC ; GRDRAW (XL-XR)/100 N*DY 0 PIC ;
      N := N-1 ; ENDWHILE ; ENDIF ;
      GRMOVE XL YT-(YT-YB)/10 0 PIC ; GRCHAR TITLE PIC ; GRMOVE 0 0 0 PIC ;
      ENDPROCEDURE ;

   PROCEDURE PTY X ;                                          {SET PICTURE TYPE}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before PTY' ; QUIT 0 ; ENDIF ;
      IF LPI#0 ; WRITE 6 ' --- WARNING, BP before PTY --> No effect' ;
      ELSEIF TRUE ; LPG := X ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE BP ; VARIABLE PIC 8 ; VARIABLE I 1 ;
      VARIABLE XF 1 ; VARIABLE YF 1 ; VARIABLE ZF 1 ; VARIABLE COD 1 3 ;
      PROCEDURE CTR X Y Z ; COD(1) := X ; COD(2) := Y ; COD(3) := Z ;
         POLVAL -1 GTRA 3 COD 3 COD 3 ;
         XF := COD(1) ; YF := COD(2) ; ZF := COD(3) ; ENDPROCEDURE ;
      PROCEDURE POS X2 Y2 PIC ; {See CURV in UPDATE}
         IF LPG#0 ; CTR X2*LPG Y2*LPG 0 ;
         ELSEIF TRUE ; XF := X2 ; YF := Y2 ; ZF := SPOS ; ENDIF ;
         GRMOVE ZF XF YF PIC ; ENDPROCEDURE ;
      LPI := 1 ; CLEAR SYS ; GRCOLR 1 SYS ; POLVAL 101 GTRA 3 COD 3 COD 3 ;
      NRAYTRA := MIN(NRAY,NRAYTRA0) ;
      IF NRAY>NRAYTRA0 ; WRITE 6 (' --- WARNING in BP, only the first '&
         SI(NRAYTRA0)&' rays, including the reference, will be drawn') ; ENDIF ;
      RAY(1) := RAY(1)*LCB ;
      LOOP I 1 NRAYTRA ; CLEAR PIC ; GRCOLR RCOL|I PIC ;
         POS RAY(1)|I RAY(3)|I PIC ; TRA(I) := PIC ; ENDLOOP ;
      RAY(1) := RAY(1)*LCB ;
      IF LENV=1 ; CLEAR ETRA ; GRCOLR 3 ETRA ; POS ERAY(1) ERAY(3) ETRA ; ENDIF;
      LOOP I 1 8 ; RSC(I) := RAY(I) ; ENDLOOP ;
      LOOP I 1 4 ; ERSC(I) := ERAY(I) ; ENDLOOP ;
      IF NSPN>0 ; LOOP I 1 3 ; SSC(I) := SPI(I) ; ENDLOOP ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE EP ; LPI := 0 ; ENDPROCEDURE ;

   PROCEDURE PP IU PHI THETA ;        {PRINTS RAY AND SYSTEM PICTURE TO UNIT IU}
      VARIABLE PICLEN 1 ; VARIABLE I 1 ;
      PROCEDURE PRPI ; VARIABLE PICTURE PICLEN ;
         PICTURE := SYS ;
         LOOP I 1 NRAYTRA ; PICTURE := PICTURE&TRA(I) ; ENDLOOP ;
         IF LENV#0 ; PICTURE := PICTURE&ETRA ; ENDIF ;
         IF LAX=2 ; PICTURE := PICTURE&SYS0 ;
            IF (PHI=0)*(THETA=0) ; GRCHAR 'X-motion' PICTURE ;
            ELSEIF (PHI=0)*(THETA=90) ; GRCHAR 'Y-motion' PICTURE ; ENDIF ;
            ENDIF ;
         GRPROJ PHI THETA PICTURE ; WRITE IU PICTURE ; ENDPROCEDURE ;
      PICLEN := 0 ;
      LOOP I 1 NRAYTRA ; PICLEN := PICLEN + LENGTH(TRA(I)) ; ENDLOOP ;
      SVSCR ; PICLEN := PICLEN + LENGTH(SYS) + LENGTH(ETRA) + 200 ;
      PICLEN := MAX(PICLEN,LSCR) ;
      SCRLEN PICLEN ; PRPI ; SCRLEN LSCR ; ENDPROCEDURE ;

   PROCEDURE PPT IU TR PHI THETA ;            {PRINTS RAY TR AND SYSTEM PICTURE}
      VARIABLE PICLEN 1 ;
      PROCEDURE PRPI ; VARIABLE PICTURE PICLEN ;
         PICTURE := SYS ; PICTURE := PICTURE&TR ;
         IF NRAY>0 ; PICTURE := PICTURE&TRA(1) ; ENDIF ;
         IF LAX=2 ; PICTURE := PICTURE&SYS0 ;
            IF (PHI=0)*(THETA=0) ; GRCHAR 'X-motion' PICTURE ;
            ELSEIF (PHI=0)*(THETA=90) ; GRCHAR 'Y-motion' PICTURE ; ENDIF ;
            ENDIF ;
         GRPROJ PHI THETA PICTURE ; WRITE IU PICTURE ; ENDPROCEDURE ;
      SVSCR ; PICLEN := 2*LENGTH(TR)+LENGTH(SYS)+500 ;
      PICLEN := MAX(PICLEN,LSCR) ;
      SCRLEN PICLEN ; PRPI ; SCRLEN LSCR ; ENDPROCEDURE ;

   PROCEDURE PG I1 I2 ;                   {PRINTS X AND Y PROJECTIONS TO SCREEN}
      VARIABLE XA 1 ; VARIABLE XB 1 ; VARIABLE YA 1 ; VARIABLE YB 1 ;
      VARIABLE ZA 1 ; VARIABLE ZB 1 ; VARIABLE DX 1 ; VARIABLE XC 1 ;
      VARIABLE DY 1 ; VARIABLE YC 1 ; VARIABLE DZ 1 ; VARIABLE ZC 1 ;
      VARIABLE F 1 ; VARIABLE LAXO 1 ;
      CLEAR SYS0 ; IF LSYS#0 ; GRMIMA SYS XA XB YA YB ZA ZB ;
      ELSEIF TRUE ; GRMIMA TRA(1) XA XB YA YB ZA ZB ; ENDIF ;
      F := 1.2 ; DX := XB-XA ; DY := YB-YA ; DZ := ZB-ZA ;
      XC := (XB+XA)/2 ; YC := (YB+YA)/2 ; ZC := (ZB+ZA)/2 ;
      IF    LPG#0 ; DZ := MAX(DX,MAX(DY,DZ))/2*F ; DY := DZ ; DX := DZ*1.5 ;
      ELSEIF TRUE ; DZ := DZ/2*F ; DY := DY/2*F ; DX := DX/2*F ; ENDIF ;
      GRMOVE XC+DX YC+DY ZC+DZ SYS0 ; GRMOVE XC-DX YC-DY ZC-DZ SYS0 ;
      IF    LPG#0 ; DZ := DZ/F ; DY := DZ ; DX := DZ ;
      ELSEIF TRUE ; DZ := DZ/F ; DY := DY/F ; DX := DX/F ; ENDIF ;
      IF LAX#0 ; GRCOLR 3 SYS0 ;
         GRMOVE XC+DX YC-DY ZC-DZ SYS0 ; GRCHAR SF(XB-XA,'(G8.2)') SYS0 ;
         GRMOVE XC-DX YC+DY ZC-DZ SYS0 ; GRCHAR SF(YB-YA,'(G8.2)') SYS0 ;
         GRMOVE XC-DX YC-DY ZC+DZ SYS0 ; GRCHAR SF(ZB-ZA,'(G8.2)') SYS0 ;
         GRMOVE XC+DX YC+DY ZC+DZ SYS0 ;
         ENDIF ; LAXO := LAX ; LAX := 2 ;
      PP I1 0 0 ; PP I2 0 90 ; LAX := LAXO ; ENDPROCEDURE ;

   PROCEDURE PGE I1 I2 ;                {PRINTS X AND Y PROJECTIONS OF ENVELOPE}
      VARIABLE XA 1 ; VARIABLE XB 1 ; VARIABLE YA 1 ; VARIABLE YB 1 ;
      VARIABLE ZA 1 ; VARIABLE ZB 1 ; VARIABLE DX 1 ; VARIABLE XC 1 ;
      VARIABLE DY 1 ; VARIABLE YC 1 ; VARIABLE DZ 1 ; VARIABLE ZC 1 ;
      VARIABLE LAXO 1 ;
      IF LENV=0 ; WRITE 6 ' *** ERROR, call ENVEL or SCDE before PGE' ; QUIT 0 ;
         ENDIF ;
      CLEAR SYS0 ; IF LSYS#0 ; GRMIMA SYS XA XB YA YB ZA ZB ;
      ELSEIF TRUE ; GRMIMA TRA(1) XA XB YA YB ZA ZB ; ENDIF ;
      DX := XB-XA ; DY := YB-YA ; DZ := ZB-ZA ;
      XC := (XB+XA)/2 ; YC := (YB+YA)/2 ; ZC := (ZB+ZA)/2 ;
      DX := MAX(DX,MAX(DY,DZ))/2 ; DY := DX*1.2 ; DZ := DX ;
      GRMOVE XC+DY*1.5 YC+DY ZC+DY SYS0 ; GRMOVE XC-DY*1.5 YC-DY ZC-DY SYS0 ;
      GRCOLR 3 SYS0 ;
      GRMOVE XC+DZ YC-DZ ZC-DZ SYS0 ; GRCHAR SF(XB-XA,'(G8.2)') SYS0 ;
      GRMOVE XC-DZ YC+DZ ZC-DZ SYS0 ; GRCHAR SF(YB-YA,'(G8.2)') SYS0 ;
      GRMOVE XC-DZ YC-DZ ZC+DZ SYS0 ; GRCHAR SF(ZB-ZA,'(G8.2)') SYS0 ;
      GRMOVE XC+DX YC+DY ZC+DZ SYS0 ;
      LAXO := LAX ; LAX := 2 ;
      PPT I1 ETRA 0 0 ; PPT I2 ETRA 0 90 ; LAX := LAXO ; ENDPROCEDURE ;

   PROCEDURE STW I MU ALPHA BETA GAMMA ;        {SETS MAP FROM TWISS PARAMETERS}
      VARIABLE COSMU 1 ; VARIABLE SINMU 1 ; VARIABLE I1 1 ; VARIABLE I2 1 ;
      I1 := 2*I-1 ; I2 := 2*I ; COSMU := COS(MU) ; SINMU := SIN(MU) ;
      MAP(I1) := (COSMU + ALPHA*SINMU)*DD(I1) + BETA *SINMU*DD(I2) ;
      MAP(I2) := (COSMU - ALPHA*SINMU)*DD(I2) - GAMMA*SINMU*DD(I1) ;
      ENDPROCEDURE ;

   FUNCTION SE M ;                         {COMPUTES NORM OF J(M)T JJ J(M) - JJ}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      VARIABLE X NM1 ; VARIABLE Y 1 ;
      Y := -1 ; SE := 0 ;
      LOOP I 1 TWOND ; LOOP J 1 TWOND ;
         IF Y*(I-J)=1 ; X:= Y ; ELSEIF TRUE ; X := 0 ; ENDIF ;
         LOOP K 2 TWOND 2 ;
            X := X+DER(K-1,M(I))*DER(K,M(J))-DER(K-1,M(J))*DER(K,M(I)) ;
            ENDLOOP ;
         CO NOC-1 ; SE := SE+WABS(X,WAF) ; CO NOC+1 ;
         ENDLOOP ; Y := -Y ; ENDLOOP ;
      SE := SE/TWOND/TWOND ; ENDFUNCTION ;

   FUNCTION OE A ;             {COMPUTES THE ERROR OF ORTHOGONALITY OF SPIN MAP}
     {OE := |A * A^T - I| + |detA - 1|.}
      VARIABLE X NM1 ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      OE := 0 ;
      LOOP I 1 3 ; LOOP J 1 3 ;
         IF I=J ; X := -1 ; ELSEIF TRUE ; X :=  0 ; ENDIF ;
         LOOP K 1 3 ; X := X+A(I,K)*A(J,K) ; ENDLOOP ;
         OE := OE + WABS(X, WAF) ;
         ENDLOOP ; ENDLOOP ;
      X := A(1,1)*(A(2,2)*A(3,3)-A(3,2)*A(2,3))-
           A(1,2)*(A(2,1)*A(3,3)-A(3,1)*A(2,3))+
           A(1,3)*(A(2,1)*A(3,2)-A(3,1)*A(2,2)) ;
      OE := OE/9+WABS(X-1,WAF) ; ENDFUNCTION ;

   PROCEDURE LFM MF C M F IT ;    {COMPUTES MAP FROM VARIOUS LIE FACTORIZATIONS}
      VARIABLE NOM 1 ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      VARIABLE H1 1 ; VARIABLE H2 1 ; VARIABLE H3 1 ; VARIABLE NF 1 ;
      NOM := NOC ; IF ABS(IT)=1 ; NF := 1 ; ELSEIF ABS(IT)=2 ; NF := NOM-1 ;
      ELSEIF ABS(IT)=3 ; NF := INT(LOG(NOC-1)/LOG(2))+1 ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR in LFM, wrong mode' ; QUIT 0 ; ENDIF ;
      CO NOM+1 ; H1 := 1 ; H2 := 0 ; H3 := 1 ;
      LOOP I 1 TWOND ;
      IF IT=1 ; MF(I) := LEXP(F,DD(I)) ; ELSEIF IT=-1 ;
      MF(I) := LEXP(F,M(I)) ; ELSEIF IT>1 ; MF(I) := LEXP(F(NF),DD(I)) ;
      H1 := NF-1 ; H2 := 1 ; H3 := -1 ; ELSEIF IT<-1 ;
      MF(I) := LEXP(F(1),M(I)) ; H1 := 2 ; H2 := NF ; H3 := 1 ; ENDIF ;
      LOOP J H1 H2 H3 ; MF(I) := LEXP(F(J),MF(I)) ; ENDLOOP ; ENDLOOP ;
      CO NOM ; IF IT>0 ; ANM MF M MF ; ENDIF ;
      LOOP J 1 TWOND ; MF(J) := MF(J) + C(J) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE MLF MF C M F IT ;    {COMPUTES VARIOUS LIE FACTORIZATIONS FROM MAP}
      VARIABLE P NM1 NOC-1 ; VARIABLE IE 1 ;
      VARIABLE L NM1 TWOND ; VARIABLE NL NM1 TWOND ; VARIABLE PL NM1 ;
      VARIABLE SN NM1 NV ; VARIABLE N NM1 NV ; VARIABLE FF NM1 ; VARIABLE NF 1 ;
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 2 ; VARIABLE NOM 1 ;
      PROCEDURE PBO J I PL ; VARIABLE A 1 2^(I-1) I ; VARIABLE B 1 I 2 ;
         VARIABLE Z1 1 ; VARIABLE Z2 1 ; VARIABLE Z3 1 ; VARIABLE Z4 1 ;
         VARIABLE Z5 1 ; VARIABLE NEN 1 ; VARIABLE PH NM1 ;
         Z1 := 1 ; A(1,1) := I ; B(1,1) := 1 ; B(1,2) := 1 ; PL := 0 ;NEN := 1 ;
         LOOP Z2 2 I ; NEN := NEN*Z2 ; B(Z2,1) := Z1 + 1 ;
            LOOP Z3 1 I-Z2+1 ; LOOP Z4 0 B(Z2-1,2)-1 ;
               IF (A(B(Z2-1,1)+Z4,1)-Z3)>0 ; Z1 := Z1 + 1 ; A(Z1,1) := Z3 ;
                  A(Z1,2) := A(B(Z2-1,1)+Z4,1)-Z3 ;
                  LOOP Z5 2 Z2-1 ; A(Z1,Z5+1) := A(B(Z2-1,1)+Z4,Z5) ; ENDLOOP ;
                  PH := PB(P(A(Z1,Z2)),DD(J)) ;
                  LOOP Z5 Z2-1 1 -1 ; PH := PB(P(A(Z1,Z5)),PH) ; ENDLOOP ;
                  PL := PL + PH/NEN ; ENDIF ; ENDLOOP ; ENDLOOP ;
               B(Z2,2) := Z1 - B(Z2,1) + 1 ; ENDLOOP ; ENDPROCEDURE ;
      NOM := NOC ; IF ABS(IT)=1 ; NF := 1 ; ELSEIF ABS(IT)=2 ; NF := NOM-1 ;
      ELSEIF ABS(IT)=3 ; NF := INT(LOG(NOC-1)/LOG(2))+1 ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR in MLF, wrong mode' ; QUIT 0 ; ENDIF ;
      IF TWOND=NV ;
         LOOP I 1 TWOND ; C(I) := CONS(MF(I)) ; N(I) := MF(I)-C(I) ; ENDLOOP ;
         CO 1 ; LOOP I 1 TWOND ; M(I) := N(I) ; ENDLOOP ;
         MI M SN NV IE NOC NV NM1 ; CO NOM ;
      ELSEIF TRUE ; LOOP I 1 TWOND ; SN(I) := 0*DD(I) ; M(I) := 0 ; ENDLOOP ;
         LOOP I TWOND+1 NV ; SN(I) := DD(I) ; ENDLOOP ;
         POLVAL 1 MF TWOND SN NV C TWOND ;
         LOOP I 1 TWOND ; N(I) := MF(I)-C(I) ;
            LOOP J 1 TWOND ; L(J) := DER(J,N(I)) ; ENDLOOP ;
            POLVAL 1 L TWOND SN NV L TWOND ;
            LOOP J 1 TWOND ; M(I) := M(I)+L(J)*DD(J) ; ENDLOOP ; ENDLOOP ;
         LOOP I 1 TWOND ; SN(I) := M(I) ; ENDLOOP ; MI SN SN NV IE NOC NV NM1 ;
         ENDIF ;
      IF IE#0 ; WRITE 6 ' *** ERROR in MLF, map singular' ; QUIT 0 ; ENDIF ;
      IF ABS(IT)=1 ; IF IT=1 ; POLVAL 1 N TWOND SN NV SN TWOND ;
         ELSEIF IT=-1 ; LOOP I TWOND+1 NV ; N(I) := DD(I) ; ENDLOOP ;
            POLVAL 1 SN TWOND N NV SN TWOND ; ENDIF ;
         LOOP I 1 TWOND ; N(I) := SN(I) - DD(I) ; L(I) := 0*DD(I) ; ENDLOOP ;
         LOOP I 2 NOM ; LOOP J 1 TWOND ; PBO J I-1 PL ; CO I ;
               NL(J) := N(J) - L(J) - PL ; ENDLOOP ;
            LOOP J 1 TWOND 2 ; SN(J) := NL(J+1) ; SN(J+1) := -NL(J) ; ENDLOOP ;
            LOOP J 1 TWOND ; L(J) := N(J) ; ENDLOOP ; CO I+1 ;
            POTI SN TWOND FF ; P(I-1) := FF ; ENDLOOP ; CO NOM+1 ;
         F := 0*DD(1) ; LOOP J 1 NOM-1 ; F := F + P(J) ; ENDLOOP ; CO NOM ;
      ELSEIF IT>1 ; POLVAL 1 N TWOND SN NV N TWOND ;
         LOOP I 1 NF ; IF IT=2 ; K := I+1 ; ELSEIF IT=3 ; K := MIN(NOM,2^I) ;
               ENDIF ; CO K ; LOOP J 1 TWOND 2 ;
               SN(J) := N(J+1)-DD(J+1) ; SN(J+1) := -N(J)+DD(J) ; ENDLOOP ;
         CO K+1 ; POTI SN TWOND FF ; F(I) := FF ; CO NOM+1 ;
         LOOP J 1 TWOND ; N(J) := LEXP(-FF,N(J)) ; ENDLOOP ; ENDLOOP ; CO NOM ;
      ELSEIF IT<-1 ; LOOP I TWOND+1 NV ; N(I) := DD(I) ; ENDLOOP ;
         POLVAL 1 SN TWOND N NV N TWOND ;
         LOOP J TWOND+1 NV ; N(J) := DD(J) ; ENDLOOP ;
         LOOP I 1 NF ; IF IT=-2 ; K := I+1 ; ELSEIF IT=-3 ; K := MIN(NOM,2^I) ;
               ENDIF ; CO K ; LOOP J 1 TWOND 2 ;
               SN(J) := N(J+1)-DD(J+1) ; SN(J+1) := -N(J)+DD(J) ; ENDLOOP ;
            CO K+1 ; POTI SN TWOND FF ; F(I) := FF ; CO NOM+1 ;
            LOOP J 1 TWOND ; SN(J) := LEXP(-FF,DD(J)) ; ENDLOOP ; CO NOM ;
            POLVAL 1 SN TWOND N NV N TWOND ; ENDLOOP ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE LFLF C M F P IA IT ; VARIABLE ML NM1 NV ;
      LFM ML C M F IA ; MLF ML C M P IT ; ENDPROCEDURE ;

   PROCEDURE GFM MM F IT ;         {COMPUTES MAP FROM F(IT) GENERATING FUNCTION}
      VARIABLE N NM1 NV ; VARIABLE M NM1 NV ; VARIABLE I 1 ;
      IF ABS(IT-1.5)=0.5 ;
      LOOP I 1 TWOND 2 ; M(I) := DD(I) ; M(I+1) := DER(I,F) ; ENDLOOP ;
      ELSEIF ABS(IT-3.5)=0.5 ;
      LOOP I 1 TWOND 2 ; M(I) := -DER(I,F) ; M(I+1) := DD(I) ; ENDLOOP ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR in GFM, wrong type' ; QUIT 0 ; ENDIF ;
      LOOP I TWOND+1 NV ; M(I) := DD(I) ; ENDLOOP ; MI M N NV I NOC NV NM1 ;
      IF I#0 ; WRITE 6 ' *** ERROR in GFM, no inverse' ; QUIT 0 ; ENDIF ;
      IF ABS(IT-2)=1 ;
      LOOP I 1 TWOND 2 ; M(I) := DD(I+1) ; M(I+1) := -DER(I+1,F) ; ENDLOOP ;
      ELSEIF ABS(IT-3)=1 ;
      LOOP I 1 TWOND 2 ; M(I) := DER(I+1,F) ; M(I+1) := DD(I+1) ; ENDLOOP ;
      ENDIF ; ANM M N MM ; ENDPROCEDURE ;

   PROCEDURE MGF MM F IT IE ;         {CALCULATION OF F(IT) GENERATING FUNCTION}
      PROCEDURE MGFF IE ;
         VARIABLE N NM1 NV ; VARIABLE M NM1 NV ; VARIABLE AM 1 ND ND ;
         VARIABLE A 1 4 ; VARIABLE B 1 4 ; VARIABLE C 1 ; VARIABLE D 1 ;
         VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
         PROCEDURE SUBDET K D ; LOOP I 1 ND ; LOOP J 1 ND ;
            AM(I,J) := COEF(MM(2*I-A(K)),2*J-B(K)) ; ENDLOOP ; ENDLOOP ;
            LDET AM ND ND D ; ENDPROCEDURE ;
         IE := 0 ; C := 0 ; LOOP I 1 TWOND ; C := C+ABS(CONS(MM(I))) ; ENDLOOP ;
         IF C#0 ; WRITE 6 ' *** ERROR in MGF, map not 0-0 ' ; QUIT 0 ; ENDIF ;
         A(1) := 1 ; A(2) := 0 ; A(3) := 1 ; A(4) := 0 ;
         B(1) := 0 ; B(2) := 0 ; B(3) := 1 ; B(4) := 1 ;
         IF IT>0 ; SUBDET IT C ; ELSEIF IT=-1 ; LOOP K 1 4 ; SUBDET K D ;
         IF C<ABS(D) ; C := ABS(D) ; IT := K ; ENDIF ; ENDLOOP ; ELSEIF TRUE ;
         WRITE 6 ' *** ERROR in MGF, wrong type' ; QUIT 0 ; ENDIF ;
         IF C=0 ; IE := 1 ; ELSEIF C#0 ; LOOP I 1 TWOND 2 ;
            N(I) := DD(I+B(IT)) ; N(I+1) := MM(I+1-A(IT)) ; ENDLOOP ;
         LOOP I TWOND+1 NV ; N(I) := DD(I) ; ENDLOOP ; MI N M NV IE NOC NV NM1 ;
         LOOP I 1 TWOND 2 ; N(I) := (1-2*B(IT))*DD(I+1-B(IT)) ;
         N(I+1) := (1-2*A(IT))*MM(I+A(IT)) ; ENDLOOP ; ANM N M M ;
         CO NOC+1 ; POTI M TWOND F ; CO NOC-1 ; ENDIF ; ENDPROCEDURE ;
      PROCEDURE BESTGF IE ;
         VARIABLE NAP NM1 NV ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE DIF 1 ;
         VARIABLE G NM1 ; VARIABLE ER 1 ; IE := 0 ; ER := 1E36 ; I := 0 ;
         LOOP IT 1 4 ; MGFF J ; IF J=0 ; GFM NAP F IT ; DIF := 0 ;
         LOOP J 1 TWOND ; DIF := DIF+ABS(MM(J)-NAP(J)) ; ENDLOOP ;
         IF DIF<ER ; I := IT ; CO NOC+1 ; G := F ; CO NOC-1 ; ER := DIF ;
         ENDIF ; ENDIF ; ENDLOOP ; IF I=0 ; IE := 1 ; ENDIF ; IT := I ;
         CO NOC+1 ; F := G ; CO NOC-1 ; ENDPROCEDURE ;
      IF IT=-2 ; BESTGF IE ; ELSEIF TRUE ; MGFF IE ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE SY MM ; VARIABLE IT 1 ; VARIABLE IE 1 ; VARIABLE F NM1 ;
      IT := -1 ; MGF MM F IT IE ; GFM MM F IT ; ENDPROCEDURE ;

   PROCEDURE BDEP NAP LGH B ;       {PARAMETER DEPENDENCE FROM FIELD DEPENDENCE}
      VARIABLE IAP NM1 NV ; VARIABLE NT NM1 ; VARIABLE NC 1 ; VARIABLE F1 NM1 ;
      VARIABLE I 1 ; VARIABLE BW NM2 ; VARIABLE ZW 2 ; VARIABLE AW 2 ;
      VARIABLE NU1 1 ; VARIABLE NU2 1 ; VARIABLE MC 1 ; VARIABLE PW NM2 ;
      FUNCTION WW Q ; IF CONS(Q)#0 ; WW := Q/CONS(Q) ; ELSEIF TRUE ; WW := 1 ;
         ENDIF ; ENDFUNCTION ; NU1 := MIN(TWOND,4) ; NU2 := MIN(TWOND,5) ;
      MC := CONS(M0) ; BW := WW(B) ; ZW := WW(Z0) ; AW := WW(LGH) ;
      PW := WW(P0) ; NC := CONS(ETA) ; BW := BW*ZW*AW/PW ;
      LOOP I 1 NU1 2 ; IAP(I) := DD(I)/AW ; IAP(I+1) := DD(I+1)/PW ; ENDLOOP ;
      LOOP I NU1+1 NV ; IAP(I) := DD(I) ; ENDLOOP ; IF ND>2 ; NAP(6) := DD(6) ;
      ENDIF ; I := TWOND+1 ; IF TYPE(B)=TYPE(DD(1)) ; WHILE CONS(DER(I,B))=0 ;
      I := I+1 ; ENDWHILE ; ENDIF ; IAP(I) := 0*IAP(1)+BW-1 ;
      POLVAL 1 NAP NU2 IAP NV NAP NU2 ; LOOP I 1 NU1 2 ; NAP(I) := NAP(I)*AW ;
      NAP(I+1) := NAP(I+1)*PW ; ENDLOOP ; IF ND=3 ; F1 := CONS(V0)/V0 ;
      NAP(5) := DD(5)+LGH*(1+NC)/(2+NC)*(1-F1)+F1*AW*(NAP(5)-DD(5)) ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE EDEP NAP LGH B ;      {PARAMETER DEPENDENCE FROM ENERGY DEPENDENCE}
      VARIABLE IAP NM1 NV ; VARIABLE NT NM1 ; VARIABLE NC 1 ; VARIABLE F1 NM1 ;
      VARIABLE I 1 ; VARIABLE BW 2 ; VARIABLE ZW 2 ; VARIABLE AW 2 ;
      VARIABLE NU1 1 ; VARIABLE NU2 1 ; VARIABLE MC 1 ;
      FUNCTION WW Q ; IF CONS(Q)#0 ; WW := Q/CONS(Q) ; ELSEIF TRUE ; WW := 1 ;
         ENDIF ; ENDFUNCTION ; NU1 := MIN(TWOND,4) ; NU2 := MIN(TWOND,5) ;
      MC := CONS(M0) ; BW := WW(B) ; ZW := WW(Z0) ; AW := WW(LGH) ;
      NC := CONS(ETA) ; NT := SQRT(1+SQR(P0/MC/AMUMEV/BW/ZW/AW))-1 ;
      LOOP I 1 NU1 2 ; IAP(I) := DD(I)/AW ; NAP(I) := NAP(I)*AW ; ENDLOOP ;
      LOOP I 2 NU1 2 ; IAP(I) := DD(I)/BW/ZW/AW ; NAP(I) := NAP(I)*BW*ZW*AW ;
      ENDLOOP ; LOOP I NU1+1 NV ; IAP(I) := DD(I) ; ENDLOOP ;
      IF ND<3 ; I := TWOND+1 ; WHILE CONS(DER(I,E0))=0 ; I := I+1 ;
      IF I>NV ; WRITE 6 ' *** ERROR in EDEP, energy not parameter' ; QUIT 0 ;
      ENDIF ; ENDWHILE ; ELSEIF ND>2 ; I := 6 ; ENDIF ;
      IAP(I) := 0*IAP(1)+NT/NC-1 ;
      POLVAL 1 NAP NU2 IAP NV NAP NU2 ;
      IF ND=3 ; F1 := (1+ETA)/(1+NT)*M0/MC/BW/ZW/AW ;
      NAP(5) := DD(5)+LGH*(1+NC)/(2+NC)*(1-F1)+F1*AW*(NAP(5)-DD(5)) ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE MCM IAP LGH ALPHA ;                  {MOMENTUM COMPACTION dL(dP)/L}
      VARIABLE XF NM1 NV ; VARIABLE MF NM1 TWOND ; VARIABLE IER 1 ;
      IF ND#3 ; WRITE 6 ' *** ERROR in MCM, dimension # 3' ; ENDIF ;
      CATR IAP IAP LGH ; TWOND := 5 ; FM IAP XF MF IER ; TWOND := 6 ;
      ALPHA := (XF(5)-DD(5))/LGH ; ENDPROCEDURE ;

   PROCEDURE ECM IAP LGH ALPHA ;                      {ENERGY COMPACTION dT(dE)}
      VARIABLE XF NM1 NV ; VARIABLE MF NM1 TWOND ; VARIABLE IER 1 ;
      IF ND#3 ; WRITE 6 ' *** ERROR in ECM, dimension # 3' ; ENDIF ;
      TWOND := 5 ; FM IAP XF MF IER ; TWOND := 6 ; ALPHA := XF(5)-DD(5) ;
      ENDPROCEDURE ;

   PROCEDURE BM M MB A IER ;   {WRITES M = A^(-1) MB A, MB HAS DECOUPLED PLANES}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE MM 1 NV NV ;
      VARIABLE MA 1 NV NV ; VARIABLE MI 1 NV NV ; VARIABLE SCR NM1 NV ;
      LOOP I 1 TWOND ; LOOP J 1 TWOND ;
         DAPEE M(I) J K ; MM(I,J) := K ; ENDLOOP ; ENDLOOP ;
      MBLOCK MM MA MI NV TWOND ;  LOOP I 1 TWOND ; A(I) := 0 ; SCR(I) := 0 ;
         LOOP J 1 TWOND ; A(I) := A(I) + MI(I,J)*DD(J) ;
         SCR(I) := SCR(I) + MA(I,J)*DD(J) ; ENDLOOP ; ENDLOOP ;
      ANM M SCR SCR ; LOOP I 1 TWOND ; MB(I) := 0 ;
         LOOP J 1 TWOND ; MB(I) := MB(I) + MI(I,J)*SCR(J) ; ENDLOOP ; ENDLOOP ;
      ENDPROCEDURE ;

   PROCEDURE GT MM F MU ALPHA BETA GAMMA R ;
     {FIX, TUNE, 3 TWISS, CONTRACTION, FOR BLOCK DIAGONAL MAPS}
      VARIABLE A NMP ; VARIABLE B NMP ; VARIABLE C NMP ; VARIABLE D NMP ;
      VARIABLE COSMU 2*NMP ; VARIABLE SINMU 2*NMP ; VARIABLE DEN 2*NMP ;
      VARIABLE M NM1 TWOND ; VARIABLE I 2 ; VARIABLE J 1 ; VARIABLE K 1 ;
      VARIABLE L 1 ; VARIABLE DET 1 ;
      PROCEDURE OUT ; VARIABLE DUM 2*NMP ; DUM := R(J)*SINMU ;
         MU(J) := MU(J)/2/PI ; ALPHA(J) := (A-D)/2/DUM ; BETA(J) := B/DUM ;
         GAMMA(J) := -C/DUM ; ENDPROCEDURE ; FM MM F M I ; IMUNIT I ;
      LOOP J 1 ND ; K := 2*J-1 ; L := K+1 ; DAPEP M(K) K TWOND A ;
         DAPEP M(K) L TWOND B ; DAPEP M(L) K TWOND C ;  DAPEP M(L) L TWOND D ;
         DET := CONS(A)*CONS(D)-CONS(B)*CONS(C) ; CO NOC-1 ;
         IF DET>0 ; R(J) := SQRT(A*D-B*C) ; COSMU := (A+D)/2/R(J) ;
            IF ABS(ABS(CONS(COSMU))-1)<DEPS ;
               IF ((ABS(B)+ABS(C))=0)*(ABS(COSMU-CONS(COSMU))=0) ;
                  ALPHA(J) := 0 ; BETA(J) := 1 ; GAMMA(J) := 1 ;
                  IF CONS(COSMU)<0 ; MU(J) := 1/2+0*DD(1) ;
                  ELSEIF TRUE ; MU(J) := 0*DD(1) ; ENDIF ;
               ELSEIF TRUE ; WRITE 6 ' *** ERROR in GT, unrepresentable map' ;
                  QUIT 0 ; ENDIF ;
            ELSEIF ABS(CONS(COSMU))>1 ; IF CONS(COSMU)<0 ; COSMU := - COSMU ;
                 DEN := PI ; K := -1 ; ELSEIF TRUE ; DEN := 0 ; K := 1 ; ENDIF ;
               SINMU := SQRT(SQR(COSMU)-1) ;
               MU(J) := DEN+I*LOG(COSMU+SINMU) ; SINMU := K*I*SINMU ; OUT ;
            ELSEIF ABS(CONS(COSMU))<1 ; MU(J) := ACOS(COSMU) ;
               IF CONS(B)<0 ; MU(J) := 2*PI-MU(J) ; ENDIF ;
               SINMU := SIN(MU(J)) ;  OUT ;
            ENDIF ;
         ELSEIF DET=0 ; IF (ABS(A)=0)*(ABS(B)=0)*(ABS(C)=0)*(ABS(D)=0) ;
         R(J) := 0 ; MU(J) := 0 ; ALPHA(J) := 0 ; BETA(J) := 1 ; GAMMA(J) := 1 ;
            ELSEIF TRUE ; WRITE 6 ' *** ERROR in GT, DET=0' ; QUIT 0 ; ENDIF ;
         ELSEIF DET<0 ; DEN := SQRT(-(A*D-B*C)) ; R(J) := I*DEN ;
            COSMU := (A+D)/2/DEN ;
            IF CONS(COSMU)<0 ; COSMU := - COSMU ; K := -1 ; ELSEIF TRUE ;
               K := 1 ; ENDIF ; SINMU := SQRT(SQR(COSMU)+1) ;
            MU(J) := PI/2+K*I*LOG(SINMU+COSMU) ; OUT ;
         ENDIF ; CO NOC+1 ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE DANF M MN MA IMA RS EPS ;       {COMPUTES NORMAL FORM MN. IF IMA#0,
      TRANSFORMATION MA IS ALSO COMPUTED. RS: RESONANCE STRENGTHS}
      VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE L 2 ; VARIABLE NOM 1 ;
      VARIABLE IER 1 ; VARIABLE XF 100 NV ; VARIABLE T 2*NM1 ;
      VARIABLE F 100 TWOND ; VARIABLE MUU 100 ND ; VARIABLE AA 100 ND ;
      VARIABLE BB 100 ND ; VARIABLE GG 100 ND ; VARIABLE RR 100 ND ;
      VARIABLE MU 2 ; VARIABLE A 2 ; VARIABLE B 2 ; VARIABLE D 2 ;
      VARIABLE PHI 1 TWOND ; VARIABLE R 1 TWOND ;
      VARIABLE M1 2*NM1 NV ; VARIABLE M2 2*NM1 NV ; VARIABLE M3 2*NM1 NV ;
      VARIABLE I 2 ; IMUNIT I ; NOM := NOC ; DSET 1E-14 ; LWNDANF := 0 ;
      FM M  XF MN IER ;  BM MN MN M1 IER ;
      IF IMA#0 ; LOOP J 1 TWOND ; MA(J) := -XF(J) + DD(J) ; ENDLOOP ;
         POLVAL 1 M1 TWOND MA TWOND MA TWOND ; ENDIF ;
         GT MN F MUU AA BB GG RR ;
      LOOP J 1 ND ; K:= 2*J-1 ; L := K + 1 ; MU := CONS(MUU(J))*2*PI ;
         A := CONS(AA(J)) ; B := CONS(BB(J)) ; D := CONS(RR(J)) ;
         IF TYPE(MU)=TYPE(1) ; PHI(K) := MU ; PHI(L) := -MU ;
            R(K) := D ; R(L) := D ;
            M2(K) :=  (     I*B       *DD(K) +    I*B  *DD(L) )/SQRT(2*I*B) ;
            M2(L) :=  ( (-1-I*A)      *DD(K) + (1-I*A) *DD(L) )/SQRT(2*I*B) ;
            M1(K) :=  ( ( 1-I*A)/2/I/B*DD(K) -      1/2*DD(L) )*SQRT(2*I*B) ;
            M1(L) :=  ( ( 1+I*A)/2/I/B*DD(K) +      1/2*DD(L) )*SQRT(2*I*B) ;
         ELSEIF TRUE ; PHI(K) := 0 ; PHI(L) := 0 ; MU := IMAG(MU) ;
            IF IMAG(D)#0 ; WRITE 6 '$$$ ERROR DANF ' ; ENDIF ; D := REAL(D) ;
            R(K) := D*EXP(-MU) ; R(L) := D*EXP(MU) ;
            M2(K) := DD(K)+0*I ; M2(L) := DD(L)+0*I ;
            M1(K) := DD(K)+0*I ; M1(L) := DD(L)+0*I ; ENDIF ;
         ENDLOOP ; ANM MN M2 MN ; CPOLVAL 1 M1 TWOND MN TWOND MN TWOND ;
      IF IMA#0 ; CPOLVAL 0 M1 TWOND MA TWOND MA TWOND ; ENDIF ;
      NOM := NOC ; RS := 0 ;   LOOP J 2 NOM ; LOOP K 1 TWOND ; CO J ;
         CDNFDA MN(K) R PHI K TWOND EPS T ; M3(K) := -T ; CO NOM ;
         IF (K/2)=NINT(K/2) ; RS := RS + T*DD(K-1) ; ENDIF ; ENDLOOP ;
         LOOP K 1 TWOND ; CDFLO M3 DD(K)+0*I T TWOND ; M1(K) := T ; ENDLOOP ;
         LOOP K 1 TWOND ; M3(K) := -M3(K) ; ENDLOOP ;
         LOOP K 1 TWOND ; CDFLO M3 DD(K)+0*I T TWOND ; M2(K) := T ; ENDLOOP ;
         LOOP K TWOND+1 NV ; M1(K) := DD(K)+0*M1(1) ; M2(K) := DD(K) ; ENDLOOP ;
         CPOLVAL 1 MN TWOND M1 NV M3 TWOND ;
         LOOP K TWOND+1 NV ; M3(K) := M1(K) ; ENDLOOP ;
         CPOLVAL 1 M2 TWOND M3 NV MN TWOND ;
         IF IMA#0 ; LOOP K 1 TWOND ; M3(K) := MA(K) ; ENDLOOP ;
            LOOP K TWOND+1 NV ; M3(K) := DD(K)+0*M3(1) ; ENDLOOP ;
            CPOLVAL 1 M2 TWOND M3 NV MA TWOND ; ENDIF ; ENDLOOP ;
      LOOP J 1 ND ; K:= 2*J-1 ; L := K + 1 ; IF PHI(K)#0 ;
            M1(K) := (  DD(K) - I*DD(L))/SQRT(2*I) ;
            M1(L) := (  DD(K) + I*DD(L))/SQRT(2*I) ;
            M2(K) := (  DD(K) +   DD(L))*SQRT(I/2) ;
            M2(L) := (I*DD(K) - I*DD(L))*SQRT(I/2) ;
         ELSEIF TRUE ;
            M1(K) := DD(K)+0*I ; M1(L) := DD(L)+0*I ;
            M2(K) := DD(K)+0*I ; M2(L) := DD(L)+0*I ; ENDIF ; ENDLOOP ;
      LOOP K TWOND+1 NV ; M1(K) := DD(K)+0*M1(1) ; ENDLOOP ;
      CPOLVAL 1 MN TWOND M1 NV M3 TWOND ;
      LOOP K TWOND+1 NV ; M3(K) := M1(K) ; ENDLOOP ;
      CPOLVAL 1 M2 TWOND M3 NV MN TWOND ;
      IF IMA#0 ; CPOLVAL 1 M2 TWOND MA TWOND MA TWOND ; LOOP K 1 TWOND ;
         MA(K) := REAL(MA(K)) ; ENDLOOP ;
      ENDIF ;  LOOP K 1 TWOND ; IF ABS(IMAG(MN(K)))>1E-6 ; LWNDANF := LWNDANF+1;
       {WRITE 6 ' --- WARNING in DANF, computational errors >1E-6' ;} ENDIF ;
        MN(K) := REAL(MN(K)) ; ENDLOOP ; DSET 1E-16 ; ENDPROCEDURE ;

   PROCEDURE NF EPS MA ; VARIABLE MN 2*NM1 NV ; VARIABLE RES 2*NM1 ;  {NF TRAFO}
      DANF MAP MN MA 1 RES EPS ; ENDPROCEDURE ;

   PROCEDURE TS MU ;      {COMPUTES TUNE DEPENDENCE ON PARAMETERS AND AMPLITUDE}
      VARIABLE MN 2*NM1 TWOND ; VARIABLE MA 2*NM1 TWOND ; VARIABLE S1 2*NM1 ;
      VARIABLE S2 NM1 ; VARIABLE I 1 ; VARIABLE J 2 ; VARIABLE NOM 1 ;
      LWNTS := 0 ; DANF MAP MN MA 1 S1 1E-7 ; NOM := NOC ;
      LOOP I 1 ND ; S1 := REAL(MN(2*I-1)) ;
      LOOP J 2 TWOND 2 ; DAPLU S1 J 0 S2 ; S1 := S2 ; ENDLOOP ;
      IF ABS(S1)=0 ; S1 := DA(2*I-1) ; ENDIF ;
      S2 := 0 ; CO NOC+1 ;
      WHILE (ABS(S2)=0)*(NOC>1) ;
         CO NOC-1 ; S1 := S1 ; DADIU 2*I-1 S1 S2 ; ENDWHILE ;
      IF NOC<NOM ; CO NOM ; LWNTS := LWNTS+1 ; {WRITE 6 (' --- WARNING in TS, '&
         'computational errors prevent full order') ;} ENDIF ;
      J := COEF(REAL(MN(2*I-1)),2*I) ; CO NOC-1 ;
      IF J=0 ; IF CONS(S2)<0 ; S2 := -S2 ; MU(I) := PI ; ELSEIF TRUE ;
         MU(I) := 0 ; ENDIF ; IMUNIT J ; MU(I) := MU(I) - J*LOG(S2) ;
      ELSEIF TRUE ; MU(I) := ACOS(S2) ; IF CONS(MU(I))<0 ; MU(I) := -MU(I) ;
         ENDIF ; IF J<0 ; MU(I) := 2*PI-MU(I) ; ENDIF ; ENDIF ;
      CO NOM ; MU(I) := MU(I)/2/PI ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE TP MU ;                    {COMPUTES TUNE DEPENDENCE ON PARAMETERS}
      VARIABLE A NM1 3 ; VARIABLE B NM1 3 ; VARIABLE G NM1 3 ; VARIABLE I 1 ;
      VARIABLE R NM1 3 ; VARIABLE F NM1 10 ; VARIABLE I 1 ; VARIABLE K 1 ;
      VARIABLE I1 1 ; VARIABLE I2 1 ; VARIABLE LC 1 ; VARIABLE S NM1 ;
      LC := 0 ; LOOP I 1 ND ; I2 := 2*I ; I1 := I2-1 ; LOOP K I2+1 TWOND ;
         IF     ME(I1,K)#0 ; LC := 1 ; ELSEIF ME(I2,K)#0 ; LC := 1 ;
         ELSEIF ME(K,I1)#0 ; LC := 1 ; ELSEIF ME(K,I2)#0 ; LC := 1 ; ENDIF ;
         ENDLOOP ; ENDLOOP ; IF LC=0 ; GT MAP F MU A B G R ;
      ELSEIF LC=1 ; TS MU ; LOOP I 1 ND ; LOOP K 1 TWOND ;
      DAPLU MU(I) K 0 S ; MU(I) := S ; ENDLOOP ; ENDLOOP ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE RS RES ;                             {COMPUTES RESONANCE STRENGTHS}
      VARIABLE MN 2*NM1 TWOND ; VARIABLE MA 2*NM1 TWOND ; VARIABLE EPS 1 ;
      EPS := 1E-7 ; DANF MAP MN MA 1 RES EPS ; ENDPROCEDURE ;

   PROCEDURE NORMSU2 UI UO CU NBAR STUNE MN MA EPS ;
      VARIABLE U1 2*NM1 2 ; VARIABLE U2 2*NM1 2 ; VARIABLE UOO 2*NM1 2 ;
      VARIABLE CUU 2*NM1 2 ; VARIABLE XX NM1 1 ; VARIABLE YY NM1 1 ;
      VARIABLE NBN NM1 3 ; VARIABLE MAI NM1 NV ; VARIABLE MNN NM1 NV ;
      VARIABLE MAA NM1 NV ; VARIABLE M1 4 NV ; VARIABLE M2 4 NV ;
      VARIABLE R 1 TWOND ; VARIABLE PHI 1 TWOND ; VARIABLE U0 2 2 ;
      VARIABLE IU 2 ; VARIABLE K 2 ; VARIABLE D 1 ;
      VARIABLE I 1 ; VARIABLE L 2 ;
      PROCEDURE IDENSU2 A ; VARIABLE IU 2 ;
         IMUNIT IU ; A(1) := 1+IU*0 ; A(2) := 0+IU*0 ; ENDPROCEDURE ;
      PROCEDURE MULASU2 A B C ;
         A(1) := B(1)*C(1)-B(2)*CONJ(C(2)) ; A(2) := B(1)*C(2)+B(2)*CONJ(C(1)) ;
         ENDPROCEDURE ;
      PROCEDURE INVRSU2 A B ;
         A(1) := CONJ(B(1)) ; A(2) := -B(2) ; ENDPROCEDURE ;
      PROCEDURE MEXPSU2 A B ;
         VARIABLE C1 2*NM1 2 ; VARIABLE C2 2*NM1 2 ; VARIABLE I 1 ;
         I := ABS(CONS(REAL(B(1))))+ABS(CONS(REAL(B(2))))+
              ABS(CONS(IMAG(B(1))))+ABS(CONS(IMAG(B(2)))) ;
         IF I#0 ; WRITE 6 ' *** ERROR in MEXPSU2' ; QUIT 0 ; ENDIF ;
         IDENSU2 A ; IDENSU2 C1 ;
         LOOP I 1 NOC ;
            MULASU2 C2 C1 B ;
            C1(1) := (1/I)*C2(1) ; C1(2) := (1/I)*C2(2) ; A(1) := A(1)+C1(1) ;
            A(2) := A(2)+C1(2) ; ENDLOOP ; ENDPROCEDURE ;
      PROCEDURE EHOMSU2 A B J ; VARIABLE C 2*NM1 2 ; VARIABLE K 1 ;
         K := NOC ; CO J ; A(1) := B(1) ; A(2) := B(2) ;
         CO J-1 ; C(1) := B(1) ; C(2) := B(2) ; CO K ;
         A(1) := A(1)-C(1) ; A(2) := A(2)-C(2) ; ENDPROCEDURE ;
      PROCEDURE CORRSU2 A ; VARIABLE D NM1 ;
         D := SQR(REAL(A(1)))+SQR(REAL(A(2)))+SQR(IMAG(A(1)))+SQR(IMAG(A(2))) ;
         D := ISRT(D) ; A(1) := D*A(1) ; A(2) := D*A(2) ; ENDPROCEDURE ;
      PROCEDURE SOLVSU2 U1 U2 D PHI R M1 M2 EPS ; VARIABLE YY 2*NM1 ;
         CPOLVAL 1 U2 2 M2 NV U1 2 ;
         CDNFDS U1(1) R PHI 0 2*ND EPS YY ; U1(1) := YY ;
         CDNFDS U1(2) R PHI -D 2*ND EPS YY ; U1(2) := YY ;
         CPOLVAL 1 U1 2 M1 NV U2 2 ; U1(1) := U2(1) ; U1(2) := U2(2) ;
         ENDPROCEDURE ;
      PROCEDURE ANALMAP MN PHI R M1 M2 ;
         VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE L 1 ; VARIABLE D 1 ;
         VARIABLE A 1 ; VARIABLE B 1 ; VARIABLE C 1 ; VARIABLE IU 2 ;
         IMUNIT IU ;
         LOOP J 1 ND ;
            K := 2*J-1 ; L := K+1 ;
            A := COEF(MN(K),K) ; B := COEF(MN(K),L) ;
            C := COEF(MN(L),K) ; D := COEF(MN(L),L) ;
            IF 1+B*B+C*C#1 ;
               R(K) := SQRT(A*A+B*B) ; R(L) := R(K) ;
               PHI(K) := ACOS(A/R(K))*(B/ABS(B)) ; PHI(L) := -PHI(K) ;
            ELSEIF TRUE ;
               PHI(K) := 0 ; PHI(L) := 0 ;
               R(K)   := A ; R(L)   := D ; ENDIF ;
            IF PHI(K)#0 ;
               M1(K) := (DD(K)-IU*DD(L)) ; M1(L) := (DD(K)+IU*DD(L)) ;
               M2(K) := (DD(K)+DD(L))/2+0*IU ; M2(L) := (IU*DD(K)-IU*DD(L))/2 ;
            ELSEIF TRUE ;
               M1(K) := DD(K)+0*IU ; M1(L) := DD(L)+0*IU ;
               M2(K) := DD(K)+0*IU ; M2(L) := DD(L)+0*IU ; ENDIF ;
            ENDLOOP ;
         LOOP J TWOND+1 NV ; M1(J) := DD(J)+0*IU ; M2(J) := DD(J)+0*IU ;
            ENDLOOP ; ENDPROCEDURE ;
      PROCEDURE MAPINVR M1 M2 ; VARIABLE J 1 ;
         MI M1 M2 NV J NOC NV NM1 ;
         IF J#0 ; WRITE 6 ' *** ERROR in MAPINVR' ; QUIT 0 ; ENDIF ;
         ENDPROCEDURE ;
      IMUNIT IU ; ANALMAP MN PHI R M1 M2 ;
      LOOP I 1 TWOND ; MNN(I) := MN(I) ; MAA(I) := MA(I) ; ENDLOOP ;
      LOOP I TWOND+1 NV ; MNN(I) := DD(I)+0*MNN(1) ;
         MAA(I) := DD(I)+0*MAA(1) ; ENDLOOP ;
      MAPINVR MAA MAI ; U1(1) := UI(1) ; U1(2) := UI(2) ;
      CPOLVAL 1 U1 2 MAI NV UOO 2 ; CORRSU2 UOO ;
      U0(1) := CONS(UOO(1)) ; U0(2) := CONS(UOO(2)) ;
      D := SQR(REAL(U0(2))) + SQR(IMAG(U0(2))) ;
      IF CONS(D)>0 ; D := SQRT(D) ; ENDIF ;
      IF 1+ABS(D)=1 ;
         L := U0(1) ; IDENSU2 CUU ;
      ELSEIF TRUE ;
         D := REAL(U0(1)) ; L := D+IU*SQRT(1-SQR(D)) ;
         K := U0(2)/(U0(1)-L) ; D := ISRT(1+SQR(REAL(K))+SQR(IMAG(K))) ;
         CUU(1) := K*D ; CUU(2) := D+0*IU ; ENDIF ;
      D := ISRT(SQR(REAL(L))+SQR(IMAG(L))) ; L := D*L ; MULASU2 U1 UOO CUU ;
      INVRSU2 U2 CUU ; MULASU2 UOO U2 U1 ;
      UOO(1) := UOO(1)-CONS(UOO(1))+L ; UOO(2) := UOO(2)-CONS(UOO(2)) ;
      D := ACOS(REAL(L)) ; IF IMAG(L)<0 ; D := -D ; ENDIF ;
      K := -COS(D)+IU*SIN(D) ; D := 2*D ;
      IF D<0 ; D := D + 2 * PI ; ENDIF ;
      LOOP I 1 NOC ;
         EHOMSU2 U1 UOO I ; U2(1) := K*U1(1) ; U2(2) := K*U1(2) ;
         SOLVSU2 U1 U2 D PHI R M1 M2 EPS ; MEXPSU2 U2 U1 ; MULASU2 U1 CUU U2 ;
         CUU(1) := U1(1) ; CUU(2) := U1(2) ; MULASU2 U1 UOO U2 ;
         INVRSU2 UOO U2 ; CPOLVAL 1 UOO 2 MNN NV U2 2 ; MULASU2 UOO U2 U1 ;
         ENDLOOP ;
      D := SQR(ABS(REAL(UOO(2)))+ABS(IMAG(UOO(2)))) ;
      IF 1+D=1 ;
         STUNE := 2*ACOS(REAL(UOO(1))) ;
         NBN(1) := -2*(REAL(CUU(1))*REAL(CUU(2)) - IMAG(CUU(1))*IMAG(CUU(2))) ;
         NBN(2) := -2*(REAL(CUU(1))*IMAG(CUU(2)) + REAL(CUU(2))*IMAG(CUU(1))) ;
         NBN(3) := SQR(REAL(CUU(1)))+SQR(IMAG(CUU(1)))-
                   SQR(REAL(CUU(2)))-SQR(IMAG(CUU(2))) ;
         POLVAL 1 NBN 3 MAA NV NBAR 3 ;
         IF CONS(IMAG(UOO(1)))<0 ;
            NBN(1) := -NBN(1) ; NBN(2) := -NBN(2) ; NBN(3) := -NBN(3) ; ENDIF ;
         XX(1) := STUNE ; POLVAL 1 XX 1 MNN NV YY 1 ; D := ABS(STUNE - YY(1)) ;
         IF 1+D*D#1 ; WRITE 6
            ' --- WARNING in NORMSU2, spin tune is not an orbital invariant' ;
            ENDIF ;
         POLVAL 1 XX 1 MAA NV YY 1 ; STUNE := YY(1) ;
      ELSEIF TRUE ; WRITE 6 (' --- WARNING in NORMSU2, spin-orbit resonance. '&
         'NBAR and STUNE undefined') ;
         NBAR(1) := 0*DD(1) ; NBAR(2) := 0*DD(1) ; NBAR(3) := 0*DD(1) ;
         STUNE := 0*DD(1) ; ENDIF ;
      INVRSU2 U1 CUU ;
      CPOLVAL 1 U1 2 MAA NV CUU 2 ;
      CU(1) := REAL(CUU(1)) ; CU(2) := IMAG(CUU(1)) ;
      CU(3) := REAL(CUU(2)) ; CU(4) := IMAG(CUU(2)) ;
      UO(1) := REAL(UOO(1)) ; UO(2) := IMAG(UOO(1)) ;
      UO(3) := REAL(UOO(2)) ; UO(4) := IMAG(UOO(2)) ; ENDPROCEDURE ;

   PROCEDURE SO3_IN_SU2 A B KEY ;
     {Converts SO(3) matrix A into SU(2) matrix B. Value of
      KEY (KEY=0, or KEY#0) indicates choosen  SU(2) branch.}
      VARIABLE X 2*NM1 ; VARIABLE D 1 ; VARIABLE Y 2*NM1 ; VARIABLE C 1 ;
      VARIABLE I 2 ; VARIABLE F 1 ;
      FUNCTION COMSQRT X ; VARIABLE A NM1 ; VARIABLE B NM1 ; VARIABLE I 2 ;
         A := SQRT(SQR(REAL(X)) + SQR(IMAG(X))) ;
         IF ABS(CONS(REAL(X)))<ABS(CONS(IMAG(X))) ;
            B := 0.5 * ACOS(REAL(X) / A) ;
            IF CONS(IMAG(X))<0 ; B := -B ; ENDIF ;
         ELSEIF TRUE ;
            B := 0.5 * ASIN(IMAG(X) / A) ;
            IF CONS(REAL(X))<0 ; B := 0.5*PI-B ; ENDIF ; ENDIF ;
         IMUNIT I ; COMSQRT := SQRT(A)*(COS(B)+I*SIN(B)) ; ENDFUNCTION ;
      IMUNIT I ;
      X := 0.5 * (A(1,1) + A(2,2) + I * (A(2,1) - A(1, 2))) ;
      Y := 0.5 * (A(2,2) - A(1,1) - I * (A(2,1) + A(1, 2))) ;
      C := SQR(CONS(REAL(X))) + SQR(CONS(IMAG(X))) ;
      D := SQR(CONS(REAL(Y))) + SQR(CONS(IMAG(Y))) ;
      IF KEY=0 ; F :=  1 ; ELSEIF TRUE ; F := -1 ; ENDIF ;
      IF 1+C*C+D*D=1 ;
         WRITE 6 ' *** ERROR in SO3_IN_SU2' ; QUIT 0 ;
      ELSEIF C>D ;
         B(1) := F*COMSQRT(X) ; B(2) := -0.5*(A(1,3)+I*A(2,3))/B(1) ;
      ELSEIF TRUE ;
         B(2) := F*COMSQRT(Y) ; B(1) := -0.5*(A(1,3)+I*A(2,3))/B(2) ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE TSS ST NBAR KEY ;
     {Spin NBAR vector and spin tune MU on parameters and orbit.
      If KEY=0 original orbital variables are used, else if KEY#0
      orbital variables are transformed to the parameter dependent
      fixed point.}
      VARIABLE MN 2*NM1 TWOND ; VARIABLE MA 2*NM1 TWOND ; VARIABLE S1 2*NM1 ;
      VARIABLE UO NM1 4 ; VARIABLE CU NM1 4 ; VARIABLE I 1 ;
      VARIABLE EPS 1 ; VARIABLE US 2*NM1 2 ;
      VARIABLE XF NM1 NV ; VARIABLE MF NM1 NV ;
      EPS := 1E-7 ; DANF MAP MN MA 1 S1 EPS ; EPS := 0 ;
      LOOP I 1 TWOND ; EPS := EPS+ABS(IMAG(MN(I)))+ABS(IMAG(MA(I))) ; ENDLOOP ;
      IF EPS=0 ; EPS := 1E-7 ;
         SO3_IN_SU2 SPNR US 0 ; NORMSU2 US UO CU NBAR ST MN MA EPS ;
         IF KEY#0 ; FM MAP XF MF I ;
            IF I#0 ; WRITE 6
               ' *** ERROR in TSS, orbital map has no fixed point' ;
               QUIT 0 ; ENDIF ;
            LOOP I 1 TWOND ; XF(I) := DD(I)+XF(I) ; ENDLOOP ;
            LOOP I TWOND+1 NV ; XF(I) := DD(I) ; ENDLOOP ;
            CU(1) := ST ; CU(2) := NBAR(1) ; CU(3) := NBAR(2) ;
            CU(4) := NBAR(3) ; POLVAL 1 CU 4 XF NV UO 4 ;
            ST := UO(1) ; NBAR(1) := UO(2) ; NBAR(2) := UO(3) ;
            NBAR(3) := UO(4) ; ENDIF ;
      ELSEIF TRUE ;
         WRITE 6 ' --- WARNING in TSS, orbital normal form is not real' ;
         ST := 0*DD(1) ; NBAR(1) := 0*DD(1) ; NBAR(2) := 0*DD(1) ;
         NBAR(3) := 0*DD(1) ; ENDIF ;
      ST := ST/PI/2 ; ENDPROCEDURE ;

   PROCEDURE TSP ST NBAR KEY ;
     {Spin NBAR vector and spin tune MU on parameters only.
      If KEY=0 original orbital variables are used, else if KEY#0
      orbital variables are transformed to the parameter dependent
      fixed point.}
      VARIABLE B 2*NM1 2 ; VARIABLE BF 2*NM1 2 ; VARIABLE IU  2 ;
      VARIABLE U1 2*NMON(NOC,NP+1) 2 ; VARIABLE CU  2*NMON(NOC,NP+1) 2 ;
      VARIABLE K 2*NMON(NOC,NP+1) ; VARIABLE L 2*NMON(NOC,NP+1) ;
      VARIABLE D NMON(NOC,NP+1) ; VARIABLE TPI 1 ; VARIABLE I 1 ;
      VARIABLE J 1 ; VARIABLE A1 NMON(NOC,NP+1) 3 3 ;
      VARIABLE A2 NMON(NOC,NP+1) 3 3 ;
      VARIABLE XF NMON(NOC,NP+1) NV ; VARIABLE MF NM1 NV ; VARIABLE N1 NM1 3 ;
      VARIABLE T1 NM1 ;
      FUNCTION PARASU2 B ;
         VARIABLE D NM1 ; VARIABLE C NM1 ; VARIABLE I 1 ;
         D := B ; LOOP I 1 TWOND ; DAPLU D I 0.0 C ; D := C ; ENDLOOP ;
         PARASU2 := D ; ENDFUNCTION ;
      PROCEDURE CPARSU2 B ;
         VARIABLE D NMON(NOC,NP+1) ;
         D := SQR(REAL(B(1)))+SQR(REAL(B(2)))+SQR(IMAG(B(1)))+SQR(IMAG(B(2))) ;
         D := ISRT(D) ; B(1) := D*B(1) ; B(2) := D*B(2) ; ENDPROCEDURE ;
      IF KEY=0 ;
         TSS T1 N1 0 ; ST := PARASU2(T1) ;
         NBAR(1) := PARASU2(N1(1)) ; NBAR(2) := PARASU2(N1(2)) ;
         NBAR(3) := PARASU2(N1(3)) ;
      ELSEIF TRUE ;
         FM MAP XF MF J ;
         IF J#0 ; WRITE 6 ' *** ERROR in TSP, orbital map has no fixed point' ;
            QUIT 0 ; ENDIF ;
         LOOP I 1 TWOND ; XF(I) := DD(I)+XF(I) ; ENDLOOP ;
         LOOP I TWOND+1 NV ; XF(I) := DD(I) ; ENDLOOP ;
         SO3_IN_SU2 SPNR BF 0 ; CPOLVAL 1 BF 2 XF NV B 2 ; IMUNIT IU ;
         U1(1) := PARASU2(REAL(B(1))) + IU*PARASU2(IMAG(B(1))) ;
         U1(2) := PARASU2(REAL(B(2))) + IU*PARASU2(IMAG(B(2))) ;
         CPARSU2 U1 ; D := SQR(REAL(U1(2))) + SQR(IMAG(U1(2))) ;
         IF CONS(D)>0 ; D := SQRT(D) ; ENDIF ;
         IF 1+ABS(D)=1 ;
            L := U1(1) ; CU(1) := 1+IU*0 ; CU(2) := 0+IU*0 ;
         ELSEIF 1+ABS(ABS(CONS(REAL(U1(1))))-1)=1 ;
            WRITE 6 ' *** ERROR in TSP, multiple eigenvalues. Try to use TSS' ;
            QUIT 0 ;
         ELSEIF TRUE ;
            D := REAL(U1(1)) ; L := D+IU*SQRT(1-SQR(D)) ;
            K := U1(2)/(U1(1)-L) ; D := ISRT(1+SQR(REAL(K))+SQR(IMAG(K))) ;
            CU(1) := K*D ; CU(2) := D+0*IU ; ENDIF ;
         D := ISRT(SQR(REAL(L))+SQR(IMAG(L))) ; L := D*L ;
         ST := 2*ACOS(REAL(L)) ;
         NBAR(1) := -2*(REAL(CU(1))*REAL(CU(2))-IMAG(CU(1))*IMAG(CU(2))) ;
         NBAR(2) := -2*(REAL(CU(1))*IMAG(CU(2))+REAL(CU(2))*IMAG(CU(1))) ;
         NBAR(3) := SQR(REAL(CU(1)))+SQR(IMAG(CU(1)))-
                    SQR(REAL(CU(2)))-SQR(IMAG(CU(2))) ;
         IF CONS(IMAG(L))<0 ; NBAR(1) := -NBAR(1) ;
            NBAR(2) := -NBAR(2) ; NBAR(3) := -NBAR(3) ; ENDIF ;
         ST := ST/PI/2 ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE RCT X ;      {REORDER ARRAY AND VARIABLES FROM COSY TO EXPO THEORY}
      VARIABLE I 1 ; VARIABLE RCE 1 TWOND ; VARIABLE TMP NM1 TWOND ;
      LOOP I 1 ND ; TMP(I) := X(2*I-1) ; TMP(ND+I) := X(2*I) ; ENDLOOP ;
      LOOP I 1 ND ; RCE(2*I-1) := DA(I) ; RCE(2*I) := DA(ND+I) ; ENDLOOP ;
      POLVAL 2 TMP TWOND RCE TWOND X TWOND ; ENDPROCEDURE ;

   PROCEDURE RET X ;      {REORDER ARRAY AND VARIABLES FROM EXPO THEORY TO COSY}
      VARIABLE I 1 ; VARIABLE REC 1 TWOND ; VARIABLE TMP NM1 TWOND ;
      LOOP I 1 ND ; TMP(2*I-1) := X(I) ; TMP(2*I) := X(ND+I) ; ENDLOOP ;
      LOOP I 1 ND ; REC(I) := DA(2*I-1) ; REC(ND+I) := DA(2*I) ; ENDLOOP ;
      POLVAL 2 TMP TWOND REC TWOND X TWOND ; ENDPROCEDURE ;

   PROCEDURE RETF F ;               {REORDER VARIABLES FROM EXPO THEORY TO COSY}
      VARIABLE I 1 ; VARIABLE REC 1 TWOND ; VARIABLE X NM1 1 ;
      LOOP I 1 ND ; REC(I) := DA(2*I-1) ; REC(ND+I) := DA(2*I) ; ENDLOOP ;
      X(1) := F ; POLVAL 2 X 1 REC TWOND X 1 ; F := X(1) ; ENDPROCEDURE ;

   PROCEDURE CGF TY MAP CL F NG ;                {COMPUTE GENERATING FUNCTION F}
      VARIABLE SC1 MAX(100,2*NM1) TWOND ; VARIABLE SC2 MAX(100,2*NM1) TWOND ;
      VARIABLE SC3 2*NM1 TWOND ; VARIABLE I 1 ; VARIABLE J 1 ;
      VARIABLE IER 1 ; VARIABLE AL TWOND TWOND ; VARIABLE BL TWOND TWOND ;
      VARIABLE DL TWOND TWOND ; VARIABLE NOM 1 ; VARIABLE DUM NM1 ;
      VARIABLE M NM1 TWOND ; VARIABLE ML NV TWOND ; VARIABLE MLI NV TWOND ;
      PROCEDURE SETTYPE ; VARIABLE SSL TWOND TWOND ; VARIABLE J2N TWOND TWOND ;
         PROCEDURE SETS ; VARIABLE SS 1 TWOND TWOND ;
            PROCEDURE CONVS ;
               LOOP I 1 ND ; CL(I) := 0*DA(1) ; DL(ND+I) := CL(I) ; ENDLOOP ;
               IF     TY=1 ; LOOP I 1 ND ; CL(ND+I) := DA(I) ;
                  DL(I) := DA(I) ; ENDLOOP ;
               ELSEIF TY=2 ; LOOP I 1 ND ; CL(ND+I) := DA(ND+I) ;
                  DL(I) := DA(I) ; ENDLOOP ;
               ELSEIF TY=3 ; LOOP I 1 ND ; CL(ND+I) := DA(I) ;
                  DL(I) := DA(ND+I) ; ENDLOOP ;
               ELSEIF TY=4 ; LOOP I 1 ND ; CL(ND+I) := DA(ND+I) ;
                  DL(I) := DA(ND+I) ; ENDLOOP ; ENDIF ;
               POLVAL 2 CL TWOND ML TWOND SC1 TWOND ;
               LOOP I 1 TWOND ; SC1(I) := SC1(I)+DL(I) ; ENDLOOP ;
               MI SC1 SC2 TWOND IER NOC NV NM1 ; IF IER#0 ;
                  WRITE 6 '*** ERROR in TR, no gen. fct.' ; QUIT 0 ; ENDIF ;
               POLVAL 2 CL TWOND ML TWOND SC1 TWOND ;
               LOOP I 1 TWOND ; SC1(I) := SC1(I)-DL(I) ; ENDLOOP ;
               POLVAL 2 SC2 TWOND SC1 TWOND SC2 TWOND ;
               POLVAL 2 J2N TWOND SC2 TWOND SC2 TWOND ;
               LOOP I 1 TWOND ; SC2(I) := -SC2(I) ; ENDLOOP ; LOOP I 1 TWOND ;
                  LOOP J 1 TWOND ; SS(I,J) := CONS(DER(J,SC2(I))) ;
                  ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;
            IF TY=0 ; LOOP I 1 TWOND ; LOOP J 1 TWOND ; SS(I,J) := 0 ; ENDLOOP ;
               ENDLOOP ; ELSEIF (0<TY)*(TY<5) ; CONVS ; ELSEIF TRUE;
               WRITE 6 ' *** ERROR in TR, invalid typ' ; QUIT 0 ; ENDIF ;
            LOOP I 1 TWOND ; LOOP J 1 TWOND ; SSL(I) := SSL(I) + DA(J)*SS(I,J) ;
               ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;
         LOOP I 1 ND ; J2N(I) := DA(ND+I) ; J2N(ND+I) := -DA(I) ; ENDLOOP ;
         SETS ; LOOP I 1 TWOND ; AL(I) := -J2N(I) ; BL(I) := J2N(I) ; ENDLOOP ;
         POLVAL 2 J2N TWOND SSL TWOND SC1 TWOND ; LOOP I 1 TWOND ;
            CL(I) := (DA(I)+SC1(I))/2 ; DL(I) := (DA(I)-SC1(I))/2 ; ENDLOOP ;
         POLVAL 2 AL TWOND MLI TWOND AL TWOND ;
         POLVAL 2 CL TWOND MLI TWOND CL TWOND ; ENDPROCEDURE ;
     {PREPARATION}
      LOOP I 1 TWOND ; M(I) := MAP(I) ; ENDLOOP ; RCT M ;  {TRANSPOSE VARIABLES}
      NOM := NOC ; CO 1 ; LOOP I 1 TWOND ; ML(I) := M(I) ; ENDLOOP ;
      MI ML MLI TWOND IER NOC NV NM1 ; CO NOM ;
      IF IER#0 ; WRITE 6 ' *** ERROR in TR, no inverse' ; QUIT 0 ; ENDIF ;
     {MAIN PROCESSING}
      SETTYPE ; POLVAL 2 AL TWOND M TWOND SC1 TWOND ; LOOP I 1 TWOND ;
         SC1(I) := SC1(I) + BL(I) ; ENDLOOP ;
      POLVAL 2 CL TWOND M TWOND SC2 TWOND ; LOOP I 1 TWOND ;
         SC2(I) := SC2(I) + DL(I) ; ENDLOOP ; MI SC2 SC3 TWOND IER NOC NV NM1 ;
      IF IER#0 ; WRITE 6 '*** ERROR in TR, no gen. fct.' ; QUIT 0 ; ENDIF ;
      POLVAL 2 SC1 TWOND SC3 TWOND SC1 TWOND ; CO NOC+1 ; POTI SC1 TWOND F ;
     {POST PROCESSING. COMPUTES NG, TOO.}
      LOOP I 1 TWOND ; NG(I) := DER(I,F) ; ENDLOOP ; RETF F ; CO NOM ;
      LOOP I 1 ND ;
         DUM := NG(I) ; NG(I) := NG(ND+I) ; NG(ND+I) := -DUM ; ENDLOOP ;
      POLVAL 2 ML TWOND NG TWOND NG TWOND ;
      RET CL ; RET NG ;                               {TRANSPOSE VARIABLES BACK}
      ENDPROCEDURE ;

   PROCEDURE SYMP0 F G H ;                                 {SETUP G, H FOR SYMP}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE ID 1 ; VARIABLE JD 1 ;
      LOOP I 1 TWOND ; G(I) := DER(I,F) ; ENDLOOP ;
      LOOP ID 1 ND ; I := 2*ID-1 ; LOOP JD 1 ND ; J := 2*JD ;
         H(ID,JD) := DER(J,G(I)) ; ENDLOOP ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE SYMP AM AN G H TY IE ;  {SYMPLECTIFIES FINAL AM (INITIAL AN) TO AN}
      VARIABLE A 1 TWOND ; VARIABLE GI 1 ND ; VARIABLE D 1 ND ;
      VARIABLE ID 1 ; VARIABLE JD 1 ; VARIABLE I 1 ; VARIABLE F 1 ;
      VARIABLE GM NM1 TWOND ; VARIABLE GA 1 TWOND ; VARIABLE DIF 1 ;
      VARIABLE HM NM1 ND ND ; VARIABLE HA 1 ND ND ; VARIABLE IER 1 ;
      VARIABLE TRY 1 ; VARIABLE SCR NM1 ; VARIABLE K 1 ;
      PROCEDURE PLUA PIN K1 P ; P := PIN ;
         LOOP K K1 TWOND 2 ; DAPLU P K A(K) P ; ENDLOOP ; ENDPROCEDURE ;
      LOOP ID 1 ND ; F := 2*ID ; I := F-1 ;
         IF     TY=1 ; A(I) := AN(I) ; A(F) := AM(I) ; GI(ID) :=  AN(F) ;
         ELSEIF TY=2 ; A(I) := AN(I) ; A(F) := AM(F) ; GI(ID) :=  AN(F) ;
         ELSEIF TY=3 ; A(I) := AN(F) ; A(F) := AM(I) ; GI(ID) := -AN(I) ;
         ELSEIF TY=4 ; A(I) := AN(F) ; A(F) := AM(F) ; GI(ID) := -AN(I) ; ENDIF;
         PLUA G(I) 1 SCR ; GM(I) := SCR ; PLUA G(F) 1 SCR ; GM(F) := SCR ;
         LOOP JD 1 ND ; PLUA H(ID,JD) 1 SCR ; HM(ID,JD) := SCR ; ENDLOOP ;
         PLUA GM(I) 2 SCR ; GA(I) := CONS(SCR) ;
         D(ID) := GI(ID)-GA(I) ; ENDLOOP ; TRY := 0 ; IE := 0 ; DIF := 1 ;
      WHILE (DIF>10*DEPS)*(IE=0) ; TRY := TRY+1 ; IF TRY>100 ;
           {WRITE 6 ' --- WARNING in SYMP, no convergence in 100 steps' ;}
            LWNTR := LWNTR+1 ; IE := 1 ; ENDIF ;
         LOOP ID 1 ND ; LOOP JD 1 ND ; PLUA HM(ID,JD) 2 SCR ;
            HA(ID,JD) := CONS(SCR) ; ENDLOOP ; ENDLOOP ; LINV HA HA ND ND IER ;
         IF IER#0 ; WRITE 6 ' --- WARNING in SYMP, no inverse' ; ENDIF ;
         LOOP ID 1 ND ; F := 2*ID ;
            LOOP JD 1 ND ; A(F) := A(F)+HA(ID,JD)*D(JD) ; ENDLOOP ; ENDLOOP ;
         DIF := 0 ; LOOP ID 1 ND ; I := 2*ID-1 ;
            PLUA GM(I) 2 SCR ; GA(I) := CONS(SCR) ;
            D(ID) := GI(ID)-GA(I) ; DIF := DIF+ABS(D(ID)) ; ENDLOOP ; ENDWHILE ;
      LOOP ID 1 ND ; F := 2*ID ; I := F-1 ;
         PLUA GM(F) 2 SCR ; GA(F) := CONS(SCR) ;
         IF     TY=1 ; AN(I) :=  A(F) ; AN(F) := -GA(F) ;
         ELSEIF TY=2 ; AN(I) := GA(F) ; AN(F) :=   A(F) ;
         ELSEIF TY=3 ; AN(I) :=  A(F) ; AN(F) := -GA(F) ;
         ELSEIF TY=4 ; AN(I) := GA(F) ; AN(F) :=   A(F) ; ENDIF ; ENDLOOP ;
      ENDPROCEDURE ;

   {!!! moved these 2 from below (**) @AA !!! }
   PROCEDURE TRSC E ; E := ESC ; ENDPROCEDURE ;     {TR SYMPLECTIFICATION ERROR}
   PROCEDURE TRNC E ; E := ENC ; ENDPROCEDURE ;    {TR SPIN NORMALIZATION ERROR}

   PROCEDURE TR N NP IID1 IID2 D1 D2 TY NF IU ;                    {TRACKS RAYS}
      VARIABLE PLOT 10000 ; VARIABLE IS 1 ; VARIABLE IMP 1 ; VARIABLE TYS 1 ;
      VARIABLE AN 1 TWOND ; VARIABLE AM 1 TWOND ; VARIABLE DUM MAX(NRAY,NM1) ;
      VARIABLE G NM1 TWOND ; VARIABLE H NM1 ND ND ; VARIABLE F NM1 ;
      VARIABLE IE 1 ; VARIABLE NOM 1 ; VARIABLE ML NV+1 TWOND ; VARIABLE LIM 1 ;
      VARIABLE MLI NV+1 TWOND ; VARIABLE NN 2*NM1 TWOND ; VARIABLE IT 1 ;
      VARIABLE TMAP 2*NM1 TWOND+9 ; VARIABLE AL 1 TWOND TWOND ;
      VARIABLE DD1 1 ; VARIABLE DD2 1 ; VARIABLE ID1 1 ; VARIABLE ID2 1 ;
      VARIABLE PART NRAY TWOND+MAX(9,1+NCCT) ; VARIABLE PARI NRAY TWOND ;
      VARIABLE ERAY NRAY TWOND ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE IC 1 ;
      VARIABLE XP NRAY ; VARIABLE YP NRAY ; VARIABLE X 1 ; VARIABLE Y 1 ;
      VARIABLE NG 2*NM1 TWOND ; VARIABLE CL TWOND TWOND ; VARIABLE DFCT 1 ;
      VARIABLE KK NRAY TWOND ; VARIABLE TMP NRAY TWOND ; VARIABLE SCR 1 ;
      VARIABLE M1 NRAY TWOND ; VARIABLE M2 NRAY TWOND ; VARIABLE II 1 ;
      VARIABLE TSPI NRAY 3 ; VARIABLE TSSC NRAY 3 ;
      VARIABLE NR 1 ; VARIABLE NS 1 ; VARIABLE STR 120 ; VARIABLE DERR 1 ;
      VARIABLE LPL 1 ; VARIABLE LPLH 1 ; VARIABLE APART NRAY 2*MAX(1,NCT) ;
      VARIABLE CLIM 1 ; VARIABLE CLIM0 1 ;
      VARIABLE PERCENT 1; { *** for printing out progress @AA *** }
      PROCEDURE PREAP ;                       {PREPARATION FOR AP APERTURE CUTS}
         PROCEDURE APCOPY IB IE ;       {POLVAL operation for every-LPL AP maps}
            VARIABLE CMAP NM1 LPL ; VARIABLE CPART NRAY LPL ; VARIABLE K 1 ;
            VARIABLE NK 1 ; NK := IE-IB+1 ;
            LOOP K 1 NK ; CMAP(K) := MCT(IB-1+K) ; ENDLOOP ;
            POLVAL 1 CMAP NK PART TWOND CPART NK ;
            LOOP K 1 NK ; APART(IB-1+K) := CPART(K) ; ENDLOOP ; ENDPROCEDURE ;
         IC := MIN(NCT,LPLH) ; POLVAL 1 MCT 2*IC PART TWOND APART 2*IC ;
         IC := LPLH ; WHILE NCT>IC ; APCOPY 2*IC+1 2*MIN(NCT,IC+LPLH) ;
            IC := IC+LPLH ; ENDWHILE ; ENDPROCEDURE ;
      PROCEDURE CUT ; {APERTURE CUT. USE PART(TWOND+1)-(TWOND+NCCT) TEMPORARILY}
         PROCEDURE CUTCND LCND X Y XC YC CADD ;         {EVALUATE CUT CONDITION}
            IC := IC+1 ; IF TWOND=2 ; PART(IC) := SQR(X/XC)+CADD ;
            ELSEIF TWOND>2 ;
               IF LCND=1 ;                                        {ELLIPTIC CUT}
                  PART(IC) := SQR(X/XC)+SQR(Y/YC)+CADD ;
               ELSEIF LCND=2 ;                                 {RECTANGULAR CUT}
                  PART(IC) := SQR(X/XC)+CADD ; IC := IC+1 ;
                  PART(IC) := SQR(Y/YC)+CADD ; ENDIF ; ENDIF ; ENDPROCEDURE ;
         IC := TWOND+1 ; PART(IC) := REMAIN ; CLIM := 1 ;
         LOOP I 1 TWOND ; CLIM := MAX(CLIM,CONS(PART(I))) ; ENDLOOP ;
         CLIM := MIN(CLIM,CLIM0)+1 ;            {AN ARTIFICIAL VEZERO THRESHOLD}
         IF NCT>0 ; LOOP I 1 NCT ;                                     {AP CUTS}
            CUTCND LCT(I) APART(2*I-1) APART(2*I) XCT(1,I) XCT(2,I) CLIM-1 ;
            ENDLOOP ;
         ELSEIF LO(1) ;                                               {TRAP CUT}
            CUTCND ABS(LCUT) PART(1) PART(3) XCUT(1) XCUT(2) CLIM-1 ; ENDIF ;
         VEZERO PART IC CLIM ;                     {IF >CLIM, CUT THE PARTICLE}
         REMOVE := REMOVE+LTRI*(REMAIN-PART(TWOND+1)) ;  {STORE THE CUT HISTORY}
         REMAIN := PART(TWOND+1) ; {UPDATE THE SURVIVAL RECORD}   ENDPROCEDURE ;
      PROCEDURE WTRPRAY IT;
       IF IT=0 ; NR := LENGTH(PART(1)) ; IF NR=1 ; NR := 0 ; ENDIF ;
          WRITE LTRPRAYU '# number of rays:'&SF(NR,'(I8)') ;
          IF NR>0 ; STR := '# iteration   ray    X              A' ;
             IF TWOND>2 ; STR := STR&'              Y              B' ;
                ENDIF ;
             IF TWOND>4 ; STR := STR&'              T              D' ;
                ENDIF ;
             IF TWOND>6 ; STR := STR&'              G              Z' ;
                ENDIF ;
             WRITE LTRPRAYU STR ;
          ENDIF ;
       ELSEIF LO(1) ; WRITE LTRPRAYU '' ; ENDIF ;
       LOOP J 1 NR ; STR := SF(IT,'(I10)')&' '&SF(J-1,'(I6)') ;
          LOOP I 1 TWOND ; STR := STR&SF((PART(I)|J),'(E15.7)') ; ENDLOOP ;
          WRITE LTRPRAYU STR ; ENDLOOP ;
      ENDPROCEDURE; {WTRPRAY @AA}
      PROCEDURE WTRPSPI IT;
        IF IT=0 ; NS := LENGTH(TSPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;
          WRITE LTRPSPIU '# number of spin vectors:'&SF(NS,'(I8)') ;
          IF NS>0 ; WRITE LTRPSPIU ('# iteration vector   S_X'&
                          '            S_Y            S_Z') ; ENDIF ;
        ELSEIF LO(1) ; WRITE LTRPSPIU '' ; ENDIF ;
        LOOP J 1 NS ; STR := SF(IT,'(I10)')&' '&SF(J-1,'(I6)') ;
          LOOP I 1 3 ; STR := STR&SF((TSPI(I)|J),'(E15.7)') ; ENDLOOP ;
          WRITE LTRPSPIU STR ; ENDLOOP ;
      ENDPROCEDURE; {WTRPSPI @AA}
      PROCEDURE OUTPIC IT ;
         IF NF=1 ; POLVAL 2 NN TWOND PART TWOND PARI TWOND ;
                        XP := PARI(ID1) ; YP := PARI(ID2) ;
          ELSEIF TRUE ; XP := PART(ID1) ; YP := PART(ID2) ; ENDIF ;
         IF IID1<0 ; XP := TSPI(-IID1) ; ENDIF ;
         IF IID2<0 ; YP := TSPI(-IID2) ; ENDIF ;

         { LOOP J 1 NRAY ; X := XP|J ; Y := YP|J ; }
         {    IF (ABS(X)<DD1)*(ABS(Y)<DD2)*((REMAIN|J)=1) ; }
              { IF COLOR IS PREFERRED, ADD THE LINE.  GRCOLR RCOL|J PLOT ; }
               { GRDOT X Y 0 PLOT ; ENDIF ; ENDLOOP ;  }{*** REMOVED PLOTTING B/C I PLOT IN PYTHON ANYWAY, @AA}
         IF (LTRPRAY+LTRPSPI)>0 ;                            {SEE PRAY AND PSPI}
            IF LTRPRAY=1 ; WTRPRAY IT; ENDIF; {@AA}
            IF LTRPSPI=1 ; WTRPSPI IT; ENDIF ; {@AA}
         ENDIF;
      ENDPROCEDURE ;
   {* PREPARATION}
      LIM := 1000*MAX(D1,D2) ; DERR := 1E5 ;
      LPL := 16 ; {parameter LPL for POLVAL in dafox.f} LPLH := INT(LPL/2) ;
      NOM := NOC ; IMP := TWOND ; ESC := 0 ; ENC := 0 ; LWNTR := 0 ;
      ID1 := IID1 ; ID2 := IID2 ; CLEAR PLOT ; GRCOLR 1 PLOT ; TYS := TY ;
     {PREPARE SPIN TRACKING}
      IF (ID1<0)+(ID2<0) ;
         IF NSPN#NRAY ; WRITE 6 (' *** ERROR in TR, the number of SSR''s '&
            'disagrees with SR''s.') ; QUIT 0 ;
         ELSEIF NF#0 ; WRITE 6 (' *** ERROR in TR, spin tracking is not '&
            'supported for NF.') ; QUIT 0 ; ENDIF ;
         IS := 1 ; IMP := TWOND+9 ;
         IF ID1<0 ; ID1 := TWOND-ID1 ; ENDIF ;
         IF ID2<0 ; ID2 := TWOND-ID2 ; ENDIF ;
         LOOP I 1 3 ; TSPI(I) := SPI(I) ;
            LOOP J 1 3 ; TMAP(TWOND+3*(I-1)+J) := SPNR(I,J)+0*DD(1) ; ENDLOOP ;
            ENDLOOP ; ENDIF ;
     {PREPARE PLOT BOX}
      LOOP I 1 IMP ; PART(I) := 0 ; ENDLOOP ;
      IF NF=1 ; DANF MAP TMAP NN 1 DUM 1E-12 ; CO 1 ;
         IF TYPE(NN(1))#TYPE(DD(1)) ;
            LOOP I 1 TWOND ; NN(I) := XX(I) ; ENDLOOP ; ENDIF ;
         PART(ID1) := D1 ; PART(ID2) := D2 ;
         POLVAL 2 NN TWOND PART TWOND PARI TWOND ;
         I := SQR(PARI(ID1))+SQR(PARI(ID2)) ;
         PART(ID2) := -D2 ; POLVAL -2 NN TWOND PART TWOND PARI TWOND ;
         J := SQR(PARI(ID1))+SQR(PARI(ID2)) ;
         DD1 := SQRT(MAX(I,J)) ; DD2 := DD1 ; CO NOM ;
         GRMOVE -DD1*1.5 -DD2 0 PLOT ; GRMOVE DD1*1.5 DD2 0 PLOT ;
       ELSEIF TRUE ; DD1 := D1 ; DD2 := D2 ;
         GRMOVE -D1 -D2 0 PLOT ; GRMOVE D1 D2 0 PLOT ; ENDIF ;
     {PREPARE MAPS}
      LOOP I 1 TWOND ; TMAP(I) := MAP(I) ; ENDLOOP ;
      IF (TY=-12)+(TY=-13) ; TYS := TY+10 ;
         CO 1 ; I := -1 ; MGF MAP F I J ; GFM ML F I ;
         MI ML MLI TWOND IE NOC NV NM1 ; CO NOM ;
         IF IE#0 ; WRITE 6 ' *** ERROR in TR, no inverse' ; QUIT 0 ; ENDIF ;
         LOOP I 1 TWOND ; TMAP(I) := 0 ;
            LOOP J 1 TWOND ; AL(I,J) := COEF(ML(I),J) ;
               TMAP(I) := TMAP(I)+COEF(MLI(I),J)*MAP(J) ; ENDLOOP ; ENDLOOP ;
       ENDIF ;
     {PREPARE SYMPLECTIFICATION - USE OF GENERATING FUNCTION}
      IF TY>-1 ; {TY POSITIVE OR 0}                      {FIXED POINT ITERATION}
         CGF TY TMAP CL F NG ;
         CO 1 ; LOOP I 1 TWOND ; ML(I) := TMAP(I) ; ENDLOOP ; CO NOM ;
         POLVAL 103 CL TWOND AN TWOND AN TWOND ;
         POLVAL 104 NG TWOND AN TWOND AN TWOND ;
       ELSEIF TY#-21 ; {TY NEGATIVE, NOT -21}                    {NEWTON METHOD}
         MGF TMAP F ABS(TYS) IE ;
         IF IE#0 ; WRITE 6 ' *** ERROR in TR, no generating function.' ;
            QUIT 0 ; ENDIF ;
         SYMP0 F G H ;
       ENDIF ;
     {INITIALIZATION}
      LOOP I 1 TWOND ; PART(I) := RAY(I) ; PARI(I) := PART(I) ; ENDLOOP ;
      LOOP I TWOND+1 IMP ; PART(I) := 0*PART(1) ; ENDLOOP ;
      POLVAL 105 TMAP IMP PART TWOND PART IMP ;      {TREES ONLY, NO EVALUATION}
      IF LTRR=0 ; LTRI := 0 ;
         IF (LCUT>0)*(NCT=0) ; CUT ; ENDIF ;
         IF NP>0 ; OUTPIC 0 ; ENDIF ;
      ELSEIF LO(1); NS := LENGTH(TSPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;
      ENDIF ;
      IF (LCUT#0)+(NCT>0) ; CLIM0 := 0 ;
         LOOP I 1 TWOND ; CLIM0 := MAX(CLIM0,CONS(PART(I))) ; ENDLOOP ;
         CLIM0 := CLIM0+10*DERR ; ENDIF ;
   {* MAIN TRACKING ITERATION LOOP}
      LOOP IT 1 N ; LTRI := LTRI+1 ; { WRITE 6 'ITERATION: '&ST(IT); }
         IF (LCUT=0)*(NCT=0) ; VEZERO PART TWOND LIM ;
            ELSEIF NCT>0 ; PREAP ; ENDIF ;
         LOOP I 1 TWOND ; PARI(I) := PART(I) ; ENDLOOP ;
         POLVAL -5 TMAP IMP PART TWOND PART IMP ;                 {PUSHING RAYS}
         LOOP I 1 TWOND ; ERAY(I) := PART(I) ; ENDLOOP ;
        {SYMPLECTIFICATION}
         IF TY>-1 ; {TY POSITIVE OR 0}                   {FIXED POINT ITERATION}
            POLVAL 2 ML TWOND PARI TWOND KK TWOND ;
            LOOP I 1 TWOND ; M2(I) := PART(I)-KK(I) ; ENDLOOP ;
            II := 0 ; DFCT := 1 ;
            WHILE (DFCT>10*DEPS)*(DFCT<DERR)*(II<101) ; II := II+1 ;
               POLVAL -3 CL TWOND M2 TWOND TMP TWOND ;
               LOOP I 1 TWOND ; TMP(I) := TMP(I)+PARI(I) ; ENDLOOP ;
               POLVAL -4 NG TWOND TMP TWOND M1 TWOND ; DFCT := 0 ;
               LOOP I 1 TWOND ; DFCT := MAX(DFCT,CONS(M1(I)-M2(I))) ;
                  M2(I) := M1(I) ; ENDLOOP ;    ENDWHILE ;
            IF DFCT>100*DEPS ; LWNTR := LWNTR+1 ;
              {WRITE 6 ' --- WARNING in TR, not converged: '&S(DFCT) ;} ENDIF ;
            LOOP I 1 TWOND ; PART(I) := M2(I)+KK(I) ; ENDLOOP ;
          ELSEIF TY#-21 ; {TY NEGATIVE, NOT -21}                 {NEWTON METHOD}
            LOOP J 2 NRAY ;
               LOOP I 1 TWOND ; AM(I) := PARI(I)|J ; AN(I) := AM(I) ;
                  ENDLOOP ;
               SYMP AM AN G H ABS(TYS) IE ;
               IF IE=0 ;
                  LOOP I 1 TWOND ; DUM := PART(I) ; VELSET DUM J AN(I) ;
                     PART(I) := DUM ; ENDLOOP ; ENDIF ;    ENDLOOP ;
            IF TY>-5 ; LOOP I 1 TWOND ; PARI(I) := PART(I) ; ENDLOOP ;
             ELSEIF (TY=-12)+(TY=-13) ;
               LOOP I 1 TWOND ; PARI(I) := 0 ;
                  LOOP J 1 TWOND ;
                     PARI(I) := PARI(I)+AL(I,J)*PART(J) ; ENDLOOP ; ENDLOOP ;
               LOOP I 1 TWOND ; PART(I) := PARI(I) ; ENDLOOP ; ENDIF ;
          ENDIF ;
        {TRANSFORMATION OF SPIN VECTORS}
         IF IS=1 ; DUM := 0 ;
            LOOP I 1 3 ; TSSC(I) := 0 ;
               LOOP J 1 3 ; TSSC(I) := TSSC(I)+PART(TWOND+3*(I-1)+J)*TSPI(J) ;
                  ENDLOOP ; DUM := DUM+SQR(TSSC(I)) ; ENDLOOP ;
            DUM := SQRT(DUM) ; VELSET DUM 1 1 ; ENC := ABS(DUM-1) ;
            LOOP I 1 3 ; TSPI(I) := TSSC(I)/DUM ; ENDLOOP ; ENDIF ;
        {OUTPUT OF PICTURE}
         LOOP I 1 TWOND ; ESC := ESC+ABS(PART(I)-ERAY(I)) ; ENDLOOP ;
         IF (LCUT#0)+(NCT>0) ; CUT ; ENDIF ;
         IF MOD(IT,ABS(NP))=0 ; OUTPIC IT ; ENDIF ;
         { *** PRINT PROGRESS @AA *** }
         PERCENT := 100*IT/N;
         IF MOD(PERCENT, 10)=0;
           WRITE 6 'Complete: '&SF(PERCENT, '(I4)')&' %';
           ENDIF ;
         { *** }
      ENDLOOP ;                                      {END OF MAIN TRACKING LOOP}
   {* POST PROCESSING}
      ESC := ESC/N/(NRAY-1)/TWOND ; ENC := ENC/N/(NRAY-1) ;
      IF LTRR>0 ;
         LOOP I 1 TWOND ; RAY(I) := PART(I) ; ENDLOOP ;
         LOOP I 1 3 ; SPI(I) := TSPI(I) ; ENDLOOP ; ENDIF ;
     {FRAME FOR PICTURE} { !!!!!!! I DON'T DRAW ANYTHING HERE ANYWAY @AA !!!!!!! }
      { GRCOLR 3 PLOT ; }
      { GRMOVE DD1*37/48 DD2/75 0 PLOT ; GRCHAR SF(DD1,'(G9.3)') PLOT ; }
      { GRMOVE DD1/50 DD2*11/12 0 PLOT ; GRCHAR SF(DD2,'(G9.3)') PLOT ; }
      { GRMOVE  DD1*2/3   0    0 PLOT ; GRDRAW  DD1   0 0 PLOT ; }
      { GRMOVE -DD1*2/3   0    0 PLOT ; GRDRAW -DD1   0 0 PLOT ; }
      { GRMOVE    0    DD2*2/3 0 PLOT ; GRDRAW   0  DD2 0 PLOT ; }
      { GRMOVE    0   -DD2*2/3 0 PLOT ; GRDRAW   0 -DD2 0 PLOT ; }
      { IF LTR=1 ; LTR := 0 ; GRCOLR 1 PLOT ; }
      {    GRMOVE -DD1 -DD2 0 PLOT ; GRCHAR TRTST PLOT ; ENDIF ; WRITE IU PLOT ; }
      IF (LTRPRAY+LTRPSPI)>0 ; LTRPRAY := 0 ; LTRPSPI := 0 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE TRT LIN ; LTR := 1 ; TRTST := LIN ; ENDPROCEDURE ;       {TR TITLE}

   PROCEDURE TRAP X Y I ;                   {TR APERTURE CUT PARAMETERS SETTING}
     {MODE I.  0: NO CUT,  1: ELLIPTIC CUT,  2: RECTANGULAR CUT
      IF NEGATIVE, NO CUT TO THE INITIAL PARTICLES.}
      XCUT(1) := ABS(X) ; XCUT(2) := ABS(Y) ; LCUT := I ; ENDPROCEDURE ;

   PROCEDURE AP X Y I ;                              {PARTICLE CUTTING APERTURE}
     {MODE I.  1: ELLIPTIC CUT,  2: RECTANGULAR CUT,  ELSE: IGNORED
      UM RESETS THE PREVIOUS AP CALLS. WITH ACTIVE AP CALLS, TRAP IS IGNORED.}
      IF (I=1)+(I=2) ; NCT := NCT+1 ; NCCT := NCCT+I ; LCT(NCT) := I ;
         XCT(1,NCT) := ABS(X) ; XCT(2,NCT) := ABS(Y) ;
         MCT(2*NCT-1) := MAP(1) ; MCT(2*NCT) := MAP(3) ;
         DR := ABS(Y) ; LOCSET 0 0 0 0 0 0 ; UPDATE 0 0 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE TRAPN N ;          {NUMBER OF SURVIVED PARTICLES VIA TR UNDER TRAP}
      N := ABS(REMAIN)-1 ;       {THE COUNTING EXCLUDES THE REFERENCE PARTICLE.}
      ENDPROCEDURE ;

   PROCEDURE TRAPHIST FN LT ;                 {OUTPUT PARTICLE SURVIVAL HISTORY}
     {USE REMOVE, THE PARTICLE REMOVAL STEP INFORMATION BY TRAP/AP IN TR.
      IF LT IS LARGER THAN THE LATEST TR STEP NUMBER APPEARING IN REMOVE,
      A LINE IS APPENDED. TYPICALLY PASS LTRI FOR LT.}
      VARIABLE HIST LENGTH(REMAIN) ; VARIABLE L 1 ;
      PROCEDURE PROCESS ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
         VARIABLE DATA 1 L+2 ; LOOP J 1 L+2 ; DATA(J) := 0 ; ENDLOOP ;
         LOOP I 2 NRAY ; J := (-HIST)|I ; DATA(J+2) := DATA(J+2)+1 ; ENDLOOP ;
         OPENF 77 FN 'UNKNOWN' ; K := NRAY-1 ;
         WRITE 77 ('#     step   number of survived particles    '&
                   '(the intial number at step=-1)') ;
         WRITE 77 SF(-1,'(I10)')&' '&SF(K,'(I10)') ;
         LOOP J 2 L+2 ; IF DATA(J)>0 ; K := K-DATA(J) ;
            WRITE 77 SF(J-2,'(I10)')&' '&SF(K,'(I10)') ; ENDIF ; ENDLOOP ;
         IF L<LT ; WRITE 77 SF(LTRI,'(I10)')&' '&SF(K,'(I10)') ; ENDIF ;
         CLOSEF 77 ; ENDPROCEDURE ;
      IF NRAY<2 ; WRITE 6 ' *** ERROR in TRAPHIST, no rays.' ; QUIT 0 ; ENDIF ;
      HIST := REMAIN-REMOVE ; L := VMAX(-HIST) ; PROCESS ; ENDPROCEDURE ;

   PROCEDURE TRAYPAC ;         {PACK RAYS TO KEEP ONLY SURVIVED PARTICLE VIA TR}
      VARIABLE L0 1 ; VARIABLE L 1 ; VARIABLE SPIN 1 ;
      VARIABLE PART NRAY TWOND ; VARIABLE TSPI NRAY 3 ; VARIABLE REMAIN0 NRAY ;
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      L0 := LENGTH(RAY(1)) ; IF L0#NRAY ; WRITE 6
            ' *** ERROR in TRAYPAC, RAY length wrong.' ; QUIT 0 ; ENDIF ;
      L := ABS(REMAIN) ;
      IF L<NRAY ; REMAIN0 := REMAIN ; REMAIN := 1 ;
         LOOP I 1 TWOND ; PART(I) := RAY(I) ; RAY(I) := PART(I)|1 ; ENDLOOP ;
         SPIN := LO(0) ; IF LENGTH(SPI(1))=L0 ; SPIN := LO(1) ; ENDIF ;
         IF SPIN ; LOOP I 1 3 ; TSPI(I) := SPI(I) ; SPI(I) := TSPI(I)|1 ;
                      ENDLOOP ; ENDIF;
         K := 1 ;
         LOOP J 2 L0 ; IF (REMAIN0|J)=1 ; K := K+1 ; REMAIN := REMAIN&1 ;
               LOOP I 1 TWOND ; RAY(I) := RAY(I)&(PART(I)|J) ; ENDLOOP ;
               IF SPIN ; LOOP I 1 3 ; SPI(I) := SPI(I)&(TSPI(I)|J) ; ENDLOOP ;
                  ENDIF ;   ENDIF ; ENDLOOP ;   ENDIF ;
      IF K#L ; WRITE 6 ' *** ERROR in TRAYPAC, REMAIN length wrong.' ; QUIT 0 ;
         ENDIF;
      NRAY := L ; IF SPIN ; NSPN := L ; ENDIF ; REMOVE := 0*REMAIN ;
      ENDPROCEDURE ;

   PROCEDURE TRR L ;                                    {TR RESUME FLAG SETTING}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before TRR' ; QUIT 0 ; ENDIF ;
      IF (LTRR=0)+(L=0) ; LTRI := 0 ; ENDIF ; LTRR := L ; ENDPROCEDURE ;

   PROCEDURE TRPRAY IU ;            {TRPRAY OUTPUT FLAG AND UNIT NUMBER SETTING}
      LTRPRAY := 1 ; LTRPRAYU := IU ;
      IF LTRPSPI=1 ; IF LTRPRAYU=LTRPSPIU ; WRITE 6
         ' *** ERROR in TRPRAY, avoid the same unit number with TRPSPI''s' ;
         QUIT 0 ; ENDIF ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE TRPSPI IU ;            {TRPSPI OUTPUT FLAG AND UNIT NUMBER SETTING}
      LTRPSPI := 1 ; LTRPSPIU := IU ;
      IF LTRPRAY=1 ; IF LTRPRAYU=LTRPSPIU ; WRITE 6
         ' *** ERROR in TRPSPI, avoid the same unit number with TRPRAY''s' ;
         QUIT 0 ; ENDIF ; ENDIF ; ENDPROCEDURE ;

     { !!! moved these 2 above (**) PROCEDURE TR @AA !!! }
   { PROCEDURE TRSC E ; E := ESC ; ENDPROCEDURE ; }     {TR SYMPLECTIFICATION ERROR}
   { PROCEDURE TRNC E ; E := ENC ; ENDPROCEDURE ;  }   {TR SPIN NORMALIZATION ERROR}

   PROCEDURE SYSCFL IU AA FF LL INOR ;       {SYMPLECTIC SCALING REPRESENTATION}
      VARIABLE MIS NM1 ; VARIABLE NOR 1 ; VARIABLE J 1 ; VARIABLE LIN 80 ;
     {READ REFERENCE PARAMETERS}
      READ IU LIN ; J := R(LIN,8,10) ; READ IU LIN ; AA(4) := R(LIN,8,30) ;
      AA(5) := R(LIN,31,53) ; AA(6) := R(LIN,54,76) ;
      IF INOR<0 ; NOR := J+1 ; ELSEIF TRUE ; NOR := INOR ; ENDIF ;
      IF J+1<NOR ; WRITE 6 ' --- WARNING in SYSCFL, order not saved' ;
      NOR := J+1 ; ENDIF ; AA(8) := NOR ; READ IU LIN ; J := R(LIN,13,15) ;
      READ IU LIN ; AA(1) := R(LIN,8,30) ; AA(2) := R(LIN,31,53) ;
      AA(3) := R(LIN,54,76) ; IF J<0 ; AA(1) := 0 ; ENDIF ;
      READ IU LIN ; READ IU LIN ; AA(7) := R(LIN,35,36) ; READ IU LIN ;
     {1:L, 2:B, 3:D, 4:E, 5:M, 6:Z, 7:TYPE OF GF, 8:ORDER}
     {READ SCALING REPRESENTATION}
      CO NOC+1 ; LOOP J 0 NOR ; DAREA IU MIS TWOND ; FF(J+1) := MIS ;
      DAREA IU MIS TWOND ; LL(J+1) := MIS ; ENDLOOP ; CO NOC-1 ;
      AA(9) := 0 ; AA(10) := 0 ; LOOP J NOR+2 10 ; LL(J) := 0*DD(1) ;
      FF(J) := 0*DD(1) ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE FC2 POL IEE FILE ;        {READS SYMPLECTIC SCALING REPRESENTATION}
      VARIABLE J 1 ; VARIABLE AA 1 10 ; VARIABLE FF NM1 10 ;
      VARIABLE LL NM1 10 ; OPENF 99 FILE 'OLD' ; SYSCFL 99 AA FF LL -1 ;
      CLOSEF 99 ; CO NOC+1 ; LOOP J 1 10 ; GFF2(IEE,POL,J) := FF(J) ;
      LFF2(IEE,POL,J) := LL(J) ; DATFF2(IEE,POL,J) := AA(J) ; ENDLOOP ;
      CO NOC-1 ; ENDPROCEDURE ;

   PROCEDURE FD2 ; VARIABLE I 1 ;       {SETS DEFAULT SYMPLECTIC SCALING ARRAYS}
      VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE AA 1 10 ;
      VARIABLE FF NM1 10 ; VARIABLE LL NM1 10 ;
      CO NOC+1 ; OPENF 99 'SYSCA.DAT' 'OLD' ;
      LOOP I 1 6 ; LOOP J 1 2 ; SYSCFL 99 AA FF LL -1 ;
      LOOP K 1 10 ; GFF2(J,I,K) := FF(K) ;
      LFF2(J,I,K) := LL(K) ; DATFF2(J,I,K) := AA(K) ; ENDLOOP ;
      ENDLOOP ; ENDLOOP ; CLOSEF 99 ; CO NOC-1 ; ENDPROCEDURE ;

   PROCEDURE FR I ;                                          {FRINGE FIELD MODE}
      IF LOV=0 ; WRITE 6 ' *** ERROR, call OV before FR' ; QUIT 0 ; ENDIF ;
      LFR := I ; IF (I<3)*(I>0)*(LFR2=0) ; FD2 ; LFR2 := 1 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE KC I ; LKC := I ; IF I=1 ;  {KINEMATIC CORRECTIN MODE. 0:ON, 1:OFF}
      WRITE 6 ' --- WARNING in KC, effects only in ODE and DLACT' ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE WAS I ;      {WEDGE COMPUTATION MODE. 0:ON, 1:OFF. CALL BEFORE OV.}
      LWA := -I ; ENDPROCEDURE ;

   FUNCTION LEN2 X Y ; VARIABLE XY2 NM1+1 ; VARIABLE LENC 1 ; VARIABLE TYP 1 ;
      XY2 := SQR(X)+SQR(Y) ; LENC := SQRT(CONS(XY2)) ; TYP := TYPE(XY2) ;
      IF TYP=TYPE(1) ; LEN2 := LENC ;
      ELSEIF TYP=TYPE(DA(1)) ; IF LENC<1.D-8 ; LEN2 := LENC+0*DA(1) ;
         ELSEIF LO(1) ; LEN2 := SQRT(XY2) ; ENDIF ;
      ELSEIF LO(1) ; WRITE 6 ' *** ERROR in LEN2, only RE or DA supported.' ;
         QUIT 0 ; ENDIF ; ENDFUNCTION ;

   PROCEDURE NORMAL X Z X0 Z0 X1 Z1 DIS XS ZS ;
     {DISTANCE DIS OF P=(X,Z) TO THE LINE P0=(X0,Z0) TO P1=(X1,Z1) INTERSECTING
      AT (XS,ZS). THE SIGN OF DIS IS THAT OF THE CROSS PRODUCT (P1-P0)X(P-P0).}
      VARIABLE NX 1 ; VARIABLE NZ 1 ; VARIABLE SCR 1 ;
      NX := -(Z1-Z0) ; NZ := X1-X0 ; SCR := SQRT(SQR(NX)+SQR(NZ)) ;
      NX := NX/SCR ; NZ := NZ/SCR ; DIS := (X-X0)*NX+(Z-Z0)*NZ ;
      XS := X-DIS*NX ; ZS := Z-DIS*NZ ; ENDPROCEDURE ;

   PROCEDURE EDGESEC X Z IB IE XS ZS DIS ;
      VARIABLE X0 1 ; VARIABLE Z0 1 ; VARIABLE X1 1 ; VARIABLE Z1 1 ;
      VARIABLE XC 1 ; VARIABLE ZC 1 ; VARIABLE T NM1+1 ; VARIABLE IS 1 ;
      VARIABLE SIDE 1 ; VARIABLE N 1 ; N := BX1BOXPN(IB,IE) ;
      IF N=1 ; IS := IE+1 ; IF IS>4 ; IS := 1 ; ENDIF ;
         X0 := BX1BOXP(IB,IE,1,1) ; Z0 := BX1BOXP(IB,IE,2,1) ;
         X1 := BX1BOXP(IB,IS,1,1) ; Z1 := BX1BOXP(IB,IS,2,1) ;
         T := ( (X-X0)*(X1-X0)+(Z-Z0)*(Z1-Z0) )/( SQR(X1-X0)+SQR(Z1-Z0) ) ;
         IF     CONS(T)<0 ; T := 0 ; XS := X0 ; ZS := Z0 ; XC := CONS(X) ;
            ZC := CONS(Z) ; SIDE := SIG(-(XC-XS)*(Z1-Z0)+(ZC-ZS)*(X1-X0)) ;
            DIS := SIDE*LEN2(X-XS,Z-ZS) ;
         ELSEIF CONS(T)>1 ; T := 1 ; XS := X1 ; ZS := Z1 ; XC := CONS(X) ;
            ZC := CONS(Z) ; SIDE := SIG(-(XC-XS)*(Z1-Z0)+(ZC-ZS)*(X1-X0)) ;
            DIS := SIDE*LEN2(X-XS,Z-ZS) ;
         ELSEIF LO(1) ; NORMAL X Z X0 Z0 X1 Z1 DIS XS ZS ; ENDIF ;
      ELSEIF LO(1) ; WRITE 6 '*** ERROR in EDGESEC, N#1 -- not supported.' ;
         QUIT 0 ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE PTBOX X Z IB INSIDE DISE SIDE ;
     {PROPERTIES OF THE POINT (X,Z) REGARDING THE BOX IB WITH 4 EDGES
      INSIDE:   1: INSIDE, 0: OUTSIDE
      DISE(I): THE CLOSEST DISTANCE TO THE I-TH EDGE
      SIDE(I): SIDE AGAINST THE I-TH EDGE   1: RIGHT   -1: LEFT
      X, Z ARE UP, RIGHT-WARD. THE I=1 EDGE STARTS AT SMALLER RADIUS AT THE
      LEFT SIDE OF THE BOX. THE EDGES GO COUNTERCLOCKWISE FROM I=1 TO I=4.}
      VARIABLE XC 1 ; VARIABLE ZC 1 ; VARIABLE I 1 ;
      VARIABLE XS 1 ; VARIABLE ZS 1 ; VARIABLE DIS 1 ;
      XC := CONS(X) ; ZC := CONS(Z) ; INSIDE := 0 ;
      LOOP I 1 4 ; EDGESEC XC ZC IB I XS ZS DIS ; DISE(I) := ABS(DIS) ;
         SIDE(I) := SIG(DIS) ; INSIDE := INSIDE+SIDE(I) ; ENDLOOP ;
      IF NINT(INSIDE)=4 ; INSIDE := 1 ; ELSEIF LO(1) ; INSIDE := 0 ; ENDIF ;
      ENDPROCEDURE ;

   FUNCTION MCSDIST X Z ;
      VARIABLE IM 1 ; VARIABLE IM0 1 ; VARIABLE INSIDE 1 ; VARIABLE R NM1+1 ;
      VARIABLE DISE 1 4 ; VARIABLE SDIS 1 ; VARIABLE SIE 1 ;
      VARIABLE SIDE 1 4 ; VARIABLE IE 1 ; VARIABLE LHE 1 ;
      VARIABLE BY NM1+1 ; VARIABLE DH NM1+1 ; VARIABLE DIS NM1+1 ;
      VARIABLE XS NM1+1 ; VARIABLE ZS NM1+1 ; VARIABLE RS NM1+1 ;
      FUNCTION POLB X P IB N ; VARIABLE I 1 ; POLB := P(IB,N+1) ;
         LOOP I N 1 -1 ; POLB := POLB*X+P(IB,I) ; ENDLOOP ; ENDFUNCTION ;
      MCSDIST := 0*DA(1) ; LHE := 0 ;
      IF LHE=0 ; LOOP IM 1 BXIBOX ; PTBOX X Z IM INSIDE DISE SIDE ;
          IF INSIDE=1 ; IM0 := BXBOXID(IM) ; R := LEN2(X,Z) ;
             BY := POLB(R,BXBDT,IM0,BXNOB(IM0)) ;
             LOOP IE 1 4 ; EDGESEC X Z IM IE XS ZS DIS ;
                RS := LEN2(XS,ZS) ; DH := POLB(RS,BXDDT,IM0,BXNOD(IM0)) ;
                BY := BY*ENGE(1,1,1,-DIS/(2*DH)) ; ENDLOOP ;
          ELSEIF LO(1) ; SDIS := -SIDE(1)*DISE(1) ;
             LOOP IE 2 4 ; SDIS := MAX(SDIS,-SIDE(IE)*DISE(IE)) ; ENDLOOP ;
             IF SDIS>10*DMAX ; BY := 0 ;
             ELSEIF LO(1) ; IM0 := BXBOXID(IM) ;
                LOOP IE 1 4 ; IF IE=1 ; SDIS := DISE(IE) ; SIE := IE ;
                   ELSEIF DISE(IE)<SDIS ; SDIS := DISE(IE) ; SIE := IE ; ENDIF ;
                   ENDLOOP ;
                EDGESEC X Z IM SIE XS ZS DIS ; RS := LEN2(XS,ZS) ;
                BY := POLB(RS,BXBDT,IM0,BXNOB(IM0)) ;
                LOOP IE 1 4 ; IF SIDE(IE)*DISE(IE)<6*DMAX ;
                   EDGESEC X Z IM IE XS ZS DIS ; RS := LEN2(XS,ZS) ;
                   DH := POLB(RS,BXDDT,IM0,BXNOD(IM0)) ;
                   BY := BY*ENGE(1,1,1,-DIS/(2*DH)) ; ENDIF ; ENDLOOP ; ENDIF ;
          ENDIF ; MCSDIST := MCSDIST+BY ; ENDLOOP ;
      ELSEIF LHE=1 ;                  {HARD EDGES ONLY FOR ILLUSTRATION PURPOSE}
         LOOP IM 1 BXIBOX ; PTBOX X Z IM INSIDE DISE SIDE ; {USE WHILE INSTEAD?}
          IF INSIDE=1 ; IM0 := BXBOXID(IM) ; R := LEN2(X,Z) ;
             MCSDIST := POLB(R,BXBDT,IM0,BXNOB(IM0))+0*DA(1) ; ENDIF ; ENDLOOP ;
      ENDIF ; ENDFUNCTION ;

   FUNCTION FOURIERGAUSS X Z ;
     {EVALUATE THE BY FIELD COMPONENT AT (X,Z) GIVEN FOURIER MODE BLOCK DATA
      PREVIOUSLY READ INTO MFD USING FGDATIN.}
      VARIABLE RAD NM1+1 ; VARIABLE PHI NM1+1 ; VARIABLE IB 1; VARIABLE IL 1;
      VARIABLE I 1 ; VARIABLE NB 1 ; VARIABLE R 1 ; VARIABLE NS 1 ;
      VARIABLE NL 1 ; VARIABLE SIGMA 1 ; VARIABLE DX 1 ; VARIABLE W NM1+1 ;
      VARIABLE RES NM1+1 ; VARIABLE ARG NM1+1 ;
      RAD := SQRT(SQR(X)+SQR(Z)) ; PHI := ATAN2(Z,X) ; NB := MFD(1,1) ;
      DX := ABS(MFD(3,2)|1-MFD(2,2)|1) ; SIGMA := PPOL(1) ;
      FOURIERGAUSS := 0 ; LOOP IB 2 NB+1 ; NL := MFD(IB,1) ;
         R := MFD(IB,2)|1 ; NS := MFD(IB,2)|2 ; ARG := (R - RAD)/DX ;
         IF ABS(RE(ARG))<8*SIGMA ; W := EXP(-SQR(ARG/SIGMA)) ;
            IF     IB=2 ;
               LOOP I 1 4 ; W := W+EXP(-SQR((ARG-I)/SIGMA)) ; ENDLOOP ;
            ELSEIF IB=NB+1 ;
               LOOP I 1 4 ; W := W+EXP(-SQR((ARG+I)/SIGMA)) ; ENDLOOP ; ENDIF ;
            RES := MFD(IB,3)|1 ;
            LOOP IL 4 NL+1 ; ARG := (IL-3)*NS*PHI+MFD(IB,IL)|2 ;
               RES := RES+MFD(IB,IL)|1*SIN(ARG) ; ENDLOOP ;
            FOURIERGAUSS := FOURIERGAUSS+RES*W ; ENDIF ; ENDLOOP ;
      FOURIERGAUSS := FOURIERGAUSS/(SQRT(PI)*SIGMA) ;
      ENDFUNCTION ;

   PROCEDURE POTFLD X S ;
  {----------------------
      DETERMINES THE CURVATURE, POTENTIALS AND FIELDS AT (X,S).
      PPOL,NPOL: DESCRIBE MULTIPOLE CONTENTS; NSDP: DESCRIBES S-DEPENDENCE}
      VARIABLE I 1 ; VARIABLE JPOL 1 ; VARIABLE JEM 1 ; VARIABLE P NM3 ;
      PROCEDURE POFF P H IX IY IS ;
        {DETERMINES OFF PLANE TERMS OF A POTENTIAL P = SUM PIJK X^I Y^J S^K
         SATISFYING DEL^2 P = 0 IN PART. OPT. COO. FROM ITS ZEROTH AND FIRST
         ORDER Y DEP. H: CURVATURE, IX, IY AND IS: SPACIAL COMP.}
         VARIABLE HF NM3 ; VARIABLE HI NM3 ; VARIABLE I 1 ; VARIABLE POLD NM3 ;
         HF := 1+H*DA(IX) ; HI := 1/HF ; POLD := P ;
         LOOP I 2 NOC+2 2 ; P := POLD - INTEG(IY,INTEG(IY,
            HI*( DER(IX,HF*DER(IX,P)) + DER(IS,HI*DER(IS,P)) ) )) ; ENDLOOP ;
         ENDPROCEDURE ;
      PROCEDURE PMFF P L IX IY IS ;
        {DETERMINES OFF PLANE TERMS OF POTENTIAL P = SUM PIJK X^I Y^J S^K
         SATISFYING DEL^2 P = 0 IN CART. COO. THAT HAS SAME ROT. SYMMETRY AS
         AN L POLE. IS: # OF VARIABLE S}
         VARIABLE S NM3 ; VARIABLE R2 NM2 ; VARIABLE R2N NM2 ; VARIABLE K 1 ;
         R2 := DD(IX)*DD(IX)+DD(IY)*DD(IY) ; R2N := 1 ; S := P ;
         IF L=20 ; L:= 0 ; ENDIF ;
         LOOP K L+2 NOC+1 2 ; S := DER(IS,DER(IS,S))/(L*L-K*K) ;
            R2N := R2N*R2 ; P := P + S*R2N ; ENDLOOP ;
         ENDPROCEDURE ;
      PROCEDURE FCCT ;  {CONCATENATES THE FIELD EXPANSIONS WITH THE VALUES OF X}
         VARIABLE ACCT NM1 8 ; VARIABLE X2 NM2 ; X2 := X(2) ; X(2) := 0*X(2) ;
         ACCT(1) := EFX ; ACCT(2) := EFY ; ACCT(3) := EFZ ; ACCT(4) := V ;
         ACCT(5) := BFX ; ACCT(6) := BFY ; ACCT(7) := BFZ ; ACCT(8) := W ;
         POLVAL 1 ACCT 8    X TWOND    ACCT 8 ;
         EFX := ACCT(1) ; EFY := ACCT(2) ; EFZ := ACCT(3) ; V := ACCT(4) ;
         BFX := ACCT(5) ; BFY := ACCT(6) ; BFZ := ACCT(7) ; W := ACCT(8) ;
         X(2) := X2 ; ENDPROCEDURE ;
      PROCEDURE INTERP ;                 {INTERPOLATES CURVATURE AND POTENTIALS}
         VARIABLE AC 100 3 ; VARIABLE BC 3 3 ;
         FUNCTION POL X P N ; VARIABLE I 1 ; POL := P(N+1) ;
            LOOP I N 1 -1 ; POL := POL*X+P(I) ; ENDLOOP ; ENDFUNCTION ;
         LOOP I NN 2 -1 ; IF S<SN(I) ; INP := I-1 ; ENDIF ; ENDLOOP ;
         P:=POL((2*(S+DD(2))-SN(INP)-SN(INP+1))/(SN(INP+1)-SN(INP)),PN,2*NPG+1);
         BC(1) := DD(1) ; BC(2) := S-SN(INP)+DD(2) ; BC(3) := DD(3) ; P := 1-P ;
         AC(1) := HN(INP) + 0*DD(2) ; AC(2) := VN(INP) + 0*DD(2) ;
         AC(3) := WN(INP) + 0*DD(2) ; POLVAL 1 AC 3 BC 3 AC 3 ;
         H :=    AC(1)*P ;    V :=    AC(2)*P ;    W :=    AC(3)*P ;
         BC(1) := DD(1) ; BC(2) := S-SN(INP+1)+DD(2) ; BC(3) := DD(3) ;
         P := 2-P;
         AC(1) := HN(INP+1) + 0*DD(2) ; AC(2) := VN(INP+1) + 0*DD(2) ;
         AC(3) := WN(INP+1) + 0*DD(2) ; POLVAL 1 AC 3 BC 3 AC 3 ;
         H := (H+AC(1)*P)/2 ; V := (V+AC(2)*P)/2 ; W := (W+AC(3)*P)/2 ;
         ENDPROCEDURE ;
      FUNCTION ENGEP IMP IEE IEM S ;           {DERIVATIVE OF THE ENGE FUNCTION}
        {2*IMP POLE, IEE: ENTRANCE OR EXIT, IEM: MAG OR ELE, USING COEFFS ENGEC}
         VARIABLE ENGEPP 100 ;
         ENGEP :=       ENGEC(IMP,IEE,IEM,1) + S*(   ENGEC(IMP,IEE,IEM,2)
                + S*(   ENGEC(IMP,IEE,IEM,3) + S*(   ENGEC(IMP,IEE,IEM,4)
                + S*(   ENGEC(IMP,IEE,IEM,5) + S*    ENGEC(IMP,IEE,IEM,6))))) ;
         ENGEPP :=      ENGEC(IMP,IEE,IEM,2) + S*( 2*ENGEC(IMP,IEE,IEM,3)
                + S*( 3*ENGEC(IMP,IEE,IEM,4) + S*( 4*ENGEC(IMP,IEE,IEM,5)
                + S*  5*ENGEC(IMP,IEE,IEM,6) ))) ;
         IF     ABS(CONS(ENGEP))>30 ; ENGEP := 0 ;
         ELSEIF TRUE ;                 ENGEP := EXP(ENGEP) ;
            ENGEP := -ENGEPP/(2+ENGEP+1/ENGEP) ; ENDIF ; ENDFUNCTION ;
      FUNCTION EDGE X ; VARIABLE I 1 ;      {FF FOR WIGGLER; PPOL(7-16): COEFFS}
         EDGE := 0 ; LOOP I 16 8 -1 ; EDGE := (EDGE+PPOL(I))*(-X) ;
         ENDLOOP ; EDGE := EDGE+PPOL(7) ; IF CONS(EDGE)<-60 ; EDGE := -60 ;
         ELSEIF CONS(EDGE)>30 ; EDGE := 30 ; ENDIF ; EDGE := 1/(1+EXP(EDGE)) ;
         ENDFUNCTION ;
      PROCEDURE DIST X Z XP ZP XC ZC H D LEV DIS XS ZS IDS ;
         VARIABLE P 10 ; VARIABLE SCR 100 ; XS := X ; ZS := Z ; IDS := 0 ;
         IF CONS(H)#0 ; P := (X-XC)*(XP-XC)+(Z-ZC)*(ZP-ZC) ;
            IF CONS(P)>0 ; SCR := SQRT(SQR(X-XC)+SQR(Z-ZC)) ;
               DIS := SCR - (ABS(CONS(H))/CONS(H))/H ; DIS := DIS*H/ABS(H) ;
               IF LEV=0 ; IF CONS(DIS)>0 ; IF CONS(H)<0 ; SCR := -SCR ; ENDIF ;
                  XS := X-DIS*(X-XC)/SCR ; ZS := Z-DIS*(Z-ZC)/SCR ; IDS := 1 ;
                  ENDIF ; ENDIF ;
            ELSEIF TRUE ; DIS := -100*D ; DIS := DIS*H/ABS(H) ; ENDIF ;
         ELSEIF TRUE ;                      {SET (XC,ZC) AS |(XP,ZP)-(XC,ZC)|=1}
            DIS := (X-XP)*(XP-XC)+(Z-ZP)*(ZP-ZC) ;
            IF LEV=0 ; IF CONS(DIS)>0 ;
               XS := X-DIS*(XP-XC) ; ZS := Z-DIS*(ZP-ZC) ; IDS := 1 ;
               ENDIF ; ENDIF ;  ENDIF ; ENDPROCEDURE ;
      PROCEDURE ENGESIDES X Z D LEV IEM XF ZF ENGES ;
         VARIABLE XS 100 ; VARIABLE ZS 100 ; VARIABLE IDS 1 ;
         VARIABLE DIS1 100 ; VARIABLE DIS2 100 ; XF := X ; ZF := Z ;
         DIST X Z PPOL(5) PPOL(6)  PPOL(7)  PPOL(8)  PPOL(13) D LEV
            DIS1 XS ZS IDS ; IF IDS=1 ; XF := XS ; ZF := ZS ; ENDIF ;
         DIST X Z PPOL(9) PPOL(10) PPOL(11) PPOL(12) PPOL(14) D LEV
            DIS2 XS ZS IDS ; IF IDS=1 ; XF := XS ; ZF := ZS ; ENDIF ;
         ENGES := ENGE(1,1,IEM,DIS1/D/2)*ENGE(1,2,IEM,DIS2/D/2) ; ENDPROCEDURE ;
      FUNCTION CENT X Z DR PHI0 ; VARIABLE PH 1 ;
         IF CONS(X)=0 ; PH := 0.5*PI ; IF CONS(Z)<0 ; PH := -0.5*PI ; ENDIF ;
         ELSEIF CONS(X)>0 ; PH := ATAN(CONS(Z)/CONS(X)) ;
            ELSEIF TRUE ; PH := ATAN(CONS(Z)/CONS(X))+PI ; ENDIF ;
         PH := PH-0.5*PHI0 ;
         CENT := PPOL(21)+PH*(PPOL(22)+PH*(PPOL(23)+PH*PPOL(24)))
                 +DR*(PPOL(25)+PH*(PPOL(26)+PH*(PPOL(27)+PH*PPOL(28)))) ;
         CENT := CENT+DR*DR*(PPOL(29)+PH*(PPOL(30)+PH*(PPOL(31)+PH*PPOL(32))))
                 +DR*DR*DR*(PPOL(33)+PH*(PPOL(34)+PH*(PPOL(35)+PH*PPOL(36)))) ;
         ENDFUNCTION ;
      FUNCTION BENDIST X Z IC ;          {FIELD DISTRIBUTION OF BENDING SECTORS}
         VARIABLE XR0 100 ; VARIABLE XR 100 ; VARIABLE XRR 100 ; VARIABLE I 1 ;
         VARIABLE XF 100 ; VARIABLE ZF 100 ; VARIABLE ENGES 100 ;
         VARIABLE IEM 1 ; IEM := 1 ; IF IC<0 ; IEM := 2 ; ENDIF ;
         ENGESIDES X Z PPOL(4) 0 IEM XF ZF ENGES ;
         XR0 := SQRT(SQR(XF-PPOL(2))+SQR(ZF-PPOL(3)))-ABS(PPOL(2)) ;
         IF IC=2 ; BENDIST := CENT(XF-PPOL(2),ZF-PPOL(3),XR0,PPOL(20)) ;
         ELSEIF LO(1) ; XR := XR0/ABS(PPOL(2)) ; XRR := 1 ; BENDIST := 1 ;
            LOOP I 1 PPOL(20) ; XRR := XRR*XR ;
               BENDIST := BENDIST-PPOL(20+I)*XRR ; ENDLOOP ;
            IF IC=-1 ; BENDIST := BENDIST*XR0 ; ENDIF ; ENDIF ;
         BENDIST := BENDIST*PPOL(1)*ENGES ; ENDFUNCTION ;
      PROCEDURE POTS ;        {DETERMINES POTENTIALS FROM INFO ALONG OPTIC AXIS}
         VARIABLE P1 NM3 ; VARIABLE IS 1 ; VARIABLE SL 1 ;
         V := 0*DD(1) ; W := 0*DD(2) ; H := 0 ; IF NSDP=20 ; INTERP ; ENDIF ;
         LOOP I 1 NPOL ; JPOL := ABS(MPOL(I)) ; JEM := (3-MPOL(I)/JPOL)/2 ;
         IF     NSDP=0 ; P := PPOL(I) ;                                  {CONST}
         ELSEIF NSDP=1 ; P := PPOL(I)*ENGE(MOD(JPOL,20),1,JEM,-(S+DD(2))/DR/2) ;
                                                                          {ENFF}
         ELSEIF NSDP=2 ; P := PPOL(I)*ENGE(MOD(JPOL,20),2,JEM,(S+DD(2))/DR/2) ;
                                                                          {EXFF}
         ELSEIF NSDP=3 ; P := PPOL(I)*EXP(-SQR((S+DD(2))/DR)) ;          {GAUSS}
         ELSEIF NSDP=4 ; P := PPOL(I)*(S+DD(2)) ;                       {LINEAR}
         ELSEIF NSDP=5 ; P := PPOL(I)*(S+DD(2))*ISRT(1+SQR((S+DD(2))/DR)) ;
         ELSEIF NSDP=6 ;                                   {THREE TUBE EL. LENS}
         P :=     LOG(COSH((S+DD(2))/DR+PPOL(2))/COSH((S+DD(2))/DR+PPOL(3))) ;
         P := P + LOG(COSH((S+DD(2))/DR-PPOL(2))/COSH((S+DD(2))/DR-PPOL(3))) ;
         P := P * PPOL(1) ;
         ELSEIF NSDP=7 ; P := PPOL(1)*DR*ATAN((S+DD(2))/DR) ;           {GLASER}
         ELSEIF NSDP=8 ;                                              {SOLENOID}
         IF S<0 ;
         P := LOG((1+EXP( 2/DR*(S+DD(2))))/(1+EXP( 2*(S+DD(2)-PPOL(2))/DR)))
         -PPOL(2)/DR ; ELSEIF S>PPOL(2) ;
         P := LOG((1+EXP(-2/DR*(S+DD(2))))/(1+EXP(-2*(S+DD(2)-PPOL(2))/DR)))
         +PPOL(2)/DR ; ELSEIF TRUE ;
         P := LOG((1+EXP(-2/DR*(S+DD(2))))/(1+EXP( 2*(S+DD(2)-PPOL(2))/DR)))+
         (2*(S+DD(2))-PPOL(2))/DR ; ENDIF ; P := PPOL(1)*P ;
         ELSEIF NSDP=9 ;                               {THREE APERTURE EL. LENS}
         P :=     (S+DD(2)+PPOL(3))*ATAN((S+DD(2)+PPOL(3))/DR) ;
         P := P + (S+DD(2)-PPOL(3))*ATAN((S+DD(2)-PPOL(3))/DR) ;
         P := P - (S+DD(2)+PPOL(2))*ATAN((S+DD(2)+PPOL(2))/DR) ;
         P := P - (S+DD(2)-PPOL(2))*ATAN((S+DD(2)-PPOL(2))/DR) ;
         P := P * PPOL(1) ;
         ELSEIF NSDP=10 ;                                       {IDEAL SOLENOID}
         P := SQRT(SQR(S+DD(2))+SQR(DR))-SQRT(SQR(S+DD(2)-PPOL(2))+SQR(DR)) ;
         P := P * PPOL(1) ;
         ELSEIF NSDP=11 ;              {ACCELERATING STATIC HOMOGENEOUS E-FIELD}
         P := PPOL(1)*(S+DD(2)) ;
         ELSEIF NSDP=12 ;                       {GENERAL MULTIPOLE BY GAUSSIANS}
         P := GAUSS1(S+DD(2),PPOL(1),PPOL(2),PPOL(3),I,MFD,IS) ;
         MFP(1) := MFP(1)+IS ;
         ELSEIF NSDP=13 ;                                       {THICK SOLENOID}
         P1 := SQRT(SQR(S+DD(2))+SQR(PPOL(4))) ;
         P :=     SQR(S+DD(2))*LOG(PPOL(4)+P1) + PPOL(4)*P1 ;
         P1 := SQRT(SQR(S+DD(2))+SQR(PPOL(3))) ;
         P := P - SQR(S+DD(2))*LOG(PPOL(3)+P1) - PPOL(3)*P1 ;
         P1 := SQRT(SQR(S-PPOL(2)+DD(2))+SQR(PPOL(4))) ;
         P := P - SQR(S-PPOL(2)+DD(2))*LOG(PPOL(4)+P1) - PPOL(4)*P1 ;
         P1 := SQRT(SQR(S-PPOL(2)+DD(2))+SQR(PPOL(3))) ;
         P := P + SQR(S-PPOL(2)+DD(2))*LOG(PPOL(3)+P1) + PPOL(3)*P1 ;
         P := P * PPOL(1) ;
         ELSEIF NSDP=14 ; P := 0 ;                  {A PIECE OF THICK SOLENOIDS}
         LOOP IS 1 PPOL(1) ; SL := S-MFD(IS,5) ;
         P1 := SQRT(SQR(SL+DD(2))+SQR(MFD(IS,4))) ;
         P := P+MFD(IS,1)*(SQR(SL+DD(2))*LOG(MFD(IS,4)+P1)+MFD(IS,4)*P1) ;
         P1 := SQRT(SQR(SL+DD(2))+SQR(MFD(IS,3))) ;
         P := P-MFD(IS,1)*(SQR(SL+DD(2))*LOG(MFD(IS,3)+P1)+MFD(IS,3)*P1) ;
         P1 := SQRT(SQR(SL-MFD(IS,2)+DD(2))+SQR(MFD(IS,4))) ;
         P := P-MFD(IS,1)*
                (SQR(SL-MFD(IS,2)+DD(2))*LOG(MFD(IS,4)+P1)+MFD(IS,4)*P1) ;
         P1 := SQRT(SQR(SL-MFD(IS,2)+DD(2))+SQR(MFD(IS,3))) ;
         P := P+MFD(IS,1)*
                (SQR(SL-MFD(IS,2)+DD(2))*LOG(MFD(IS,3)+P1)+MFD(IS,3)*P1) ;
            ENDLOOP ;
         ELSEIF TRUE ;     WRITE 6 ' *** ERROR in POTFLD' ; QUIT 0 ;
         ENDIF ;
         IF     MPOL(I)=1  ; H := H +      P/CHIM1 ;
         ELSEIF MPOL(I)=-1 ; H := H + 1000*P/CHIE1 ; ENDIF ;
         IF     LOFF=1 ;   {OFF PLANE EXTENSION WITH SYMM. MULTIPOLE COMPLETION}
            IF     JEM=1 ; P := P*PMM(JPOL) ;
               IF NSDP#0 ; PMFF P JPOL 1 3 2 ; ENDIF ; W := W + P ;
            ELSEIF JEM=2 ; P := P*PEM(JPOL) ;
               IF NSDP#0 ; PMFF P JPOL 1 3 2 ; ENDIF ; V := V + P ; ENDIF ;
         ELSEIF LOFF=2 ;      {OFF PLANE EXTENSION USING JUST PLANE INFORMATION}
            IF     JEM=1 ; IF JPOL#1 ; P := P*DX(JPOL-1) ; ENDIF ;
                               P := P*DD(3) ;    W := W + P ;
            ELSEIF JEM=2 ; P := P*DX(JPOL) ; V := V + P ; ENDIF ;
         ENDIF ; ENDLOOP ;
         IF LOFF=2 ; POFF V H 1 3 2 ; POFF W H 1 3 2 ; ENDIF ;  H := CONS(H) ;
         ENDPROCEDURE ;
      PROCEDURE POTXZ ;                {DETERMINES POTENTIAL FROM INFO IN PLANE}
         VARIABLE CPHI 20 ; VARIABLE SPHI 20 ;
         PROCEDURE FIELDXZ X Z T V W ;            {CARTESIAN MIDPLANE POTENTIAL}
            VARIABLE F 100 2 ; VARIABLE XPP 200 20 ; VARIABLE ZZ 100 ;
            VARIABLE XR0 100 ; VARIABLE I 1 ; VARIABLE J 1 ;
            VARIABLE R 1 ; VARIABLE NM 1 ; VARIABLE XR 100 ;
            VARIABLE XF 100 ; VARIABLE ZF 100 ; VARIABLE ENGES 100 ;
            VARIABLE XS 100 ; VARIABLE ZS 100 ; VARIABLE IDS 1 ;
            VARIABLE DIS1 100 ; VARIABLE DIS2 100 ;
            BFY := 0 ; V := 0 ;
            IF (NSDP=-1)+(NSDP=-2) ;             {BENDING ELEMENT FRINGE FIELDS}
               EFX := 0 ; EFZ := 0 ;    {USE CAREFULLY FOR AN ELECTRIC CASE: WC}
               XPP(1) := 1 ; LOOP I 2 20 ; XPP(I) := XPP(I-1)*X ; ENDLOOP ;
               LOOP I 1 NPOL ; JPOL := ABS(MPOL(I)) ;
                  JEM := (3-MPOL(I)/JPOL)/2 ; P := XPP(JPOL)*PPOL(I) ;
                  ZZ := Z/DR/2 ; IF  NSDP=-1 ; ZZ := -ZZ ; ENDIF ;
                  IF     JEM=1 ; BFY := BFY + P*ENGE(1,1,JEM,ZZ) ;
                  ELSEIF JEM=2 ; EFX := EFX-1000*P*JPOL*ENGE(1,1,JEM,ZZ) ;
                     IF NSDP=-1 ;  P := -P ; ENDIF ;
                     EFZ := EFZ-1000*P*X*ENGEP(1,1,JEM,ZZ)/DR/2 ; ENDIF ;
                  ENDLOOP ;
               F(1) :=  CPHI*EFX+SPHI*EFZ+0*DD(1) ;
               F(2) := -SPHI*EFX+CPHI*EFZ+0*DD(1) ; POTI F 2 V ; V := - V*.001 ;
            ELSEIF NSDP=-3 ;                                           {WIGGLER}
               BFY := PPOL(1)*COS((PPOL(2)+PPOL(5)*Z)*Z) ;
               BFY := EDGE(Z/PPOL(3))*EDGE((-Z+PPOL(4))/PPOL(3))*BFY ;
            ELSEIF NSDP=-4 ;                                            {DIPOLE}
               IF MFP(2)=1 ; MFP(2) := 0 ;         {CREATE FIELD DATA FOR MFFLD}
                  LOOP I MFP(3) MFP(4) MFP(5) ; LOOP J MFP(6) MFP(7) MFP(8) ;
                     WRITE 98 SF(BENDIST(I,J,1),'(G23.16)') ;
                     ENDLOOP ; ENDLOOP ; CLOSEF 98 ; ENDIF ;
               BFY := BENDIST(X,Z,1) ;
            ELSEIF NSDP=-5 ;                      {MEASURED MAGNETIC FIELD DATA}
               BFY := GAUSS(X,Z,PPOL(1),PPOL(2),PPOL(3),PPOL(4),PPOL(5),MFD,J) ;
               MFP(1) := MFP(1)+J ;
            ELSEIF NSDP=-6 ;        {MEASURED FIELD DATA FOURIER REPRESENTATION}
               BFY := FOURIERGAUSS(X,Z) ;
            ELSEIF NSDP=-7 ;                       {DIPOLE WITH DETAILED CENTER}
               IF MFP(2)=1 ; MFP(2) := 0 ;         {CREATE FIELD DATA FOR MFFLD}
                  LOOP I MFP(3) MFP(4) MFP(5) ; LOOP J MFP(6) MFP(7) MFP(8) ;
                     WRITE 98 SF(BENDIST(I,J,2),'(G23.16)') ;
                     ENDLOOP ; ENDLOOP ; CLOSEF 98 ; ENDIF ;
               BFY := BENDIST(X,Z,2) ;
            ELSEIF NSDP=-8 ;            {SUPERIMPOSED COMBINED FUNCTION MAGNETS}
               IF MFP(2)=1 ; MFP(2) := 0 ;         {CREATE FIELD DATA FOR MFFLD}
                  LOOP I MFP(3) MFP(4) MFP(5) ; LOOP J MFP(6) MFP(7) MFP(8) ;
                     WRITE 98 SF(MCSDIST(I,J),'(G23.16)') ;
                     ENDLOOP ; ENDLOOP ; CLOSEF 98 ; ENDIF ;
               BFY := MCSDIST(X,Z) ;
            ELSEIF NSDP=-11 ; V := BENDIST(X,Z,-1) ;   {ELECTROSTATIC DEFLECTOR}
            ELSEIF NSDP=-12 ;                                      {CYLINDRICAL}
               XR0 := SQRT(SQR(X-PPOL(2))+SQR(Z)) ;
               V := PPOL(1)*LOG(-XR0/PPOL(2)) ;
            ELSEIF NSDP=-13 ;                                        {SPHERICAL}
               XR0 := SQRT(SQR(X-PPOL(2))+SQR(Z)) ;
               V := PPOL(1)*(1+PPOL(2)/XR0) ;
            ELSEIF NSDP=-21 ;        {COMBINED MAGNET WITH E-MULTIPOLES FOR G-2}
               R := PPOL(NPOL+1) ; NM := MPOL(NPOL+1) ; XF := X ; ZF := Z ;
               DIST X Z 0 0 0 1 0 DR 0 DIS1 XS ZS IDS ;
                  IF IDS=1 ; XF := XS ; ZF := ZS ; ENDIF ;
               DIST X Z PPOL(NPOL+2) PPOL(NPOL+3) PPOL(NPOL+4) PPOL(NPOL+5) 0
                  DR 0 DIS2 XS ZS IDS ; IF IDS=1 ; XF := XS ; ZF := ZS ; ENDIF ;
              {MULTIPOLE COMPONENTS} J := 2 ;
              {THE MAGNETIC PART - NO S DEPENDENT FRINGE FIELD}
               XR0 := SQRT(SQR(X+R)+SQR(Z))-R ; XR := 1 ; BFY := PPOL(1) ;
               LOOP I 2 MPOL(NM) ; XR := XR*XR0 ; IF I=MPOL(J) ;
                     BFY := BFY+PPOL(J)*XR ; J := J+1 ; ENDIF ; ENDLOOP ;
              {THE ELCTROSTATIC PART - S DEPENDENT ENGE FRINGE FIELD}
              IF MPOL(NPOL+2)=1 ;
               XR0 := SQRT(SQR(XF+R)+SQR(ZF))-R ; XR := XR0 ; V := 0 ;
               LOOP I 2 ABS(MPOL(NPOL)) ; XR := XR*XR0 ; IF I=ABS(MPOL(J)) ;
                     ENGES := ENGE(I,1,2,DIS1/DR/2)*ENGE(I,2,2,DIS2/DR/2) ;
                     V := V+PPOL(J)*XR*ENGES ; J := J+1 ; ENDIF ; ENDLOOP ;
               ENDIF ;
            ELSEIF TRUE ; WRITE 6 ' *** ERROR in FIELDXZ' ; QUIT 0 ; ENDIF ;
            W := BFY*DD(3) ; ENDPROCEDURE ;
         CPHI := COS(X(13)) ; SPHI := SIN(X(13)) ;
         FIELDXZ X(11)+CPHI*DD(1)-SPHI*DD(2) X(12)+SPHI*DD(1)+CPHI*DD(2)
                {X(14)+TLOC+TP1*DD(2) -- THINK THIS THROUGH IF A TIME DEPENDENT
                 ELEMENT IS NEEDED TO BE IMPLEMENTED.} 0  V W ;
         POFF V 0 1 3 2 ; POFF W 0 1 3 2 ; ENDPROCEDURE ;
      {------------------------------------------------------------------------}
      IF LM=0 ; LM := 1 ; CO NOC+1 ; JPOL := 1 ; DX(1) := DD(1) ;
         LOOP I 2 NOC+1 ; DX(I) := DX(I-1)*DD(1) ; ENDLOOP ;
         LOOP I 1 NOC+1 ; P := JPOL*DD(3) ; POFF P 0 1 3 2 ; PMM(I) := P ;
            PEM(I+20) := P ; JPOL := JPOL*DD(1) ; P := JPOL ;
            POFF P 0 1 3 2 ; PEM(I) := P ; PMM(I+20) := P ;
         ENDLOOP ; PEM(20) := 1 ; PMM(20) := 1 ; CO NOC-1 ; ENDIF ;
      CO NOC+1 ; IF NSDP>-1 ; POTS ; ELSEIF NSDP<0 ; POTXZ ; ENDIF ;
      EFX := -1000*DER(1,V) ; EFY := -1000*DER(3,V) ; EFZ := -1000*DER(2,V) ;
      BFX :=       DER(1,W) ; BFY :=       DER(3,W) ; BFZ :=       DER(2,W) ;
      IF NSDP<0 ; H := CONS(BFY)/CHIM1-CONS(EFX)/CHIE1 ; ENDIF ;
      CO NOC-1 ; IF LCCT=1 ; FCCT ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE ODE X S XP ; {EOM OF ALL QUANTITIES TO BE INTEGRATED
      X: 1-8: PHASE SPACE.
      11-15:  REF. ORBIT X, Z, PHI, TIME (S), ENERGY GAIN (KEV).
      21-29:  SPIN MATRIX.
      XP: X'.              REFERENCE: M. BERZ, NIM A298 (1990) 473.}
      VARIABLE ETA1 NM2 {K/M0/CLIGHT^2} ; VARIABLE P0PZ NM2 {P0/PZ} ;
      VARIABLE EPG  NM2 {1+X(7)} ;        VARIABLE EPHX NM2 {1+H*X(1)} ;
      VARIABLE XP5  NM2 {L'} ;            VARIABLE POP0 1 ; VARIABLE ETA10 1 ;
      VARIABLE SCR  NM2 ; VARIABLE LAMBDA NM2 ; VARIABLE SCR0 NM2 ;
      VARIABLE SCR1 NM2 ; VARIABLE SCR2 NM2 ; VARIABLE SCR3 NM2 ;
      VARIABLE WX NM2 ; VARIABLE WY NM2 ; VARIABLE WZ NM2 ;
      IF LRP#1 ; WRITE 6 ' *** ERROR, call RP before ODE' ; QUIT 0 ; ENDIF ;
      ETA10 := (1+0.001*CONS(X(15))/CONS(E0))*CONS(ETA) ;
      IF ETA10<1E-10 ; WRITE 6 ' *** VOLTAGE TOO HIGH ' ; QUIT 0 ; ENDIF ;
      POP0 := SQRT((ETA10/CONS(ETA))*((2+ETA10)/(2+CONS(ETA)))) ;
      TP1 := ((1+ETA10)/(1+CONS(ETA)))/CONS(POP0) ;
      CHIM1 := CONS(CHIM)*POP0 ; CHIE1 := CONS(CHIE)*POP0/TP1 ; POTFLD X S ;
      XP(11) := -SIN(X(13)) ; XP(12) := COS(X(13)) ; XP(14) := TP1/CONS(V0) ;
      XP(13) := H ; XP(15) := 0.001*CONS(Z0)*CONS(EFZ) ;
      EPHX := 1+H*X(1) ; EPG := 1+X(7) ;
      ETA1 := ( 1+X(6) -0.001*(1+X(8))*(CONS(Z0)*(V-CONS(V))-X(15))/CONS(E0) )
              *CONS(ETA)/EPG ;
      SCR := SQR(EPG)*(ETA1/CONS(ETA))*((2+ETA1)/(2+CONS(ETA))) ;
      IF LKC=0 ; P0PZ := ISRT(SCR-SQR(X(2))-SQR(X(4))) ;
         ELSEIF LKC=1 ; P0PZ := ISRT(SCR) ; ENDIF ;
      SCR := EPHX*P0PZ ; XP5 := EPHX*EPG*((1+ETA1)/(1+CONS(ETA)))*P0PZ ;
                XP(1) := SCR*X(2) ; XP(2) := ( EFX/CONS(CHIE)*XP5
               + (-BFY +X(4)*P0PZ*BFZ)/CONS(CHIM)*EPHX )*(1+X(8)) + H/P0PZ ;
      IF ND>1 ; XP(3) := SCR*X(4) ; XP(4) := ( EFY/CONS(CHIE)*XP5
               + ( BFX -X(2)*P0PZ*BFZ)/CONS(CHIM)*EPHX )*(1+X(8)) ; ENDIF ;
      IF ND>2 ; XP(5) := -(XP5-CONS(XP5))*(1+CONS(ETA))/(2+CONS(ETA)) ; ENDIF ;
      XP(6) := 0*DD(6) ; XP(7) := 0*DD(7) ; XP(8) := 0*DD(8) ;
      IF LSPN=1 ;
         SCR1 := -SCR*(1+G0*(1+ETA1))*(1+X(8))/CONS(CHIM) ;
         SCR0 := CONS(ETA)*(2+CONS(ETA))*(1+X(8))/EPG ;
         LAMBDA := SCR*(X(2)*BFX+X(4)*BFY+BFZ/P0PZ)/CONS(CHIM) ;
         SCR2 := SCR0*G0*LAMBDA/(2+ETA1)/EPG ;
         SCR3 := SCR0*(G0+1/(2+ETA1))/(1+CONS(ETA))/CONS(CHIE)*EPHX ;
         WX := SCR1*BFX + SCR2*X(2) + SCR3*(X(4)*P0PZ*EFZ-EFY) ;
         WY := SCR1*BFY + SCR2*X(4) + SCR3*(EFX-X(2)*P0PZ*EFZ) + H ;
         WZ := SCR1*BFZ + SCR2/P0PZ + SCR3*(X(2)*EFY-X(4)*EFX)*P0PZ ;
         XP(21) := -WZ*X(24) + WY*X(27) ; XP(22) := -WZ*X(25) + WY*X(28) ;
         XP(23) := -WZ*X(26) + WY*X(29) ; XP(24) :=  WZ*X(21) - WX*X(27) ;
         XP(25) :=  WZ*X(22) - WX*X(28) ; XP(26) :=  WZ*X(23) - WX*X(29) ;
         XP(27) := -WY*X(21) + WX*X(24) ; XP(28) := -WY*X(22) + WX*X(25) ;
         XP(29) := -WY*X(23) + WX*X(26) ; ENDIF ;
      ENDPROCEDURE ;

   FUNCTION HAMILTONIAN A V H ;     {COMPUTES THE HAMILTONIAN IN PO COORDINATES;
      A: VECTOR POTENTIAL IN TM , V: SALAR POT. IN KV, H: CURVATURE IN M^-1}
      PROCEDURE HFULL ;
         VARIABLE ETA NM2 ; VARIABLE PREL NM2 ; VARIABLE CHIM NM2 ;
         ETA  := ((E0-.001*Z0*V)/M0)/AMUMEV ;
         PREL := SQRT(ETA*(2+ETA)) ; CHIM := (AMU*C/Z0/EZERO)*M0*PREL ;
         HAMILTONIAN := A/CONS(CHIM) - (1+H*DD(1))*
            SQRT((CHIM/CONS(CHIM))*(CHIM/CONS(CHIM))-DD(2)*DD(2)-DD(4)*DD(4)) ;
         ENDPROCEDURE ;
      IF LRP#1 ;  WRITE 6 ' *** ERROR, call RP before HAMILTONIAN ' ;
                  QUIT 0 ;   ENDIF ;  CO NOC+1 ;
      IF ABS(V)=0 ; HAMILTONIAN := A/CONS(CHIM) - (1+H*DD(1))*HFAC ;
      ELSEIF TRUE ; HFULL ;
      ENDIF ; CO NOC-1 ; ENDFUNCTION ;

   PROCEDURE RP E M Z ;  {SETS ENERGY E0 [MEV], MASS M0 [AMU], CHARGE Z0 [UNITS]
      MOMENTUM P0 [MEV], VELOCITY V0 [M/SEC], AND SOME PARAMETERS}
      VARIABLE PHI NM1 ; VARIABLE I 1 ; VARIABLE NOM 1 ;
      IF LOV#1 ; WRITE 6 ' *** ERROR, call OV before RP ' ; QUIT 0 ; ENDIF ;
      LRP := 1 ; NOM := NOC ; CO NO+1 ;
      E0 := E ; M0 := M ; Z0 := Z ; IF ND=3 ; E0 := CONS(E0)*(1+DD(6)) ; ENDIF ;
      LOOP I 1 8 ; XX(I) := DD(I) ; IF I>TWOND ; XX(I) := 0*DD(I) ; ENDIF ;
      ENDLOOP ;                               XX(6) := (E0-CONS(E0))/CONS(E0) ;
      XX(7) := (M0-CONS(M0))/CONS(M0) ;       XX(8) := (Z0-CONS(Z0))/CONS(Z0) ;
      XX(21) := 1 ; XX(22) := 0 ; XX(23) := 0 ; XX(24) := 0 ; XX(25) := 1 ;
      XX(26) := 0 ; XX(27) := 0 ; XX(28) := 0 ; XX(29) := 1 ;
      ETA   := E0/M0/AMUMEV ; PHI := SQRT(ETA*(2+ETA)) ;
      P0 := (AMUMEV*M0)*PHI ; V0  := CLIGHT*(PHI/(1+ETA)) ;
      TFAC := ((1+CONS(ETA))/(2+CONS(ETA)))*CONS(V0) ;
      CHIM  := (AMU*CLIGHT/EZERO)*M0/Z0*PHI ; CHIE := CHIM*V0 ;
      HFAC := SQRT(SQR(CHIM/CONS(CHIM))-DD(2)*DD(2)-DD(4)*DD(4)) ; CO NOM ;
      ENDPROCEDURE ;

   PROCEDURE RPR  CHI M Z ;     {SETS REFERENCE PARTICLE FROM MAGNETIC RIGIDITY}
      VARIABLE PHI 100 ; VARIABLE ETA 100 ; VARIABLE NOM 1 ; NOM := NOC ;
      RP 1 1 1 ; CO NO+1 ; PHI := CHI/(AMU*CLIGHT/EZERO)/M*Z ;
      ETA := SQRT(1+PHI*PHI) - 1 ; RP ETA*M*AMUMEV M Z ; CO NOM ; ENDPROCEDURE ;
   PROCEDURE RPM  MEVC M Z ;    {SETS REFERENCE PARTICLE FROM MOMENTUM IN MEV/C}
      RP 1 1 1 ; RPR MEVC*(1E6/CLIGHT)/Z M Z ; ENDPROCEDURE ;

   PROCEDURE RPP E    ; RP E 1.00727646688   1 ; G0 := 1.792847337 ;
      ENDPROCEDURE ;
   PROCEDURE RPE E    ; RP E 5.485799110D-4 -1 ; G0 := 0.001159652187 ;
      ENDPROCEDURE ;
   PROCEDURE RPPI E Z ; RP E 0.149834758     Z ; G0 := 0 ;      ENDPROCEDURE ;
   PROCEDURE RPMU E   ; RP E 0.1134289168   -1 ; G0 := 0.0011659160 ;
      ENDPROCEDURE ;
   PROCEDURE RPS LS G ; LSPN := LS ; IF G#0 ; G0 := G ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE RK N X0 X1 Y0 H0 HS H1 EPS BS Z Y1 ERREST ;
     {RUNGE KUTTA INTEGRATOR OF ORDER EIGHT WITH AUTOMATIC STEP SIZE CONTROL
      USING A SEVENTH ORDER ALGORITHM. EACH STEP REQUIRES 13 EVALUATIONS.
      WRITTEN IN FORTRAN 77                  BY INGOLF KUEBLER  1986
      REWRITTEN FOR USE WITH COSY INFINITY   BY MARTIN BERZ     1990
      INPUT PARAMETERS:
         N          NUMBER OF ODE'S
         X0, X1     INITIAL AND FINAL VALUES OF INDEPENDENT VARIABLE
         Y0         INITIAL VALUES OF ODE
         H0, HS, H1 MINIMUM ALLOWED, SUGGESTED AND MAXIMUM ALLOWED  STEPSIZE
         EPS, BS    DESIRED ERROR, BACKSTEP BOUNDS (1E-12 < EPS,  BS > EPS
         Z          2 DIMENSIONAL SCRATCH ARRAY WITH DIMENSIONS N AND 16
      OUTPUT PARAMETERS:
         Y1        SOLUTION ARRAY OF LENGTH N
         ERREST    ESTIMATION OF THE ACTUAL ACCUMULATED ERROR}
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE X 1 ; VARIABLE H 1;
      VARIABLE RFNORM 1 ; VARIABLE HH0 1 ; VARIABLE HH1 1 ; VARIABLE ISTP 1 ;
      VARIABLE FORM 10 ; VARIABLE STR 400 ; VARIABLE SCR 1 ;
      PROCEDURE NORM N X AX ; VARIABLE I 1 ; AX := 0 ; LOOP I 1 N ;
         IF TYPE(X(I))=TYPE(DD(1)) ; AX := MAX(AX,WABS(X(I),WAF)) ; ELSEIF
         TRUE ; AX := MAX(AX,ABS(X(I))) ; ENDIF ; ENDLOOP ; ENDPROCEDURE ;
      IF LRKCO=0 ; RKCO HSQR A B C D ; LRKCO := 1 ; ENDIF ;       {PREPARATIONS}
      OPENF 77 'RKLOG.DAT' 'UNKNOWN' ; ISTP := 0 ;
      STR := '# STEP    S                 DS' ;
     {OPTIONAL FIELD OUTPUT ALONG THE INTEGRATION PATH BY SETTING LRKO>0}
      IF LRKO>0 ; write 6 '## LRKO = '&SI(LRKO)&' ##' ;
         STR := STR&'           POSITION(X,    Z,             Phi,'&
                    '           Radius)        By             Ex'&
                    '             Ez             Egain' ;
         FORM := '(E15.7)' ; ENDIF ;
      WRITE 77 '#RUNGE KUTTA   S1,S2 = '&S(X0)&', '&S(X1)
               '#        HMIN,H,HMAX = '&S(H0)&', '&S(HS)&', '&S(H1)
               '#             EPS,BS = '&S(EPS)&', '&S(BS)       STR ;
      LOOP I 1 N ; Z(I,1) := Y0(I) ; Z(I,2) := 0.D0 ;    ENDLOOP ;
      H := ABS(HS) ; HH0 := ABS(H0) ; HH1 := ABS(H1) ;
      IF X1-X0<0 ; H := -H ; HH0 := -HH0 ; HH1 := -HH1 ; ENDIF ;
      X := X0 ; RFNORM := 0 ; ERREST := 0 ; ISTP := 0 ;
      STR := SF(ISTP,'(I6)')&SF(X,'(E18.10)')&SF(H,'(E13.5)') ;
      IF LRKO>0 ; SCR := LEN2(CONS(Z(11,1)),CONS(Z(12,1))) ; RKO := SCR&SCR ;
         LOOP I 11 13 ; STR := STR&SF(CONS(Z(I,1)),FORM) ; ENDLOOP ;
         STR := STR&SF(SCR,FORM)&SF(CONS(BFY),FORM)&SF(CONS(EFX),FORM)&
                    SF(CONS(EFZ),FORM)&SF(CONS(Z(15,1)),FORM) ; ENDIF ;
      WRITE 77 STR ;
      WHILE X#X1 ;                                        {COMPUTE NEW STEPSIZE}
         IF RFNORM#0 ;        H := H*MIN(4,(EPS/RFNORM)^HSQR) ;          ENDIF ;
         IF ABS(H)>ABS(HH1) ; H := HH1 ; ELSEIF ABS(H)<ABS(HH0)*.99 ; H := HH0 ;
            WRITE 6 ' --- WARNING, minimum stepsize reached in RK' ; ENDIF ;
         IF (X+H-X1)*H>0 ;    H := X1-X ; ENDIF ; ISTP := ISTP + 1 ;
         LOOP J 1 13 ; LOOP I 1 N ; Y0(I) := 0 ;     {EVALUATE RHS AT 13 POINTS}
               LOOP K 1 J-1 ;  Y0(I) := Y0(I) + Z(I,K+3)*B(J,K) ; ENDLOOP ;
               Y0(I) := H * Y0(I) + Z(I,1) ; ENDLOOP ; ODE Y0 X+H*A(J) Y1 ;
            LOOP I 1 N ; Z(I,J+3) := Y1(I) ; ENDLOOP ; ENDLOOP ;
         LOOP I 1 N ; Z(I,2) := 0 ; Z(I,3) := 0 ;  {EXECUTE 7TH,8TH ORDER STEPS}
            LOOP J 1 13 ; Z(I,2) := Z(I,2) + Z(I,J+3)*D(J) ;
               Z(I,3) := Z(I,3) + Z(I,J+3)*C(J) ; ENDLOOP ;
            Y1(I) := (Z(I,3)-Z(I,2))*H ; Z(I,3) := Z(I,3)*H+Z(I,1) ; ENDLOOP ;
         NORM N Y1 RFNORM ;           {ESTIMATE ERROR AND DECIDE ABOUT BACKSTEP}
         IF (RFNORM>BS)*(ABS(H/H0)>1.2) ; H := H/3 ; RFNORM := 0 ;
         ELSEIF TRUE ; LOOP I 1 N ; Z(I,1) := Z(I,3) ; ENDLOOP ; X := X + H ;
            STR := SF(ISTP,'(I6)')&SF(X,'(E18.10)')&SF(H,'(E13.5)') ;
            IF LRKO>0 ; SCR := LEN2(CONS(Z(11,1)),CONS(Z(12,1))) ;
               RKO := MIN((RKO|1),SCR)&MAX((RKO|2),SCR) ;
               LOOP I 11 13 ; STR := STR&SF(CONS(Z(I,1)),FORM) ; ENDLOOP ;
               STR := STR&SF(SCR,FORM)&SF(CONS(BFY),FORM)&SF(CONS(EFX),FORM)&
                          SF(CONS(EFZ),FORM)&SF(CONS(Z(15,1)),FORM) ; ENDIF ;
            WRITE 77 STR ; ERREST := ERREST + RFNORM ; ENDIF ; ENDWHILE ;
      WRITE 77 '#ERROR ESTIMATE '&S(ERREST) ;
      LOOP I 1 N ; Y1(I) := Z(I,1) ; ENDLOOP ; CLOSEF 77 ;
      IF LRKO>0 ; OS 'cp RKLOG.DAT RKLOG'&SI(LRKO)&'.DAT' ;  {cp: LINUX COMMAND}
         LRKO := LRKO+1 ; ENDIF ;
      ENDPROCEDURE ;

{COSY PARTICLE OPTICAL ELEMENTS}
{******************************}

   PROCEDURE DLACT ARR L ; VARIABLE LP0PZ NM1 ; LP0PZ := CONS(ETA) ;
      LP0PZ := (1+ARR(6))*( 2*(1+ARR(7))+(1+ARR(6))*LP0PZ )/(2+LP0PZ) ;
      IF LKC=0 ; LP0PZ := L*ISRT(LP0PZ-SQR(ARR(2))-SQR(ARR(4))) ;
         ELSEIF LKC=1 ; LP0PZ := L*ISRT(LP0PZ) ; ENDIF ;
                ARR(1) := ARR(1) + LP0PZ*ARR(2) ;
      IF ND>1 ; ARR(3) := ARR(3) + LP0PZ*ARR(4) ; ENDIF ;
      IF ND>2 ; LP0PZ := (1+ARR(7)+(1+ARR(6))*CONS(ETA))*LP0PZ/(1+CONS(ETA))-
         L ; ARR(5) := ARR(5) - LP0PZ*(1+CONS(ETA))/(2+CONS(ETA)) ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE DL L ;                                           {FIELD-FREE DRIFT}
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before DL' ; QUIT 0 ;ENDIF ;
      DLACT MAP L ; UMS ; DLACT MSC L ;
      LOCSET 0 L 0 L 0 0 ; DR := 0 ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE PS D ;                  {POINCARE' SECTION WITH GRAPHICS DISPLAY N}
      DR := D ; LOCSET 0 0 0 0 0 0 ; UPDATE 0 0 ; ENDPROCEDURE ;

   PROCEDURE SDELE S1 S2 H1 H2 H3 D ;             {LETS S-DEPENDENT ELEMENT ACT}
      VARIABLE ERREST 1 ; VARIABLE I 1 ; VARIABLE J 1 ;
      VARIABLE EE0 1 ; VARIABLE PP0 1 ; VARIABLE TFAC0 1 ;
      VARIABLE RKSCR NM2 29 16 ; VARIABLE MMP NM2 29 ; VARIABLE MMQ NM2 29 ;
      LCCT := 1 ; DR := D ;
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before element' ; QUIT 0 ; ENDIF ;
      LOOP I 1 8 ; MMP(I) := XX(I) ; ENDLOOP ;
      LOOP I 9 29 ; MMP(I) := 0 ; ENDLOOP ;
      LOOP I 21 29 4 ; MMP(I) := 1 ; ENDLOOP ;
      MMP(11) := XLOC ; MMP(12) := ZLOC ; MMP(13) := PLOC ;
      MMP(14) := TLOC ; MMP(15) := VLOC ;
      RK 29 CONS(S1) CONS(S2) MMP CONS(H1) CONS(H2) CONS(H3) EPS EPS*20 RKSCR
            MMQ ERREST ;
      LOOP I 1 8 ; MSC(I) := MMQ(I) ; ENDLOOP ; LOOP I 1 3 ;
      LOOP J 1 3 ; SSCR(I,J) := MMQ((I-1)*3+J+20) ; ENDLOOP ; ENDLOOP ;
      LOCSET MMQ(11) MMQ(12) MMQ(13) S2-S1 MMQ(15) MMQ(14) ;
      IF NSDP>-1 ; IF VLOC#0 ;
         PP0 := CONS(P0) ; EE0 := CONS(E0) ; TFAC0 := TFAC ;
         RP E0+VLOC*.001 M0 Z0 ; VLOC := 0 ; MSC(2) := MSC(2)*(PP0/CONS(P0)) ;
         IF ND>1 ; MSC(4) := MSC(4)*(PP0/CONS(P0)) ; ENDIF ;
         IF ND>2 ; MSC(5) := MSC(5)*(TFAC/TFAC0) ;
                   MSC(6) := MSC(6)*(EE0/CONS(E0)) ; ENDIF ; ENDIF ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE SDELEREF S1 S2 H1 H2 H3 D ;     {S-DEPENDENT ELEMENT FOR REFERENCE}
      VARIABLE RKSCR 1 29 16 ; VARIABLE MMP 1 29 ; VARIABLE MMQ 1 29 ;
      VARIABLE ERREST 1 ; VARIABLE I 1 ; VARIABLE LSPNO 1 ;
      LSPNO := LSPN ; LSPN := 0 ; LCCT := 1 ; DR := D ;
      LOOP I 1 8 ; MMP(I) := 0*XX(I) ; ENDLOOP ;
      LOOP I 9 29 ; MMP(I) := 0 ; ENDLOOP ; MMP(11) := XLOC ; MMP(12) := ZLOC ;
      MMP(13) := PLOC ; MMP(14) := TLOC ; MMP(15) := VLOC ;
      RK 29 CONS(S1) CONS(S2) MMP CONS(H1) CONS(H2) CONS(H3) EPS EPS*20 RKSCR
            MMQ ERREST ; LOCSET MMQ(11) MMQ(12) MMQ(13) S2 MMQ(15) MMQ(14) ;
      LSPN := LSPNO ; ENDPROCEDURE ;

   PROCEDURE DSDED LDL L H1 H2 H3 D ;   {STRAIGHT SDELE BETWEEN NEGATIVE DRIFTS}
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ; VARIABLE SCE 1 ;
      SCE := 2E-5 ;       {SCE is to force UPDATE to output the element name CE}
      UMS ; DLACT MSC -LDL ; SNM MSC MS ; SSNM SSCR SM ;
      LOCSET 0 -LDL 0 -LDL 0 0 ;
      SDELE -LDL L+LDL H1 H2 H3 D ; UPDATEMAP MSC MS MSC SSCR SM SSCR ;
      DLACT MSC -LDL ;
      IF L<1E-5 ; LOCSET 0 L 0 L+SCE 0 0 ; UPDATE 1 1 ; SPOS := SPOS-SCE ;
         ELSEIF LO(1) ; LOCSET 0 L 0 L 0 0 ; UPDATE 1 1 ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE SIELE L D ;                        {LETS S-INDEPENDENT ELEMENT ACT}
      VARIABLE XP NM2 29 ; VARIABLE I 1 ; VARIABLE RES NM1 ;
      PROCEDURE SPNFLO ; VARIABLE J 1 ; VARIABLE K 1 ; VARIABLE N 1 ;
         VARIABLE VN NM2 3 3 ; VARIABLE VNP NM2 3 3 ; VARIABLE W NM2 3 3 ;
         VARIABLE VNIJ NM2 ;  RES := 1 ; N := 0 ; LOOP I 1 3 ; LOOP J 1 3 ;
         W(I,J) := XP(3*(I-1)+J+20)*L ; SSCR(I,J) := 0 ; VNP(I,J) := 0 ;
         ENDLOOP ; VNP(I,I) := 1 ; SSCR(I,I) := 1 ; ENDLOOP ;
         WHILE RES#0 ; N := N+1 ; RES := 0 ;
            LOOP I 1 3 ; LOOP J 1 3 ; VNIJ := 0 ;
            LOOP K 1 TWOND ; VNIJ := VNIJ + XP(K)*DER(K,VNP(I,J)) ; ENDLOOP ;
            LOOP K 1 3 ;     VNIJ := VNIJ + W(K,J)*VNP(I,K) ; ENDLOOP ;
            RES := RES + ABS(VNIJ) ; VN(I,J) := VNIJ/N ;
            SSCR(I,J) := SSCR(I,J) + VN(I,J) ; ENDLOOP ; ENDLOOP ;
            LOOP I 1 3 ; LOOP J 1 3 ; VNP(I,J) := VN(I,J) ; ENDLOOP ; ENDLOOP ;
         IF N>200 ; WRITE 6 ' $$$ ERROR in SPNFLO, no convergence ' ; QUIT 0 ;
         ENDIF ; ENDWHILE ; ENDPROCEDURE ;
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before element' ; QUIT 0 ;ENDIF ;
      DR := D ; NSDP := 0 ; LCCT := 0 ; ODE XX 0 XP ;
      LOOP I 1 TWOND ; XP(I) := XP(I)*L ; ENDLOOP ;
      LOOP I 1 TWOND ; DAFLO XP DD(I) RES TWOND ; MSC(I) := RES ; ENDLOOP ;
      IF LSPN=1 ; SPNFLO ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE SYSCLM IAP L0 B0 D0 AA FF LL ; {COMPUTES SYMPLECTICALLY SCALED MAP}
      VARIABLE FAC NM1 21 ; VARIABLE MAG NM1 ; VARIABLE I 1 ;
      VARIABLE C 1 TWOND ; VARIABLE LIN 2 ; VARIABLE P NM1 ; VARIABLE PR 1 ;
      VARIABLE COP NM1 NV ; VARIABLE BT 100 ; VARIABLE J 1 ; VARIABLE EP NM1 ;
      VARIABLE MP NM1 ; VARIABLE ZP NM1 ; VARIABLE KD NM1 NV ; VARIABLE F NM1 ;
     {21 CORRESPONDS TO THE MAXIMAL ORDER OF REF. REP. + 1}
      FUNCTION PE E M ; PE := SQRT(E*(E+2*AMUMEV*M)) ; ENDFUNCTION ;
      IF (CONS(B0)=0)+(CONS(Z0)=0) ;
        LOOP I 1 NV ; IAP(I) := XX(I) ; ENDLOOP ; DLACT IAP L0 ;
      ELSEIF TRUE ;
        EP := E0 ; MP := M0 ; ZP := Z0 ;
        I := CONS(P0)/CONS(B0)/CONS(Z0)/CONS(D0) ; J := PE(AA(4),AA(5))/
        AA(2)/AA(6)/AA(3) ;
        IF ABS(I)>100*ABS(J) ;
           LOOP I 1 NV ; IAP(I) := XX(I) ; ENDLOOP ; DLACT IAP L0 ;
        ELSEIF TRUE ; IF ABS(I)*100<ABS(J) ; WRITE 6 (' --- WARNING in SYSCLM,'&
             ' large deviation from scaling map: '&S(ABS((I-J)/(I+J)))) ; ENDIF;
     {COMPUTE SCALING PARAMETERS}
          MAG := D0/AA(3) ; PR := PE(AA(4),AA(5)) ;
          BT := PR/PE(CONS(E0),CONS(M0)) ; LIN := (ND<3)*(NV#TWOND) ;
          IF LIN ; BT := BT*CONS(Z0)/AA(6)*CONS(MAG)*CONS(B0)*PARA(1) ;
          ELSEIF TRUE ; BT := BT*Z0/AA(6)*MAG*B0 ; ENDIF ;
          FAC(1) := BT/AA(2)-1 ;
          LOOP I 2 AA(8) ; FAC(I) := FAC(I-1)*FAC(1) ; ENDLOOP ;
          CO NOC+1 ; F := FF(1) ; P := LL(1) ; LOOP I 1 AA(8) ;
          F := F + FF(I+1)*FAC(I) ; P := P + LL(I+1)*FAC(I) ; ENDLOOP ;
          CO NOC-1 ; GFM IAP F AA(7) ; LOOP I 1 TWOND ; C(I) := 0 ; ENDLOOP ;
          IF LFR=1.9 ; LOOP I 1 TWOND ; IAP(I) := DD(I) ; ENDLOOP ; ENDIF ;
          LFM IAP C IAP P -1 ;
     {SCALE MAP}
          RP AA(4) AA(5) AA(6) ; CATR IAP IAP AA(1) ;
          LOOP I 1 NV ; COP(I) := DD(I) ; ENDLOOP ;
          LOOP I 1 TWOND 2 ; COP(I) := DD(I)/MAG ; ENDLOOP ;
          POLVAL 1 IAP TWOND COP NV IAP TWOND ;
          LOOP I 1 TWOND 2 ; IAP(I) := MAG*IAP(I) ; ENDLOOP ;
          IF LIN ; RP CONS(EP) CONS(MP) CONS(ZP) ;
          ELSEIF TRUE ; RP EP MP ZP ; ENDIF ;
          IF LFR<0 ; TRCA IAP IAP 0 ;
          ELSEIF TRUE ; TRCA IAP IAP L0 ; ENDIF ;
          IF LIN ; RP EP MP ZP ; BDEP IAP L0 1 ; ENDIF ; ENDIF ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE RSM IU L0 B0 D0 ;                 {READS SYMPLECTICALLY SCALED MAP}
      VARIABLE FF NM1 10 ; VARIABLE LL NM1 10 ; VARIABLE AA 1 10 ;
      SYSCFL IU AA FF LL -1 ; SYSCLM MSC L0 B0 D0 AA FF LL ;
      LOCSET 0 L0 0 L0 0 0 ; UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE FFELE L D H LF1 LF2 CI ;              {ELEMENTS WITH OR WITHOUT FF}
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
      VARIABLE LLPI 1 ; VARIABLE I 1 ; VARIABLE J 1 ;
      PROCEDURE SYSCFF IE ;
         VARIABLE FF NM1 10 ; VARIABLE LL NM1 10 ; VARIABLE AA 1 10 ;
         VARIABLE NAP NM1 MAX(8,NV) ; VARIABLE B0 5 ;
         UMS ; LOOP I 1 MIN(6,NPOL) ; B0 := SIG(PPOL(I)*CONS(Z0))*PPOL(I) ;
            LOOP J 2 MOD(MPOL(I),20) ; B0 := B0*D ; ENDLOOP ; CO NOC+1 ;
            LOOP J 1 10 ;
               FF(J) :=   GFF2(IE,MOD(MPOL(I),20),J) ;
               LL(J) :=   LFF2(IE,MOD(MPOL(I),20),J) ;
               AA(J) := DATFF2(IE,MOD(MPOL(I),20),J) ; ENDLOOP ;
            CO NOC-1 ; SYSCLM NAP 0 B0 D AA FF LL ;
            IF CONS(PPOL(I)*Z0)<0 ; MT NAP NAP 180/MOD(MPOL(I),20) ; ENDIF ;
            ANM NAP MSC MSC ; ENDLOOP ; ENDPROCEDURE ;
      CE := CI ; DR := D ;
      IF LFR=0 ; SIELE L D ;                                   {NO FRINGE FIELD}
         IF H=0 ; LOCSET 0 L 0 L 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(H*L)-1)/H SIN(H*L)/H H*L L 0 0 ; ENDIF ; UPDATE 1 1 ;
      ELSEIF LFR=1 ;                    {WITH SOFT EDGE FRINGE FIELD, TWO STEPS}
         UMS ; DLACT MSC -4*D ; SNM MSC MS ; SSNM SSCR SM ;
         LOCSET 0 -4*D 0 -4*D 0 0 ; NSDP := LF1 ;
         SDELE -4*D 0 4*D 4*D 4*D D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SDELE  0 2*D 2*D 2*D 2*D D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SIELE L-4*D D ; UPDATEMAP MSC MS MS SSCR SM SM ; NSDP := LF2 ;
         IF H=0 ; LOCSET 0 -2*D 0 -2*D 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(2*H*D)-1)/H -SIN(2*H*D)/H -2*H*D -2*D 0 0 ; ENDIF ;
         SDELE -2*D 0 2*D 2*D 2*D D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SDELE 0 4*D 4*D 4*D 4*D D ;  UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         DLACT MSC -4*D ;
         IF H=0 ; LOCSET 0 L 0 L 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(H*L)-1)/H SIN(H*L)/H H*L L 0 0 ; ENDIF ; UPDATE 1 1 ;
      ELSEIF (LFR=1.9)+(LFR=2) ;            {SYMPLECTICALLY SCALED FRINGE FIELD}
         IF SS(CE,1,1)#'M' ; WRITE 6
            ' *** ERROR, FR 2 or 1.9 with non magnetic element' ; QUIT 0 ;
            ENDIF ;
         J := 0 ; LOOP I 1 NPOL ; J := MAX(J,MOD(MPOL(I),20)) ; ENDLOOP ;
         IF J>6 ; WRITE 6
            ' --- WARNING, MPOL>6 for LFR='&SF(LFR,'(F3.1)') ; ENDIF ;
         SYSCFF 1 ; SNM MSC MS ; SSNM SSCR SM ;
         SIELE L D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SYSCFF 2 ; UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         IF H=0 ; LOCSET 0 L 0 L 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(H*L)-1)/H SIN(H*L)/H H*L L 0 0 ; ENDIF ; UPDATE 1 1 ;
      ELSEIF (LFR=3)+(LFR=2.5) ;   {WITH SOFT EDGE FRINGE FIELD, HIGH PRECISION}
         UMS ; DLACT MSC -8*D ; SNM MSC MS ; SSNM SSCR SM ;
         LOCSET 0 -8*D 0 -8*D 0 0 ; NSDP := LF1 ;
         SDELE -8*D 6*D D/200 D 7*D D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SIELE L-12*D D ; UPDATEMAP MSC MS MS SSCR SM SM ; NSDP := LF2 ;
         IF H=0 ; LOCSET 0 -6*D 0 -6*D 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(6*H*D)-1)/H -SIN(6*H*D)/H -6*H*D -6*D 0 0 ; ENDIF ;
         SDELE -6*D 8*D D/200 D 7*D D ; UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         DLACT MSC -8*D ;
         IF H=0 ; LOCSET 0 L 0 L 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(H*L)-1)/H SIN(H*L)/H H*L L 0 0 ; ENDIF ; UPDATE 1 1 ;
      ELSEIF LFR=-1 ;    {SOFT EDGE ENTRANCE FRINGE FIELD ALONE, HIGH PRECISION}
         UMS ; DLACT MSC -8*D ; SNM MSC MS ; SSNM SSCR SM ;
         LOCSET 0 -8*D 0 -8*D 0 0 ; NSDP := LF1 ;
         SDELE -8*D 6*D D/200 D 7*D D ; UPDATEMAP MSC MS MS SSCR SM SM ;
         SIELE -6*D D ; UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         LOCSET 0 0 0 0 0 0 ;
         LLPI := LPI ; LPI := 0 ; UPDATE 1 1 ; LPI := LLPI ;
      ELSEIF LFR=-2 ;    {SOFT EDGE EXIT     FRINGE FIELD ALONE, HIGH PRECISION}
         SIELE -6*D D ; SNM MSC MS ; SSNM SSCR SM ; NSDP := LF2 ;
         IF H=0 ; LOCSET 0 -6*D 0 -6*D 0 0 ; ELSEIF H#0 ;
            LOCSET (COS(6*H*D)-1)/H -SIN(6*H*D)/H -6*H*D -6*D 0 0 ; ENDIF ;
         SDELE -6*D 8*D D/200 D 7*D D ; UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         DLACT MSC -8*D ; LOCSET 0 0 0 0 0 0 ;
         LLPI := LPI ; LPI := 0 ; UPDATE 1 1 ; LPI := LLPI ;
      ELSEIF LFR=-10 ;                                     {NO FRINGE FIELD, RK}
         LOCSET 0 0 0 0 0 0 ; SDELE 0 L D/200 D 7*D D ; UPDATE 1 1 ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR, wrong fringe field ID' ; QUIT 0 ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE CB ;                                     {CHANGE BENDING DIRECTION}
      VARIABLE I 1 ;
      IF LUM=0 ; WRITE 6 ' *** ERROR, call UM before CB' ; QUIT 0 ; ENDIF ;
      MAP(1) := -MAP(1) ; MAP(2) := -MAP(2) ;
      RAY(1) := -RAY(1) ; RAY(2) := -RAY(2) ;
      RSC(1) := -RSC(1) ; RSC(2) := -RSC(2) ;
      IF LSPN=1 ; LOOP I 1 3 ; SPNR(1,I) := -SPNR(1,I) ; ENDLOOP ;
         SPI(1) := -SPI(1) ; SSC(1) := -SSC(1) ; ENDIF ;
      LCB := -LCB ; ENDPROCEDURE ;

   PROCEDURE GE N M S H V W ;             {LETS GENERAL S-DEPENDENT ELEMENT WITH
      S-DEPENDENCE DESCRIBED BY ARRAYS ACT ON MAP
      N: NUMBER OF SUPPORT POINTS,  M: NUMBER OF DERIVATIVES
      S: ARRAY OF N SUPPORT POINTS, H: ARRAY OF N CURVATURES AND M DERIVATIVES
      V, W: ARRAYS OF  OF N SUPPORT POINTS AND M DERIVATIVES OF DA'S
            DESCRIBING ELECTRIC AND MAGNETIC POTENTIALS}
      VARIABLE I 1 ; VARIABLE S1 1 ; VARIABLE S2 1 ; CO NOC+1 ; NSDP := 20 ;
      IF M<NOC ; WRITE 6 ' --- WARNING in GE, M < calculation order' ; ENDIF ;
      INTPOL PN M ; LOOP I 1 N ; SN(I) := S(I) ; HN(I) := H(I) ;
         VN(I) := V(I) ; WN(I) := W(I) ; ENDLOOP ; INP := 1 ; NN := N ;
      NPOL := 0 ; NPG := M ; S1 := CONS(S(1)) ; S2 := CONS(S(N)) ;
      LOCSET 0 0 0 0 0 0 ; CE := 'GE' ; LOFF := 2 ;
      SDELE S1 S2 (S2-S1)/100 (S2-S1)/10 (S2-S1) .1 ; UPDATE 1 1 ; CO NOC-1 ;
      ENDPROCEDURE ;

{MAGNETIC ELEMENTS}
{-----------------}

   PROCEDURE MQ L B D ;
      PROCEDURE MQUAD IAP L F AP ;
         VARIABLE C 1 ; VARIABLE OM1 1 ; VARIABLE OM2 NMP ; VARIABLE FI NM1 ;
         VARIABLE FP  NM1 ; VARIABLE N NM1 ; VARIABLE OM NM1 ;
         PROCEDURE MAPY C X Y ; N := IAP(C) ; IAP(C) := IAP(C)*X+IAP(C+1)/FP*Y ;
           IF C=1 ; IAP(C+1) := -FP*N*Y+IAP(C+1)*X ; ELSEIF C=3 ;
                    IAP(C+1) :=  FP*N*Y+IAP(C+1)*X ; ENDIF ; ENDPROCEDURE ;
         IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before MQ' ; QUIT 0 ;
         ENDIF ; IF ABS(CONS(F))<1E-15 ; DLACT IAP L ; ELSEIF TRUE ;
         FI := F ; IF CONS(F*Z0)<0 ; FI := -F ; N := IAP(1) ;
         IAP(1) := IAP(3) ; IAP(3) := N ; N := IAP(2) ; IAP(2) := IAP(4) ;
         IAP(4) := N ; ENDIF ; C := CONS(ETA) ; OM := SQRT(FI/(AP*CHIM)) ;
         OM1 := CONS(OM) ; OM2 := 2*OM1*L ;
         FP := SQRT((1+IAP(6))*((1+IAP(6))*C+2*(1+IAP(7)))/(C+2))*OM ;
         IF ND>2 ; N := IAP(3)*IAP(4)*(COSH(OM2)-1)+IAP(1)*IAP(2)*(COS(OM2)-1) ;
         N := N
             +SQR(IAP(2))*(L+.5/OM1*SIN(OM2))+SQR(IAP(4))*(L+.5/OM1*SINH(OM2)) ;
         N := N+(SQR(IAP(1))*(L-SIN(OM2)*.5/OM1)
                +SQR(IAP(3))*(-L+SINH(OM2)*.5/OM1))*SQR(OM1) ;
         IAP(5) := IAP(5)
               +((1+C)*(1-.25*N/L)-((1+IAP(7))+(1+IAP(6))*C)*OM/FP)/(2+C)*L ;
         ENDIF ; OM := OM*L ; MAPY 1 COS(OM) SIN(OM) ;
         MAPY 3 COSH(OM) SINH(OM) ; IF CONS(F*Z0)<0 ; N := IAP(1) ;
         IAP(1) := IAP(3) ; IAP(3) := N ; N := IAP(2) ; IAP(2) := IAP(4) ;
         IAP(4) := N ; ENDIF ; ENDIF ; ENDPROCEDURE ;
      IF (NOC<3)*(LFR=0)*(LSPN=0) ; MQUAD MAP L B D ;
         IF NRAY#0 ; UMS ; MQUAD MSC L B D ; ENDIF ;
         LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'MQ' ; UPDATE 0 1 ;
      ELSEIF TRUE ; NPOL := 1 ; PPOL(1) := B/D ; MPOL(1) := 2 ; LOFF := 1 ;
      FFELE L D 0 1 2 'MQ' ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE MH L B D ;
      PROCEDURE MHEXA IAP L F AP ;
         VARIABLE C 1 ; VARIABLE X NM1 ; VARIABLE XZ NM1 ; VARIABLE Y NM1 ;
         VARIABLE FP  NM1 ; VARIABLE FI NM1 ; C := CONS(ETA) ; IF LUM#1 ;
            WRITE 6 ' *** ERROR, call UM before MH' ; QUIT 0 ; ENDIF ;
         FP := SQRT((1+IAP(6))*((1+IAP(6))*C+2*(1+IAP(7)))/(C+2)) ;
         X  := IAP(1) ; XZ := IAP(2) ; Y := IAP(3) ; DLACT IAP L ;
         IF NO>1 ; FI := F/(3*SQR(AP)) ; C := CONS(CHIM) ;
         IAP(1) := IAP(1) - FI/C*1.5*SQR(L)*(SQR(X)-SQR(Y)
         +2/3*L*(X*XZ-Y*IAP(4)+.25*L*(SQR(XZ)-SQR(IAP(4))))) ;
         IAP(2) := IAP(2) - FI/C*L*3*(SQR(X)-SQR(Y)
         +L*(X*XZ-Y*IAP(4)+1/3*L*(SQR(XZ)-SQR(IAP(4))))) ;
         IAP(3) := IAP(3)+FI/C*SQR(L)*(3*X*Y+L*(Y*XZ+X*IAP(4)+.5*L*XZ*IAP(4))) ;
         IAP(4) := IAP(4) + FI/C*L*(6*X*Y+L*(3*(Y*XZ+X*IAP(4))+2*L*XZ*IAP(4))) ;
         ENDIF ; ENDPROCEDURE ;
      IF (NOC<3)*(LFR=0)*(LSPN=0) ; MHEXA MAP L B D ;
         IF NRAY#0 ; UMS ; MHEXA MSC L B D ; ENDIF ;
         LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'MH' ; UPDATE 0 1 ;
      ELSEIF TRUE ; NPOL := 1 ; PPOL(1) := B/D/D ; MPOL(1) := 3 ; LOFF := 1 ;
      FFELE L D 0 1 2 'MH' ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE MO L B D ; NPOL := 1 ; PPOL(1) := B/D/D/D ; MPOL(1) := 4 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MO' ; ENDPROCEDURE ;

   PROCEDURE MD L B D ; NPOL := 1 ; PPOL(1) := B/D/D/D/D ; MPOL(1) := 5 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MD' ; ENDPROCEDURE ;

   PROCEDURE MZ L B D ; NPOL := 1 ; PPOL(1) := B/D/D/D/D/D ; MPOL(1) := 6 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MZ' ; ENDPROCEDURE ;

   PROCEDURE M5 L BQ BH BO BD BZ D ;                        {MAGNETIC MULTIPOLE}
      PPOL(1) := BQ/D ;                      MPOL(1) := 2 ;
      PPOL(2) := BH/D/D ;                    MPOL(2) := 3 ;
      PPOL(3) := BO/D/D/D ;                  MPOL(3) := 4 ;
      PPOL(4) := BD/D/D/D/D ;                MPOL(4) := 5 ;
      PPOL(5) := BZ/D/D/D/D/D ;              MPOL(5) := 6 ;
      LOFF := 1 ; NPOL := 5 ; FFELE L D 0 1 2 'M5' ;  ENDPROCEDURE ;

   PROCEDURE MM L BA NBA D ;                                {MAGNETIC MULTIPOLE}
      VARIABLE I 1 ; VARIABLE DP NM2 ; DP := 1 ;
      LOOP I 1 NBA ; DP := DP/D ; PPOL(I) := BA(I)*DP ;
         MPOL(I) := I+1 ; ENDLOOP ;
      LOFF := 1 ; NPOL := NBA ; FFELE L D 0 1 2 'MM' ;  ENDPROCEDURE ;

   PROCEDURE MMS L BA BS NB D ;                        {SKEW MAGNETIC MULTIPOLE}
      VARIABLE I 1 ; VARIABLE DP NM2 ; DP := 1 ; LOOP I 1 NB ; DP := DP/D ;
         PPOL(I) := BA(I)*DP ; MPOL(I) := I+1 ; ENDLOOP ; DP := 1 ;
      LOOP I 1 NB ; DP := DP/D ;
         PPOL(I+NB) := BS(I)*DP/(I+1) ; MPOL(I+NB) := I+1+20 ; ENDLOOP ;
      LOFF := 1 ; NPOL := 2*NB ; FFELE L D 0 1 2 'MMS' ;  ENDPROCEDURE ;

   PROCEDURE MQK L K D ; MQ L K*CONS(CHIM)*D   D ; ENDPROCEDURE ;

   PROCEDURE MSK L K D ; MH L K*CONS(CHIM)*D*D D ; ENDPROCEDURE ;

   PROCEDURE MOK L K D ; NPOL := 1 ; PPOL(1) := K*CONS(CHIM) ; MPOL(1):=4 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MOK' ; ENDPROCEDURE ;

   PROCEDURE MDK L K D ; NPOL := 1 ; PPOL(1) := K*CONS(CHIM) ; MPOL(1):=5 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MDK' ; ENDPROCEDURE ;

   PROCEDURE MZK L K D ; NPOL := 1 ; PPOL(1) := K*CONS(CHIM) ; MPOL(1):=6 ;
      LOFF := 1 ; FFELE L D 0 1 2 'MZK' ; ENDPROCEDURE ;

   PROCEDURE MMK L BA NBA D ; VARIABLE I 1 ; VARIABLE DP NM3 ;
      LOOP I 1 NBA ; PPOL(I) := BA(I)*CONS(CHIM) ; MPOL(I) := I+1 ; ENDLOOP ;
      LOFF := 1 ; NPOL := NBA ; FFELE L D 0 1 2 'MMK' ; ENDPROCEDURE ;

   PROCEDURE MMSK L KA TA NA D ; VARIABLE I 1 ; VARIABLE DP NM3 ;
      VARIABLE BS NM3 ; DP := 1 ; LOOP I 1 NA ; DP := DP*D ;
         KA(I) := KA(I)*CONS(CHIM)*DP ; BS := KA(I)*SIN((I+1)*TA(I)*DEGRAD) ;
         KA(I) := KA(I)*COS((I+1)*TA(I)*DEGRAD) ; TA(I) := BS ; ENDLOOP ;
      MMS L KA TA NA D ; ENDPROCEDURE ;

   PROCEDURE MGE NP A NS DS SIGMA D ;               {GENERAL MAGNETIC MULTIPOLE}
      VARIABLE I 1 ; VARIABLE IS 1 ; VARIABLE S2 1 ;
      LOOP I 1 NP ; MPOL(I) := I+1 ;
         LOOP IS 1 NS ; MFD(I,IS) := A(I,IS)/(D^I) ; ENDLOOP ; ENDLOOP ;
      PPOL(1) := NS ; PPOL(2) := DS ; PPOL(3) := SIGMA ;
      NSDP := 12 ; LOFF := 1 ; NPOL := NP ; S2 := (NS-1)*DS ;
      LOCSET 0 0 0 0 0 0 ; CE := 'MGE' ; DR := D ;
      SDELE 0 S2 D/200 1*D 7*D D ; UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE BEND R PHI D E1 H1 E2 H2 N S1 S2 NT ;              {GENERAL MAGNET}
      VARIABLE I 1 ; VARIABLE NTS 1 ; VARIABLE F NMP ; VARIABLE LPIP 1 ;
      VARIABLE S1N NMP MAX(NOC,NT) ; VARIABLE S2N NMP MAX(NOC,NT) ;
      VARIABLE E1N NMP ; VARIABLE E2N NMP ; VARIABLE H1N NMP ;
      VARIABLE H2N NMP ; VARIABLE NAP NM1 MAX(NV,8) ; VARIABLE AA 1 10 ;
      VARIABLE FF NM1 10 ; VARIABLE LL NM1 10 ;
      FUNCTION FK X E XI ;                                        {CIRCLE FK(X)}
         IF CONS(XI)#0 ; FK := (COS(E)-SQRT(1-SQR(X*XI+SIN(E))))/XI ;
         ELSEIF TRUE ; FK := TAN(E)*X ; ENDIF ; ENDFUNCTION ;
      PROCEDURE SNS S E H SN NT ;   {CIRCLE E,H,SN OF ORDERS>3 SN FROM POLYN. S}
         VARIABLE I 1 ; VARIABLE L 1 ; VARIABLE F NM1 ;
         E := 0 ; H := 0 ; IF NT>0 ; E := ATAN(S(1)) ; IF NT>1 ;
         H := 1+SQR(S(1)) ; H := 2*S(2)/SQRT(H)/H ; ENDIF ; ENDIF ;
         F := FK(DD(1),E,H) ; L := 1 ; LOOP I 1 NT ; L := L*I ;
         F := DER(1,F) ; SN(I) := S(I)-CONS(F)/L ; ENDLOOP ;
         LOOP I NT+1 NTS ; L := L*I ; F := DER(1,F) ; SN(I) := -CONS(F)/L ;
         ENDLOOP ; ENDPROCEDURE ;
      PROCEDURE KICK I F IAP ; VARIABLE A NM1 1 ; VARIABLE NAP NM1 NV ;   {KICK}
         VARIABLE J 1 ; LOOP J 1 NV ; NAP(J) := DD(J) ; ENDLOOP ;
         NAP(1) := IAP(1) ; IF ND>1 ; NAP(3) := IAP(3) ; ENDIF ;
         IF I=1 ; A(1) := F ;
         ELSEIF I=2 ; A(1) := -DER(1,F)*DD(3) ; NAP(1) := 0*NAP(1) ; ENDIF ;
         POLVAL 1 A 1 NAP NV A 1 ; IAP(2*I) := IAP(2*I)+A(1) ; ENDPROCEDURE ;
      FUNCTION POL X CO NT ; VARIABLE I 1 ; POL := 0 ; LOOP I NT 1 -1 ;
         POL := (POL+CO(I))*X ; ENDLOOP ; ENDFUNCTION ;
      PROCEDURE KICKSXYN SN IAP ;          {X AND Y KICK F FOR INHOMOG. MAGNETS}
         VARIABLE F NM1 ; F := POL(DD(1),SN,NTS) ;
         KICK 1 F/R IAP ; KICK 2 F/R IAP ; ENDPROCEDURE ;
      PROCEDURE BENDFF3 ;                            {MAGNET WITH FRINGE FIELDS}
         VARIABLE LDL 1 ; VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
         NSDP := -4 ; LOFF := 2 ;
         PPOL( 1) := CONS(CHIM)/R ; PPOL( 2) := -R ; PPOL( 3) := 0 ;
         PPOL( 4) := D ;   PPOL( 5) := 0 ;   PPOL( 6) := 0 ;
         PPOL( 7) := SIN(-E1N) ;     PPOL( 8) :=  COS(-E1N) ;
         IF H1N#0 ; PPOL( 7) := PPOL( 7)/H1N ; PPOL( 8) :=  PPOL( 8)/H1N ;
            ENDIF ; PPOL( 9) := R*(COS(PHI) - 1) ; PPOL(10) :=  R*SIN(PHI) ;
         PPOL(11) := SIN(PHI-E2N) ; PPOL(12) := -COS(E2N-PHI) ;
         IF H2N#0 ; PPOL(11) := PPOL(11)/H2N ; PPOL(12) :=  PPOL(12)/H2N ;
            ENDIF ; PPOL(11) := PPOL(11) + PPOL(9) ;
         PPOL(12) := PPOL(12) + PPOL(10) ; PPOL(13) := H1N ; PPOL(14) := H2N ;
         LOOP I 1 NT ; PPOL(20+I) := N(I) ; ENDLOOP ; PPOL(20) := NT ;
         LDL := 10*D ; LOCSET 0 -LDL 0 0 0 0 ;
         IF LFR=3 ;
            LOCSET R*(COS(0.5*PHI)-1) R*SIN(0.5*PHI) 0.5*PHI 0.5*R*PHI 0 0 ;
            SDELEREF 0.5*R*PHI -LDL D/200 D 7*D D ; ENDIF ;
         UMS ; DLACT MSC -LDL ; SNM MSC MS ; SSNM SSCR SM ;
         SDELE 0 R*PHI+2*LDL MIN(R/10000,D/200) MIN(R/20,D) MIN(R,7*D) D ;
         UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         DLACT MSC -LDL ; SLOC := R*PHI ;
         XLOC := XLOC+LDL*SIN(PLOC) ; ZLOC := ZLOC-LDL*COS(PLOC) ;
         UPDATE 1 1 ; ENDPROCEDURE ;
      PROCEDURE BENDFF0 ;                         {MAGNET WITHOUT FRINGE FIELDS}
         VARIABLE LGH 10 ; VARIABLE F NOC+1 ; VARIABLE ISC NM1 MAX(8,NV) ;
         VARIABLE XP NM2 MAX(8,NV) ; VARIABLE RES NM1 ;
         PROCEDURE DIPOLE R0 PHI E1 XI1 E2 XI2 IN OUT LGH ; {GEOMETRIC SOLUTION}
            VARIABLE IER 1 ; VARIABLE Z1 NM1 ; VARIABLE X1 NM1 ;
            VARIABLE R NM1 ; VARIABLE ZRI NM1 ; VARIABLE XRI NM1 ;
            VARIABLE ZR NM1 ; VARIABLE XR NM1 ; VARIABLE Z2 NM1 ;
            VARIABLE X2 NM1 ; VARIABLE ZA NM1 ; VARIABLE XA NM1 ;
            VARIABLE ZB NM1 ; VARIABLE XB NM1 ; VARIABLE CO NM1 ;
            VARIABLE SI NM1 ; VARIABLE THE NM1 ; VARIABLE ST1 NM1 ;
            VARIABLE ST2 NM1 ; VARIABLE LN NM1 ; VARIABLE NC 1 ;
            VARIABLE PC 1 ; VARIABLE VC 1 ; VARIABLE MG NM1 ;
            FUNCTION RADI X Y ; RADI := SQRT(SQR(X)+SQR(Y)) ; ENDFUNCTION ;
            PROCEDURE CAPO X Y PHI IER ; VARIABLE XC 1 ; VARIABLE YC 1 ;
               VARIABLE TINY 1 ; TINY := 1E-16 ; XC := CONS(X) ; YC := CONS(Y) ;
               IF (ABS(XC)+ABS(YC))<TINY ; PHI := 0 ; IER := 1 ;
               ELSEIF TRUE ; IER := 0 ; IF ABS(XC)>ABS(YC) ; PHI := ATAN(Y/X) ;
               IF (XC<0)*(YC<0) ; PHI := PHI-PI ; ELSEIF TRUE ; PHI := PHI+PI ;
               ENDIF ; ELSEIF TRUE ; PHI := PI/2-ATAN(X/Y) ; IF YC<0 ;
               PHI := PHI-PI ; ENDIF ; ENDIF ; ENDIF ; ENDPROCEDURE ;
            PROCEDURE EQ2 A B C Z1 Z2 ;                           {AX^2-2BX-C=0}
               IF (CONS(A)=0)+(SQR(CONS(B))+CONS(C)*CONS(A)<0) ;
               WRITE 6 ' *** ERROR in DIPOLE, no solution' ; QUIT 0 ; ENDIF ;
               Z1 := B/A ; Z2 := SQRT(SQR(Z1)+C/A) ; ENDPROCEDURE ;
            PROCEDURE LINLIN A1 B1 C1 A2 B2 C2 X Y ; {A1X+B1Y+C1=0,A2X+B2Y+C2=0}
               VARIABLE D NM1 ; VARIABLE TINY 1 ; TINY := 1E-16 ;
               D := A1*B2-A2*B1 ; IF ABS(CONS(D))<TINY ;
               WRITE 6 ' *** ERROR in DIPOLE, no solution' ; QUIT 0 ; ENDIF ;
               X := (B1*C2-B2*C1)/D ; Y := (A2*C1-A1*C2)/D ; ENDPROCEDURE ;
            PROCEDURE LINCIR A B C XR YR R X1 Y1 X2 Y2 ;
              {AX+BY+C=0,(X-XR)^2+(Y-YR)^2=R^2} VARIABLE A1 NM1 ;
               VARIABLE C1 NM1 ; VARIABLE Z1 NM1 ; VARIABLE Z2 NM1 ;
               IF ABS(CONS(B))>ABS(CONS(A)) ; A1 := A/B ; C1 := C/B ;
               EQ2 1+SQR(A1) XR-A1*(YR+C1) SQR(R)-SQR(XR)-SQR(YR+C1) Z1 Z2 ;
               X1 := Z1-Z2 ; X2 := Z1+Z2 ; Y1 := -A1*X1-C1 ; Y2 := -A1*X2-C1 ;
               ELSEIF TRUE ; A1 := B/A ; C1 := C/A ;
               EQ2 1+SQR(A1) YR-A1*(XR+C1) SQR(R)-SQR(YR)-SQR(XR+C1) Z1 Z2 ;
               Y1 := Z1-Z2 ; Y2 := Z1+Z2 ; X1 := -A1*Y1-C1 ; X2 := -A1*Y2-C1 ;
               ENDIF ; ENDPROCEDURE ;
            PROCEDURE CIRCIR XR1 YR1 R1 XR2 YR2 R2 X1 Y1 X2 Y2 ;
              {(X-XR1)^2+(Y-YR1)^2=R1^2,(X-XR2)^2+(Y-YR2)^2=R2^2}
               VARIABLE C NM1 ;
               C := (SQR(R2)-SQR(XR2)-SQR(YR2))-(SQR(R1)-SQR(XR1)-SQR(YR1)) ;
               LINCIR 2*(XR2-XR1) 2*(YR2-YR1) C XR1 YR1 R1 X1 Y1 X2 Y2 ;
               ENDPROCEDURE ;
            PC := CONS(P0) ; MG := SQRT(SQR(P0/PC)-SQR(IN(2))-SQR(IN(4))) ;
            IN(2) := IN(2)/MG ; IN(4) := IN(4)/MG ;
        {FIND \VEC(W1)}
            CO := COS(E1) ; SI := SIN(E1) ;
            IF CONS(XI1)#0 ; R := 1/XI1 ; ZR := CO/XI1 ; XR := -SI/XI1 ;
            LINCIR IN(2) -1 IN(1) ZR XR R ZA XA ZB XB ;
               IF CONS(XI1)>0 ; Z1 := ZA ; X1 := XA ;
               ELSEIF TRUE ; Z1 := ZB ; X1 := XB ; ENDIF ;
            ELSEIF TRUE ; LINLIN IN(2) -1 IN(1) CO -SI 0 Z1 X1 ; ENDIF ;
        {FIND \VEC(R)}
            ST1 := 1+SQR(IN(2)) ; IF ND=1 ; ST1 := SQRT(ST1) ; ST2 := ST1 ;
            ELSEIF ND>1 ; ST2 := SQRT(ST1+SQR(IN(4))) ; ST1 := SQRT(ST1) ;
            ENDIF ; R := R0*P0/PC*CONS(Z0)/Z0*ST1/ST2 ;
            XRI := X1-R/ST1 ; ZRI := Z1+R*IN(2)/ST1 ;
        {NEW COORDINATES}
            CO := COS(PHI) ; SI := SIN(PHI) ; Z2 := R0*SI ; X2 := R0*(CO-1) ;
            ZR := (ZRI-Z2)*CO - (XRI-X2)*SI ;
            XR := (XRI-X2)*CO + (ZRI-Z2)*SI ;
        {FIND \VEC(W2)}
            CO := COS(E2) ; SI := SIN(E2) ;
            IF CONS(XI2)#0 ; THE := 1/XI2 ; Z2 := -CO/XI2 ; X2 := -SI/XI2 ;
            CIRCIR ZR XR R Z2 X2 THE ZA XA ZB XB ; ELSEIF TRUE ;
               LINCIR CO SI 0 ZR XR R ZA XA ZB XB ; ENDIF ;
            IF RADI(CONS(ZA),CONS(XA))<RADI(CONS(ZB),CONS(XB)) ;
            Z2 := ZA ; X2 := XA ; ELSEIF TRUE ; Z2 := ZB ; X2 := XB ;
            ENDIF ; CAPO X1-XRI Z1-ZRI X1 IER ; CAPO X2-XR Z2-ZR THE IER ;
            THE := PHI+THE-X1 ; X1 := -(Z2-ZR)/(X2-XR) ;
        {FIND \VEC(WF)}
            LINLIN X1 -1 X2-Z2*X1 1 0 0 ZRI XRI ; OUT(1) := XRI ; OUT(2) := X1 ;
            LGH := R0*PHI ; LN := Z1*ST1 + R*THE - Z2*SQRT(1+SQR(OUT(2))) ;
            IF ND>1 ; OUT(3) := IN(3)+IN(4)*LN/ST1 ;
               OUT(4) := IN(4)*SQRT(1+SQR(OUT(2)))/ST1 ; ENDIF ;
            MG := SQRT(1+SQR(OUT(2))+SQR(OUT(4)))*PC/P0 ;
            OUT(2) := OUT(2)/MG ; OUT(4) := OUT(4)/MG ;
            IF ND>2 ;NC := CONS(ETA) ; VC := CONS(V0) ;
            MG := -(1+NC)/(2+NC)*VC/V0 ;
            OUT(5) := IN(5)+(LN*ST2/ST1-V0/VC*LGH)*MG ; OUT(6) := IN(6) ;
            ENDIF ; ENDPROCEDURE ;
         PROCEDURE DIPOLEY R0 PHI E1 XI1 E2 XI2 IN OUT LGH ;  {Y KICK TO DIPOLE}
            KICK 2 FK(DD(1),E1,XI1)/R0 IN ;
            DIPOLE R0 PHI E1 XI1 E2 XI2 IN OUT LGH ;
            KICK 2 FK(DD(1),E2,XI2)/R0 OUT ; ENDPROCEDURE ;
         IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before element' ;
         QUIT 0 ; ENDIF ;
         IF (NT=0)*(LSPN=0) ; DIPOLEY R PHI E1 H1 E2 H2 MSC MSC LGH ;
         ELSEIF TRUE ;
            NPOL := NT+1 ;  PPOL(1) :=  CONS(CHIM)/R ; MPOL(1) := 1 ;
            F := 1/R ; LOOP I 2 NPOL ; PPOL(I) := -PPOL(1)*N(I-1)*F ;
            MPOL(I) := I ; F := F/R ; ENDLOOP ; LOFF := 2 ;
            DIPOLEY R 0 E1N H1N 0 0 MSC ISC LGH ;
            LOOP I TWOND+1 MIN(NV,8) ; ISC(I) := MSC(I) ; ENDLOOP ;
            SIELE R*PHI D ; POLVAL 1 MSC TWOND ISC MIN(NV,8) MSC TWOND ;
            DIPOLEY R 0 0 0 E2N H2N MSC MSC LGH ; ENDIF ; ENDPROCEDURE ;
      IF CONS(R)<0 ; WRITE 6 ' *** ERROR in '&CE&' BEND, negative radius' ;
         QUIT 0 ;
      ELSEIF CONS(PHI)<0; WRITE 6 ' *** ERROR in '&CE&' BEND, negative angle' ;
         QUIT 0 ;
      ELSEIF (ABS(E1)+ABS(E2)+ABS(H1)+ABS(H2)#0)*(NT#0) ; WRITE 6
         ' @@@ ERROR in '&CE&' BEND, wrong parameters' ; QUIT 0 ; ENDIF ;
      DR := D ;
      LOOP I 1 8 ; MSC(I) := DD(I) ; ENDLOOP ;
      IF (NRAY=0)*(LSPN=0) ; LOOP I 1 TWOND ; MSC(I) := MAP(I) ; ENDLOOP ;
         ENDIF ; NTS := NOC ; E1N := E1 ; H1N := H1 ; E2N := E2 ; H2N := H2 ;
      IF (LFR=3)+(LFR=2.5) ;
         IF NT#0 ; SNS S1 E1N H1N S1N NT ; SNS S2 E2N H2N S2N NT ;
            UMS ; KICKSXYN S1N MSC ; LPIP := LPI ; LPI := 0 ;
            LOCSET 0 0 0 0 0 0 ; UPDATE 1 1 ; LPI := LPIP ; ENDIF ;
         BENDFF3 ;
         IF NT#0 ; UMS ; KICKSXYN S2N MSC ; LPI := 0 ;
            LOCSET 0 0 0 0 0 0 ; UPDATE 1 1 ; LPI := LPIP ; ENDIF ;
      ELSEIF (LFR=-1)+(LFR=-2) ;
         NPOL := NT+1 ;  PPOL(1) :=  CONS(CHIM)/R ; F := 1/R ; MPOL(1) := 1 ;
         LOOP I 2 NPOL ; PPOL(I) := -PPOL(1)*N(I-1)*F ; MPOL(I) := I ;
            F := F/R ; ENDLOOP ; LOFF := 2 ; FFELE R*PHI D 1/R -1 -2 '  ' ;
      ELSEIF TRUE ;
         IF NT#0 ; SNS S1 E1N H1N S1N NT ; SNS S2 E2N H2N S2N NT ;
            KICKSXYN S1N MSC ; ENDIF ;
         IF LFR=0 ; BENDFF0 ;
         ELSEIF (LFR=1)+(LFR=1.9)+(LFR=2) ;
            CO NOC+1 ; LOOP I 1 10 ; AA(I) := DATFF2(1,1,I) ;
            FF(I) := GFF2(1,1,I) ; LL(I) := LFF2(1,1,I) ; ENDLOOP ; CO NOC-1 ;
            SYSCLM NAP 0 CONS(P0)*1E6/CLIGHT/CONS(Z0)/R D AA FF LL ;
            ANM NAP MSC MSC ;
            BENDFF0 ;
            CO NOC+1 ; LOOP I 1 10 ; AA(I) := DATFF2(2,1,I) ;
            FF(I) := GFF2(2,1,I) ; LL(I) := LFF2(2,1,I) ; ENDLOOP ; CO NOC-1 ;
            SYSCLM NAP 0 CONS(P0)*1E6/CLIGHT/CONS(Z0)/R D AA FF LL ;
            ANM NAP MSC MSC ;
         ELSEIF LO(1) ; WRITE 6
            ' *** ERROR in '&CE&' BEND, FR '&S(LFR)&' not supported.' ; QUIT 0 ;
         ENDIF ;
         IF NT#0 ; KICKSXYN S2N MSC ; ENDIF ;
         LOCSET (COS(PHI)-1)*R SIN(PHI)*R PHI R*PHI 0 0 ;
         IF (NRAY=0)*(LSPN=0) ; LOOP I 1 TWOND ; MAP(I) := MSC(I) ; ENDLOOP ;
         UPDATE 0 1 ; ELSEIF TRUE ; UPDATE 1 1 ; ENDIF ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE DI R PHI D E1 H1 E2 H2 ;                 {DIPOLE WITH CURVED EDGES}
      CE := 'DI' ; BEND R PHI*DEGRAD D E1*DEGRAD H1 E2*DEGRAD H2 0 0 0 0 ;
      ENDPROCEDURE ;

   PROCEDURE DP R PHI D ; VARIABLE PH 1 ;                {PARALLEL FACED DIPOLE}
      PH := PHI*DEGRAD ; CE := 'DP' ; BEND R PH D PH/2 0 PH/2 0 0 0 0 0 ;
      ENDPROCEDURE ;

   PROCEDURE MC R PHI D N S1 S2 NT ;       {COMBINED FUNCTION MAGNET WITH EDGES}
         CE := 'MC' ; BEND R PHI*DEGRAD D 0 0 0 0 N S1 S2 NT ;
         ENDPROCEDURE ;

   PROCEDURE MS R PHI D N1 N2 N3 N4 N5 ;              {COMBINED FUNCTION MAGNET}
      VARIABLE S1 1 5 ; VARIABLE S2 1 5 ; VARIABLE N NMP 5 ; VARIABLE I 1 ;
      LOOP I 1 5 ; S1(I) := 0 ; S2(I) := 0 ; ENDLOOP ;
      N(1) := N1 ; N(2) := N2 ; N(3) := N3 ; N(4) := N4 ; N(5) := N5 ;
      CE := 'MS' ; BEND R PHI*DEGRAD D 0 0 0 0 N S1 S2 5 ; ENDPROCEDURE ;

   PROCEDURE MSL L PHI D N1 N2 N3 N4 N5 ;             {COMBINED FUNCTION MAGNET}
      VARIABLE S1 1 5 ; VARIABLE S2 1 5 ; VARIABLE N NMP 5 ; VARIABLE I 1 ;
      IF PHI=0 ; DL L ; ELSEIF TRUE ;
      LOOP I 1 5 ; S1(I) := 0 ; S2(I) := 0 ; ENDLOOP ;
      N(1) := N1 ; N(2) := N2 ; N(3) := N3 ; N(4) := N4 ; N(5) := N5 ;
      CE := 'MSL' ; BEND L/PHI/DEGRAD PHI*DEGRAD D 0 0 0 0 N S1 S2 5 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE MPL L PHI D N1 N2 N3 N4 N5 ;    {PARALLEL COMBINED FUNCTION MAGNET}
      VARIABLE S1 1 5 ; VARIABLE S2 1 5 ; VARIABLE N NMP 5 ; VARIABLE I 1 ;
      VARIABLE PH 1 ;  IF PHI=0 ; DL L ; ELSEIF TRUE ;
      PH := PHI*DEGRAD ; S1(1) := TAN(PH/2) ; S2(1) := TAN(PH/2) ;
      LOOP I 2 5 ; S1(I) := 0 ; S2(I) := 0 ; ENDLOOP ;
      N(1) := N1 ; N(2) := N2 ; N(3) := N3 ; N(4) := N4 ; N(5) := N5 ;
      CE := 'MPL' ; BEND L/PH PH D 0 0 0 0 N S1 S2 5 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE DIL L PHI D E1 H1 E2 H2 ; IF PHI=0 ; DL L ; ELSEIF TRUE ;
      DI L/PHI/DEGRAD PHI D E1 H1 E2 H2 ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE MCLK L PHI D K S1 S2 NT ;
      VARIABLE I 1 ; VARIABLE RPOW 1 ; VARIABLE R 1 ; VARIABLE KN NM3 NT ;
      VARIABLE TA 1 NT ;
      IF (ABS(PHI)>1E-9) ; R := L/(PHI*DEGRAD) ; RPOW := R ;
         LOOP I 1 NT ; RPOW := RPOW*R ; KN(I) := -K(I)*RPOW ; ENDLOOP ;
         MC R PHI D KN S1 S2 NT ;
      ELSEIF 1=1 ; LOOP I 1 NT ; TA(I) := 0 ; ENDLOOP ; MMSK L K TA NT D ;
      ENDIF ; ENDPROCEDURE ;

   PROCEDURE MSS R PHID D E1D H1 E2D H2 W ;  {M SECTOR WITH CENTER DETAIL FIELD}
      VARIABLE E1N NMP ; VARIABLE E2N NMP ; VARIABLE H1N NMP ;
      VARIABLE H2N NMP ; VARIABLE NTS 1 ; VARIABLE LDL 1 ;
      VARIABLE PHI 1 ; VARIABLE E1 1 ; VARIABLE E2 1 ; VARIABLE NT 1 ;
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE LFT 1 ;
      LFT := LFR ; LFR := 3 ; CE := 'MSS' ;
      NT := 0 ; PHI := PHID*DEGRAD ; E1 := E1D*DEGRAD ; E2 := E2D*DEGRAD ;
      IF CONS(R)<0 ; WRITE 6 ' *** ERROR in MSS, negative radius' ; QUIT 0 ;
      ELSEIF CONS(PHID)<0 ; WRITE 6 ' *** ERROR in MSS, negative angle'; QUIT 0;
      ELSEIF CONS(PHID)>360 ;
         WRITE 6 ' *** ERROR in MSS, too big angle > 360'; QUIT 0;
      ELSEIF (ABS(E1)+ABS(E2)+ABS(H1)+ABS(H2)#0)*(NT#0) ;
      WRITE 6 ' @@@ ERROR in MSS, wrong parameters' ; QUIT 0 ; ENDIF ;
      NSDP := -7 ; LOFF := 2 ; DR := D ;
      LOOP I 1 8 ; MSC(I) := DD(I) ; ENDLOOP ;
      IF (NRAY=0)*(LSPN=0) ; LOOP I 1 TWOND ; MSC(I) := MAP(I) ; ENDLOOP ;
         ENDIF ; NTS := NOC ; E1N := E1 ; H1N := H1 ; E2N := E2 ; H2N := H2 ;
      PPOL( 1) := CONS(CHIM)/R ; PPOL( 2) := -R ; PPOL( 3) := 0 ;
      PPOL( 4) := D ;   PPOL( 5) := 0 ;   PPOL( 6) := 0 ;
      PPOL( 7) := SIN(-E1N) ;     PPOL( 8) :=  COS(-E1N) ;
      IF H1N#0 ; PPOL( 7) := PPOL( 7)/H1N ; PPOL( 8) :=  PPOL( 8)/H1N ;
         ENDIF ; PPOL( 9) := R*(COS(PHI) - 1) ; PPOL(10) :=  R*SIN(PHI) ;
      PPOL(11) := SIN(PHI-E2N) ; PPOL(12) := -COS(E2N-PHI) ;
      IF H2N#0 ; PPOL(11) := PPOL(11)/H2N ; PPOL(12) :=  PPOL(12)/H2N ;
         ENDIF ; PPOL(11) := PPOL(11) + PPOL(9) ;
      PPOL(12) := PPOL(12) + PPOL(10) ; PPOL(13) := H1N ; PPOL(14) := H2N ;
      PPOL(20) := PHI ; LOOP I 1 4 ; LOOP J 1 4 ; PPOL(20+4*(I-1)+J) := W(I,J) ;
         ENDLOOP ; ENDLOOP ;
      LDL := 10*D ; LOCSET 0 -LDL 0 0 0 0 ;
      IF LFT=3 ;
         LOCSET R*(COS(0.5*PHI)-1) R*SIN(0.5*PHI) 0.5*PHI 0.5*R*PHI 0 0 ;
         SDELEREF 0.5*R*PHI -LDL D/200 D 7*D D ; ENDIF ;
      UMS ; DLACT MSC -LDL ; SNM MSC MS ; SSNM SSCR SM ;
      SDELE 0 R*PHI+2*LDL MIN(R/10000,D/200) MIN(R/20,D) MIN(R,7*D) D ;
      UPDATEMAP MSC MS MSC SSCR SM SSCR ;
      DLACT MSC -LDL ; SLOC := R*PHI ;
      XLOC := XLOC+LDL*SIN(PLOC) ; ZLOC := ZLOC-LDL*COS(PLOC) ;
      UPDATE 1 1 ; FR LFT ; ENDPROCEDURE ;

   PROCEDURE CMR I D ;                                      {MAGNETIC COIL LOOP}
      VARIABLE MU 1 ; MU := 1.2566E-6 ; CE := 'CMR' ;
      NPOL := 1 ; PPOL(1) := MU*I/(2*D) ; MPOL(1) := 20 ; NSDP := 5 ;
      LOFF := 1 ; DSDED 5E4*D 0 1E-4*D 1E4*D 1E4*D D ;
      ENDPROCEDURE ;

   PROCEDURE CMG B D ;                                  {MAGNETIC GAUSSIAN LENS}
      NPOL := 1 ; PPOL(1) := B ; MPOL(1) :=  20 ; NSDP := 3 ; CE := 'CMG' ;
      LOFF := 1 ; DSDED 5*D 0 D/40 D 10*D D ; ENDPROCEDURE ;

   PROCEDURE CML B D ;                                  {MAGNETIC LENS (GLASER)}
      NPOL := 1 ; PPOL(1) := B ; MPOL(1) := 20 ; NSDP := 7 ; CE := 'CML' ;
      LOFF := 1 ; DSDED 5E4*D 0 1E-4*D 1E4*D 1E4*D D ;
      ENDPROCEDURE ;

   PROCEDURE CMSI I N D L ;                            {IDEAL MAGNETIC SOLENOID}
     {B(S) = MU*I*N/2* ( S/SQRT(S^2+D^2) - (S-L)/SQRT((S-L)^2+D^2) )
      V(S) = MU*I*N/2* ( SQRT(S^2+D^2) - SQRT((S-L)^2+D^2) )}
      VARIABLE MU 1 ; MU := 1.2566E-6 ; CE := 'CMSI' ; NPOL := 1 ;
      PPOL(1) := MU*I*N/2 ; PPOL(2) := L ; MPOL(1) := 20 ; NSDP := 10 ;
      LOFF := 1 ; DSDED 200*D L 1E-4*D D 3*D D ; ENDPROCEDURE ;

   PROCEDURE CMS B D L ;                                     {MAGNETIC SOLENOID}
     {B(S) = B/2/TANH(L/2/D)* ( TANH(S/D) - TANH((S-L)/D) )
      V(S) = B*D/2/TANH(L/2/D)* ( LOG(COSH(S/D)) - LOG(COSH((S-L)/D)) )}
      NPOL := 1 ; PPOL(1) := B*D/2/TANH(L/2/D) ; PPOL(2) := L ;
      MPOL(1) := 20 ; NSDP := 8 ; LOFF := 1 ; CE := 'CMS' ;
      DSDED 25*D L 1E-4*D D 3*D D ; ENDPROCEDURE ;

   PROCEDURE CMSP B D L S1 S2 ;     {A PIECE OF MAGNETIC SOLENOID FROM S1 TO S2}
     {B(S) = B/2/TANH(L/2/D)* ( TANH(S/D) - TANH((S-L)/D) )
      V(S) = B*D/2/TANH(L/2/D)* ( LOG(COSH(S/D)) - LOG(COSH((S-L)/D)) )
      L: LENGTH OF SOLENOID,
      S1, S2: BEGINNING AND END POSITION OF SLICE IN [0,L]}
      VARIABLE DS1 1 ; VARIABLE DS2 1 ;
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
      NPOL := 1 ; PPOL(1) := B*D/2/TANH(L/2/D) ; PPOL(2) := L ;
      MPOL(1) := 20 ; NSDP := 8 ; LOFF := 1 ; CE := 'CMSP' ;
      UMS ; SNM MSC MS ; SSNM SSCR SM ;
      DS1 := 0 ; IF ABS(S1)<1E-5 ; DS1 := L/2-20*D ; ENDIF ;
      IF ABS(S1)<1E-5 ; DLACT MS DS1 ; ELSEIF TRUE ; DS1 := S1 ; ENDIF ;
      IF ABS(S2-L)<1E-5 ; DS2 := 20*D+L/2 ; ELSEIF TRUE ; DS2 := S2 ; ENDIF ;
      LOCSET 0 DS1 0 DS1 0 0 ; SDELE DS1 DS2 1E-4*D (20*D-L/2)/100 3*D D ;
      UPDATEMAP MSC MS MSC SSCR SM SSCR ;
      IF ABS(S2-L)<1E-5 ; DLACT MSC L/2-20*D ; ZLOC := ZLOC-(L/2-20*D) ; ENDIF ;
      SLOC := S2-S1 ; UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE CMST NI R1 R2 L ;                         {THICK MAGNETIC SOLENOID}
     {B(S) = MU*NI/2/(R2-R1) *
                   ( S*LOG((R2+SQRT(    S^2+R2^2))/(R1+SQRT(    S^2+R1^2))
                -(S-L)*LOG((R2+SQRT((S-L)^2+R2^2))/(R1+SQRT((S-L)^2+R1^2)) )
      V(S) = MU*NI/2/(R2-R1) *
             ( 1/2*S^2*LOG((R2+SQRT(    S^2+R2^2))/(R1+SQRT(    S^2+R1^2)))
          -1/2*(S-L)^2*LOG((R2+SQRT((S-L)^2+R2^2))/(R1+SQRT((S-L)^2+R1^2)))
                    +1/2*R2*SQRT(    S^2+R2^2) -1/2*R1*SQRT(    S^2+R1^2)
                    -1/2*R2*SQRT((S-L)^2+R2^2) +1/2*R1*SQRT((S-L)^2+R1^2) )}
      VARIABLE MU 1 ; MU := 1.2566E-6 ;
      IF (R1<0)+(R1=0) ;
         WRITE 6 ' *** ERROR in CMST, R1 < 0 or R1 = 0' ; QUIT 0 ;
      ELSEIF (R2<R1)+(R2=R1) ;
         WRITE 6 ' *** ERROR in CMST, R2 < R1 or R2 = R1' ; QUIT 0 ; ENDIF ;
      CE := 'CMST' ; NPOL := 1 ; PPOL(1) := MU*NI/4/(R2-R1) ; PPOL(2) := L ;
      PPOL(3) := R1 ; PPOL(4) := R2 ; MPOL(1) := 20 ; NSDP := 13 ; LOFF := 1 ;
      DSDED 200*R2 L 1E-4*R1 R1 3*R1 R1 ; ENDPROCEDURE ;

   PROCEDURE CMSTP N NI R1 R2 L X S1 S2 ;  {A PIECE OF THICK MAGNETIC SOLENOIDS}
     {N: NUMBER OF SOLENOIDS, X(IS): STARTING POSITION OF THE IS-TH SOLENOID,
      S1, S2: BEGINNING AND END POSITION OF SLICE IN [0,L]}
      VARIABLE MU 1 ; VARIABLE F 1 ; VARIABLE D 1 ; VARIABLE IS 1 ;
      CE := 'CMSTP' ; MU := 1.2566E-6 ; D := 1D8 ; PPOL(1) := N ;
      LOOP IS 1 N ; D := MIN(D,R1(IS)) ;
         IF (R2(IS)<R1(IS))+(R2(IS)=R1(IS))+(L(IS)<0) ; PPOL(1) := -1 ; ENDIF ;
         MFD(IS,1) := MU*NI(IS)/4/(R2(IS)-R1(IS)) ;
         MFD(IS,2) := L(IS) ; MFD(IS,3) := R1(IS) ; MFD(IS,4) := R2(IS) ;
         MFD(IS,5) := X(IS) ; ENDLOOP ;
      IF (D<0)+(D=0)+(D=1D8) ;
         WRITE 6 ' *** ERROR in CMSTP, R1<0 or R1=0 or R1 too large' ; QUIT 0 ;
      ELSEIF PPOL(1)=-1 ;
         WRITE 6 ' *** ERROR in CMSTP, R2<R1 or R2=R1 or L<0' ; QUIT 0 ; ENDIF ;
      F := 200*D ; NPOL := 1 ; MPOL(1) := 20 ; NSDP := 14 ; LOFF := 1 ;
      LOCSET 0 S1 0 S1 0 0 ; SDELE S1 S2 1E-4*D D 3*D D ; UPDATE 1 1 ;
      ENDPROCEDURE ;

   PROCEDURE WI B K L D K1 IA A ;                                      {WIGGLER}
      VARIABLE L1 1 ; VARIABLE LS 1 ; VARIABLE I 1 ; VARIABLE X 1 ;
      VARIABLE XLOC0 1 ; VARIABLE ZLOC0 1 ; VARIABLE PLOC0 1 ;
      VARIABLE SLOC0 1 ; VARIABLE LLPI 1 ;
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ; VARIABLE SCE 1 ;
      SCE := 2E-5 ;       {SCE is to force UPDATE to output the element name CE}
      PPOL(1) := B ; PPOL(2) := 2*PI/K ; PPOL(3) := D ; PPOL(4) := L ;
      PPOL(5) := K1 ; PPOL(6) := IA ; NSDP := -3 ; LOFF := 2 ; CE := 'WI' ;
      IF IA=0 ; LOOP I 1 10 ; PPOL(I+6) := 0 ; ENDLOOP ; PPOL(8) := 8 ;
         L1 := 5*D ;
      ELSEIF IA=1 ; LOOP I 1 10 ; PPOL(I+6) := A(I) ; ENDLOOP ; L1 := 10*D ;
      ELSEIF TRUE ; WRITE 6 ' *** ERROR in WI fringe field mode' ; ENDIF ;
      DR := D ; LOCSET 0 0 0 SCE 0 0 ; UPDATE 0 0 ; SPOS := SPOS-SCE ;      {PS}
      LLPI := LPI ; LPI := 0 ; LS := L+4*L1 ;
      UMS ; DLACT MSC -L1 ; SNM MSC MS ; SSNM SSCR SM ;
      LRKO := -LRKO ; X := L ;         {Determine the final location for UPDATE}
      FIT X ; LOCSET 0 -L1 0 0 0 0 ; SDELEREF -L1 X K/500 K/10 K D ;
         ENDFIT L*1E-5 100 1 ABS(ZLOC-L) ; LRKO := -LRKO ;
      XLOC0 := XLOC ; ZLOC0 := ZLOC ; PLOC0 := PLOC ; SLOC0 := SLOC ;
      LOCSET 0 -L1 0 0 0 0 ; SDELE 0 LS K/500 K/10 K D ;
      UPDATEMAP MSC MS MSC SSCR SM SSCR ; DLACT MSC -(ZLOC-L) ;
      LOCSET XLOC0 ZLOC0 PLOC0 SLOC0 0 0 ; UPDATE 1 1 ; LPI := LLPI ; PS D ;
      ENDPROCEDURE ;

   PROCEDURE MF L A NX NZ DX DZ SIGMA D SX SZ SPHI ;   {MEASURED MAG FIELD DATA}
      VARIABLE DS1 1 ; VARIABLE IX 1 ; VARIABLE IZ 1 ;
      IF (SIGMA<0.5)+(SIGMA>5.0) ;
         WRITE 6 ' *** ERROR in MF, SIGMA < 0.5  or  SIGMA > 5.0' ; ENDIF ;
      IF (DX<0)+(DX=0)+(DZ<0)+(DZ=0) ;
         WRITE 6 ' *** ERROR in MF, DX =< 0  or  DZ =< 0' ; ENDIF ;
      MFP(1) := 0 ;
      LOOP IX 1 NX ; LOOP IZ 1 NZ ; MFD(IX,IZ) := A(IX,IZ) ; ENDLOOP ; ENDLOOP ;
      PPOL(1) := NX ; PPOL(2) := NZ ; PPOL(3) := DX ; PPOL(4) := DZ ;
      PPOL(5) := SIGMA ; NSDP := -5 ; LOFF := 2 ; DS1 := MIN(DX,DZ) ;
      LOCSET SX SZ -SPHI*DEGRAD 0 0 0 ; CE := 'MF' ;
      SDELE 0 L DS1/100 SQRT(DS1*L/5) L/5 D ; UPDATE 1 1 ;
      IF MFP(1)>0 ; WRITE 6 (' --- WARNING in MF, out of range of data at '&
        SF(MFP(1),'(I8)')&' points') ; ENDIF ; ENDPROCEDURE ;

   PROCEDURE MFFLD XMIN ZMIN XMAX ZMAX DX DZ ;               {CREATE FIELD DATA}
      VARIABLE NX 1 ; VARIABLE NZ 1 ;
      NX := INT((XMAX-XMIN)/DX+1.00001) ; NZ := INT((ZMAX-ZMIN)/DZ+1.00001) ;
      IF (NX<2)+(NZ<2) ; WRITE 6 ' *** ERROR in MFFLD, NX < 2 or NZ < 2' ;
         QUIT 0 ; ENDIF ;
      IF LFR#3 ; WRITE 6 ' *** ERROR in MFFLD, call FR 3 before MFFLD' ; ENDIF ;
      MFP(2) := 1 ; OPENF 98 'MFFLD.DAT' 'UNKNOWN' ;
      WRITE 98 ' MIN (X,Z) = ('&SF(XMIN,'(G16.9)')&','&SF(ZMIN,'(G16.9)')&')' ;
      WRITE 98 ' MAX (X,Z) = ('&SF(XMAX,'(G16.9)')&','&SF(ZMAX,'(G16.9)')&')' ;
      WRITE 98 ' DX = '&SF(DX,'(D16.9)')&',  DZ = '&SF(DZ,'(D16.9)') ;
      WRITE 98 ' NX = '&SF(NX,'(I6)')&',  NZ = '&SF(NZ,'(I6)') ;
      MFP(3) := XMIN ; MFP(4) := XMAX ; MFP(5) := DX ;
      MFP(6) := ZMIN ; MFP(7) := ZMAX ; MFP(8) := DZ ; ENDPROCEDURE ;

   PROCEDURE MFFLDIN A NX NZ DX DZ ;         {READ FIELD DATA CREADTED BY MFFLD}
      VARIABLE STR 80 ; VARIABLE IX 1 ; VARIABLE IZ 1 ; VARIABLE ADT 1 ;
      OPENF 98 'MFFLD.DAT' 'OLD' ; READ 98 STR ; READ 98 STR ;
      READ 98 STR ; DX := R(STR,7,22) ; DZ := R(STR,31,46) ;
      READ 98 STR ; NX := R(STR,7,12) ; NZ := R(STR,21,26) ;
      LOOP IX 1 NX ; LOOP IZ 1 NZ ; READ 98 ADT ; A(IX,IZ) := ADT ;
         ENDLOOP ; ENDLOOP ; CLOSEF 98 ; ENDPROCEDURE ;

  {PROCEDURE FGDATIN FN ;
     {READ FOURIER GAUSS DATA IN GIVEN FILE INTO STORAGE ARRAY MFD(,)
      THE TOTAL NUMBER OF RADII IS STORED IN MFD(1,1)
      THE LENGTH OF THE I-TH RADIUS BLOCK IS MFD(I+1,1). THE FOURIER MODES
      FOLLOW IN MFD(I+1,*).}
      VARIABLE L 4096 ; VARIABLE N 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      VARIABLE M 1 ; VARIABLE F 2 10 ;
      N := 1 ; OPENF 98 FN 'OLD' ; READS 98 L ;
      WHILE (L=' ')+(L|1='#') ; READS 98 L ; ENDWHILE ;
      WHILE L#'' ;
         N := N + 1 ; K := 1 ;
         WHILE (L#'')*(L#' ')*(L|1#'#') ; FIELDS L M F ',' ; IF M>1 ;
            K := K + 1 ; MFD(N,K) := RE(L|F(1))&RE(L|F(2)) ; ENDIF ;
            READS 98 L ; ENDWHILE ; MFD(N,1) := K-1 ;
         WHILE (L=' ')+(L|1='#') ; READS 98 L ; ENDWHILE ; ENDWHILE ;
      MFD(1,1) := N - 1; CLOSEF 98 ; ENDPROCEDURE ;}

   FUNCTION FGDATCHECK DUMMY;
     {CHECK IF THE FOURIER GAUSS DATA PREVIOUSLY READ INTO MFD USING FGDATIN IS
      CONSISTENT AND MEETS THE REQUIREMENTS OF FOURIERGAUSS.}
      VARIABLE IB 1; VARIABLE IL 1; VARIABLE NB 1; VARIABLE NS0 1;
      VARIABLE DR 1; VARIABLE OR 1;
      FGDATCHECK := LO(1) ; NB := MFD(1,1) ;
      IF NB<2 ; FGDATCHECK := LO(0) ; WRITE 6
         ' *** ERROR in FGDATCHECK, at least two radius blocks required'; ENDIF;
      IF FGDATCHECK ; LOOP IB 2 NB+1 ;
         IF MFD(IB,1)<2 ; FGDATCHECK := LO(0) ; WRITE 6 (' *** ERROR in '&
            'FGDATCHECK, block header and one Fourier mode required') ;
         ELSEIF LENGTH(MFD(IB,2))<2 ;
            FGDATCHECK := LO(0) ; WRITE 6
            ' *** ERROR in FGDATCHECK, block header too short' ;
         ELSEIF LENGTH(MFD(IB,2))>2 ; WRITE 6
            ' --- WARNING in FGDATCHECK, block header contains extra data' ;
         ENDIF ; ENDLOOP ; ENDIF ;
      IF FGDATCHECK ; DR := ABS(MFD(3,2)|1 - MFD(2,2)|1) ; NS0 := MFD(2,2)|2 ;
         OR := MFD(2,2)|1 - DR ; LOOP IB 2 NB+1 ;
         IF (MFD(IB,2)|1 - OR - DR)>1E-14 ; FGDATCHECK := LO(0) ; WRITE 6
            ' *** ERROR in FGDATCHECK, radii not evenly spaced and increasing' ;
            ENDIF;
         IF MFD(IB,2)|2#NS0 ; FGDATCHECK := LO(0) ; WRITE 6
            ' *** ERROR in FGDATCHECK, number of sectors not constant' ; ENDIF ;
         OR := MFD(IB,2)|1 ; ENDLOOP ; ENDIF ;
      IF FGDATCHECK ; LOOP IB 2 NB+1 ; IF MFD(IB,3)|1<0 ; WRITE 6
            ' --- WARNING in FGDATCHECK, negative constant Fourier coefficient';
            ENDIF ;
         LOOP IL 3 MFD(IB,1)+1 ; IF LENGTH(MFD(IB,IL))<2 ; FGDATCHECK := LO(0) ;
            WRITE 6
            ' *** ERROR in FGDATCHECK, Fourier coefficent and phase required' ;
            ELSEIF LO(1) ; IF LENGTH(MFD(IB,IL))>2 ; WRITE 6
                  ' --- WARNING in FGDATCHECK, data line contains extra data' ;
                  ENDIF ;
               IF ABS(MFD(IB,IL)|2)>PI+1E-14 ; WRITE 6
                  ' --- WARNING in FGDATCHECK, phase not in [-pi,pi]'
                  MFD(IB,IL); ENDIF ; ENDIF ;
            ENDLOOP ; ENDLOOP ; ENDIF ;
      ENDFUNCTION ;

{ELECTROSTATIC ELEMENTS}
{----------------------}

   PROCEDURE EQ L VV D ; NPOL := 1 ; PPOL(1) := VV/D/D ; MPOL(1) := -2 ;
      LOFF := 1 ; FFELE L D 0 1 2 'EQ' ; ENDPROCEDURE ;

   PROCEDURE EH L VV D ; NPOL := 1 ; PPOL(1) := VV/D/D/D ; MPOL(1) := -3 ;
      LOFF := 1 ; FFELE L D 0 1 2 'EH' ; ENDPROCEDURE ;

   PROCEDURE EO L VV D ; NPOL := 1 ; PPOL(1) := VV/D/D/D/D ; MPOL(1) := -4 ;
      LOFF := 1 ; FFELE L D 0 1 2 'EO' ; ENDPROCEDURE ;

   PROCEDURE ED L VV D ; NPOL := 1 ; PPOL(1) := VV/D/D/D/D/D ; MPOL(1) := -5 ;
      LOFF := 1 ; FFELE L D 0 1 2 'ED' ; ENDPROCEDURE ;

   PROCEDURE EZ L VV D ; NPOL := 1 ; PPOL(1) := VV/D/D/D/D/D/D ; MPOL(1) := -6 ;
      LOFF := 1 ; FFELE L D 0 1 2 'EZ' ; ENDPROCEDURE ;

   PROCEDURE E5 L VQ VH VO VD VZ D ; NPOL := 5 ;            {ELECTRIC MULTIPOLE}
      PPOL(1) := VQ/D/D ;                        MPOL(1) := -2 ;
      PPOL(2) := VH/D/D/D ;                      MPOL(2) := -3 ;
      PPOL(3) := VO/D/D/D/D ;                    MPOL(3) := -4 ;
      PPOL(4) := VD/D/D/D/D/D ;                  MPOL(4) := -5 ;
      PPOL(5) := VZ/D/D/D/D/D/D ;                MPOL(5) := -6 ;
      LOFF := 1 ; FFELE L D 0 1 2 'E5' ; ENDPROCEDURE ;

   PROCEDURE EM L VA NVA D ;                                {ELECTRIC MULTIPOLE}
      VARIABLE I 1 ; VARIABLE DP NM2 ; DP := 1/D ;
      LOOP I 1 NVA ; DP := DP/D ; PPOL(I) := VA(I)*DP ;
         MPOL(I) := -(I+1) ; ENDLOOP ;
      LOFF := 1 ; NPOL := NVA ; FFELE L D 0 1 2 'EM' ;  ENDPROCEDURE ;

   PROCEDURE EMS L VA VS NV D ;                        {SKEW ELECTRIC MULTIPOLE}
      VARIABLE I 1 ; VARIABLE DP NM2 ;
      DP := 1/D ; LOOP I 1 NV ; DP := DP/D ;
         PPOL(I   ) := VA(I)*DP ; MPOL(I   ) := -(I+1) ; ENDLOOP ;
      DP := 1/D ; LOOP I 1 NV ; DP := DP/D ;
         PPOL(I+NV) := -VS(I)*DP*(I+1) ; MPOL(I+NV) := -(I+1+20) ; ENDLOOP ;
      LOFF := 1 ; NPOL := 2*NV ; FFELE L D 0 1 2 'EMS' ;  ENDPROCEDURE ;

   PROCEDURE EBEND R PHI D N NT CI ; {COMBINED FUNCTION ELECTROSTATIC DEFLECTOR}
      VARIABLE RPP 1 ; VARIABLE LDL 1 ; VARIABLE I 1 ;
      VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
      CE := CI ; DR := D ; LOFF := 2 ;
      IF CONS(R)<0 ; WRITE 6 ' *** ERROR in '&CE&', negative radius' ; QUIT 0 ;
      ELSEIF CONS(PHI)<0 ;
         WRITE 6 ' *** ERROR in '&CE&', negative angle' ; QUIT 0 ; ENDIF ;
      IF LFR=0 ; NPOL := NT+1 ; PPOL(1) := CONS(CHIE)/R/1000 ; RPP := 1 ;
         LOOP I 1 NT ; RPP := RPP*R ;
            PPOL(I+1) := -PPOL(1)*N(I)/RPP/(I+1) ; ENDLOOP ;
         LOOP I 1 NPOL ; MPOL(I) := -I ; ENDLOOP ;
         SIELE R*PHI D ;
         LOCSET R*(COS(PHI)-1) R*SIN(PHI) PHI R*PHI 0 0 ; UPDATE 1 1 ;
      ELSEIF (LFR=3)+(LFR=2.5) ; NSDP := -11 ;
         LOOP I 1 36 ; PPOL(I) := 0 ; ENDLOOP ; PPOL(1) := CONS(CHIE)/R/1000 ;
         PPOL(2) := -R ; PPOL(4) := D ; PPOL(8) := 1 ;
         PPOL(9) := R*(COS(PHI)-1) ; PPOL(10) := R*SIN(PHI) ;
         PPOL(11) := PPOL(9)+SIN(PHI) ; PPOL(12) := PPOL(10)-COS(PHI) ;
         IF NT>16 ; WRITE 6 ' --- WARNING in '&CE&', NT is too large.' ; ENDIF ;
         PPOL(20) := MIN(NT,16) ;
         LOOP I 1 PPOL(20) ; PPOL(20+I) := N(I)/(I+1) ; ENDLOOP ;
         LDL := 10*D ; LOCSET 0 -LDL 0 0 0 0 ;
         IF LFR=3 ;
            LOCSET R*(COS(0.5*PHI)-1) R*SIN(0.5*PHI) 0.5*PHI 0.5*R*PHI 0 0 ;
            SDELEREF 0.5*R*PHI -LDL D/200 D 7*D D ; ENDIF ;
         UMS ; DLACT MSC -LDL ; SNM MSC MS ; SSNM SSCR SM ;
         LOCSET XLOC ZLOC PLOC 0 0 0 ;
         SDELE 0 R*PHI+2*LDL MIN(R/10000,D/200) MIN(R/20,D) MIN(R,7*D) D ;
         UPDATEMAP MSC MS MSC SSCR SM SSCR ;
         DLACT MSC -LDL ; SLOC := R*PHI ;
         XLOC := XLOC+LDL*SIN(PLOC) ; ZLOC := ZLOC-LDL*COS(PLOC) ; UPDATE 1 1 ;
      ELSEIF LO(1) ; WRITE 6
         ' *** ERROR in '&CE&', FR '&S(LFR)&' not supported.' ; QUIT 0 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE EC R PHID D N NT ;      {ELECTROSTATIC COMBINED FUNCTION DEFLECTOR}
      EBEND R PHID*DEGRAD D N NT 'EC' ; ENDPROCEDURE ;

   PROCEDURE ES R PHID D N1 N2 N3 N4 N5 ;      {ELECTROSTATIC COMBINED FUNCTION}
      VARIABLE NT 1 ; VARIABLE N 1 5 ;                     {DEFLECTOR UP TO 5TH}
      NT := 5 ; N(1) := N1 ; N(2) := N2 ; N(3) := N3 ; N(4) := N4 ; N(5) := N5 ;
      EBEND R PHID*DEGRAD D N NT 'ES' ; ENDPROCEDURE ;

   PROCEDURE ECL R PHID D ;                {ELECTROSTATIC CYLINDRICAL DEFLECTOR}
      VARIABLE NT 1 ; VARIABLE N 1 MAX(5,NO+1) ; VARIABLE I 1 ;
      NT := MAX(5,NO+1) ; LOOP I 1 NT ; N(I) := 1 ; ENDLOOP ;
      LOOP I 2 NT 2 ; N(I) := -N(I) ; ENDLOOP ;
      EBEND R PHID*DEGRAD D N NT 'ECL' ; ENDPROCEDURE ;

   PROCEDURE ESP R PHID D ;                   {ELECTROSTATIC SPHRICAL DEFLECTOR}
      VARIABLE NT 1 ; VARIABLE N 1 MAX(5,NO+1) ; VARIABLE I 1 ;
      NT := MAX(5,NO+1) ; LOOP I 1 NT ; N(I) := I+1 ; ENDLOOP ;
      LOOP I 2 NT 2 ; N(I) := -N(I) ; ENDLOOP ;
      EBEND R PHID*DEGRAD D N NT 'ESP' ; ENDPROCEDURE ;

   PROCEDURE WC RE RM L D NE NM NT ;             {COMBINED FUNCTION WIEN FILTER}
      VARIABLE I 1 ; NPOL := 2+2*NT ;
      PPOL(1) := -CONS(CHIE)/RE/1000 ; MPOL(1) := -1 ;
      PPOL(2) :=  CONS(CHIM)/RM      ; MPOL(2) := +1 ;
      LOOP I 1 NT ; PPOL(2+I) := PPOL(1)*NE(I)/(I+1) ; MPOL(2+I) := -I-1 ;
         PPOL(2+I+NT) := PPOL(2)*NM(I) ; MPOL(2+I+NT) := I+1 ; ENDLOOP ;
      LOFF := 2 ; FFELE L D 1/RM-1/RE -1 -2 'WC' ; ENDPROCEDURE ;

   PROCEDURE WF RE RM L D ; WC RE RM L D 0 0 0 ; ENDPROCEDURE ; {HOMOGENEOUS WF}

   PROCEDURE MSEM R PHI DM NB DE EV N CI ;    {MAGNET WITH E-MULTIPOLES FOR G-2}
     {Note: The multipole components higher than the 19th are ignored.
      Anyway, the highest computation order possible (POTFLD, OV) is the 18th.}
      VARIABLE I 1 ; VARIABLE NM 1 ; VARIABLE F NMP ;
      VARIABLE LDL 1 ; VARIABLE MS NM1 MAX(8,NV) ; VARIABLE SM NM2 3 3 ;
      CE := CI ; DR := DE ; LOFF := 2 ;
      IF LUM#1 ; WRITE 6 ' *** ERROR, call UM before MSEM' ; QUIT 0 ;
      ELSEIF CONS(R)<0 ;
         WRITE 6 ' *** ERROR in '&CE&', negative radius' ; QUIT 0 ;
      ELSEIF CONS(PHI)<0 ;
         WRITE 6 ' *** ERROR in '&CE&', negative angle'; QUIT 0 ; ENDIF ;
      NPOL := 1 ; PPOL(1) := CONS(CHIM)/R ; MPOL(1) := 1 ; F := 1 ;
      LOOP I 1 N ; F := F/R ;
         IF ABS(NB(I))#0 ; NPOL := NPOL+1 ; MPOL(NPOL) := I+1 ;
            PPOL(NPOL) := -PPOL(1)*NB(I)*F ; ENDIF ; ENDLOOP ;
      NM := NPOL ; F := 1/DE ;
      LOOP I 1 N ; F := F/DE ;
         IF ABS(EV(I))#0 ; NPOL := NPOL+1 ; MPOL(NPOL) := -(I+1) ;
            PPOL(NPOL) := EV(I)*F ; ENDIF ; ENDLOOP ;
      MPOL(NPOL+1) := NM ; PPOL(NPOL+1) := R ;
      PPOL(NPOL+2) := R*(COS(PHI)-1) ; PPOL(NPOL+4) := PPOL(NPOL+2)+SIN(PHI) ;
      PPOL(NPOL+3) := R*SIN(PHI) ;     PPOL(NPOL+5) := PPOL(NPOL+3)-COS(PHI) ;
      MPOL(NPOL+2) := 1 ;
      IF (LFR=0)+(NPOL=NM) ; SIELE R*PHI DE ;
         LOCSET R*(COS(PHI)-1) R*SIN(PHI) PHI R*PHI 0 0 ; UPDATE 1 1 ;
      ELSEIF (LFR=3)+(LFR=2.5) ; NSDP := -21 ; LDL := 10*DE ;
        {BACKWARD FOR THE ENTRANCE}
         LOCSET 0 0 0 0 0 0 ;
         IF LFR=3 ;
            LOCSET R*(COS(0.5*PHI)-1) R*SIN(0.5*PHI) 0.5*PHI 0.5*R*PHI 0 0 ;
            SDELEREF 0.5*R*PHI 0 DE/200 DE 7*DE DE ; ENDIF ;
         MPOL(NPOL+2) := 0 ;
         SDELE 0 -LDL MIN(R/10000,DE/200) MIN(R/20,DE) MIN(R,7*DE) DE ;
         SNM MSC MS ; SSNM SSCR SM ;
        {THE ENTRANCE AND EXIT FF, AND THE MAIN PART}
         MPOL(NPOL+2) := 1 ;
         SDELE 0 R*PHI+2*LDL MIN(R/10000,DE/200) MIN(R/20,DE) MIN(R,7*DE) DE ;
         UPDATEMAP MSC MS MS SSCR SM SM ;
        {BACKWARD FOR THE EXIT}
         MPOL(NPOL+2) := 0 ;
         SDELE 0 -LDL MIN(R/10000,DE/200) MIN(R/20,DE) MIN(R,7*DE) DE ;
         UPDATEMAP MSC MS MSC SSCR SM SSCR ; SLOC := R*PHI ; UPDATE 1 1 ;
      ELSEIF LO(1) ; WRITE 6
         ' *** ERROR in MSEM, FR '&S(LFR)&' not supported.' ; QUIT 0 ; ENDIF ;
      ENDPROCEDURE ;

   PROCEDURE CEG V D ;                                  {GAUSSIAN ELECTRIC LENS}
      NPOL := 1 ; PPOL(1) := V ; MPOL(1) := -20 ; NSDP := 3 ; CE := 'CEG' ;
      LOFF := 1 ; DSDED 5*D 0 1E-4*D D 10*D D ; ENDPROCEDURE ;

   PROCEDURE CEL V D L C ;                            {THREE TUBE ELECTRIC LENS}
     {V(S) = -V/(2*O*C/D)* ( LOG( COSH(O/D*(S+L/2)) / COSH(O/D*(S+L/2+C) )
                           + LOG( COSH(O/D*(S-L/2)) / COSH(O/D*(S-L/2-C) ) )
      REFERENCE: X. JIYE, ABERRATION THEORY IN ELECTRON AND ION OPTICS,
      ACADEMIC PRESS, 1986}
      VARIABLE O 1 ; O := 1.315 ; NPOL := 1 ; MPOL(1) := -20 ;
      NSDP := 6 ; DR := D/O ; LOFF := 1 ; CE := 'CEL' ;
      PPOL(1) := -V/(2*O/D*C) ; PPOL(2) := O*L/2/D ; PPOL(3) := O*(C+L/2)/D ;
      DSDED 5*D+C+L/2 0 1E-4*D D 10*D D/O ; ENDPROCEDURE ;

   PROCEDURE CEA V D L C ;                 {THREE APERTURE EINZEL ELECTRIC LENS}
     {V(S) = V/(PI*C)*((S+L/2+C)*ATAN((S+L/2+C)/D)+(S-L/2-C)*ATAN((S-L/2-C)/D)
                       - (S+L/2)*ATAN((S+L/2)/D) - (S-L/2)*ATAN((S-L/2)/D) )}
      NPOL := 1 ; MPOL(1) := -20 ; NSDP := 9 ; LOFF := 1 ; CE := 'CEA' ;
      PPOL(1) := V/(PI*C) ; PPOL(2) := L/2 ; PPOL(3) := C+L/2 ;
      DSDED 15*D+C+L/2 0 1E-4*D D 10*D D ; ENDPROCEDURE ;

   PROCEDURE DC V D L ;                {ACCELERATING STATIC HOMOGENEOUS E-FIELD}
      VARIABLE S1 1 ; NPOL := 1 ; MPOL(1) := -20 ;
      NSDP := 11 ; LOFF := 1 ; CE := 'DC' ; PPOL(1) := -V/L ;
      LOCSET 0 0 0 0 0 0 ; SDELE 0 L 1E-4*D D 10*D D ; UPDATE 1 1 ;
      ENDPROCEDURE ;

   PROCEDURE RF V N W PHI D ;                                           {CAVITY}
      VARIABLE VV NM1 ;       {V,N ARE COEF AND ORDER OF POL, W FREQ, PHI PHASE}
      VARIABLE VV0 100 ; VARIABLE PP0 1 ; VARIABLE PH 100 ;
      VARIABLE EE0 1 ; VARIABLE T NM1 ; VARIABLE I 1 ;
      PROCEDURE RFM  M ;
        T := M(5)*(-PP0/EE0/CLIGHT) ;
        VV := POLY(M(1),M(3),V,N)*SIN(W*2*PI*T+PH)*(1+M(8))*.001*Z0 ;
        M(2) := M(2)*PP0/CONS(P0) ;
        IF ND>1 ; M(4) := M(4)*PP0/CONS(P0) ; ENDIF ;
        IF ND>2 ; M(5) := T*(-CONS(E0)/CONS(P0))*CLIGHT ;
           M(6) := ( M(6)+(VV-CONS(VV0))/EE0)/(1+CONS(VV0)/EE0) ; ENDIF ;
        ENDPROCEDURE ;
      IF LRP#1 ;  WRITE 6 ' *** ERROR, call RP before RF ' ; QUIT 0 ; ENDIF ;
      PP0 := CONS(P0) ; EE0 := CONS(E0) ; PH := PHI*DEGRAD ;
      VV0 := POLY(0,0,V,N)*SIN(PH)*.001*Z0 ; RP E0+VV0 M0 Z0 ;
      IF CONS(E0)<1E-10 ; WRITE 6 ' *** RF TOO HIGH ' ; QUIT 0 ; ENDIF ;
      RFM MAP ; IF NRAY#0 ; UMS ; RFM MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := D ; CE := 'RF' ; UPDATE 0 1 ; ENDPROCEDURE ;

{GLASS ELEMENTS}
{--------------}

   PROCEDURE GLASS IS0 P1 IS1 P2 IS2 N D AA ; {CENTRAL PROGRAM FOR GLASS OPTICS}
     {IS0>0 : LENS(=1) OR PRISM(=2); REFLECTION. ISO>0 : MIRROR ; REFRACTION.
      IS1 : SURFACE SHAPE[ IS1=0 : SPHERE, IS1>0 : POLYNOMIAL WITH ORDER IS1]
      P : COEFF. OF SURFACE POLYNOMIAL OR RADIUS OF SPHERE.}
      VARIABLE X NM1 ; VARIABLE A NM1 ; VARIABLE Y NM1 ; VARIABLE B NM1 ;
      VARIABLE TANA NM1 ; VARIABLE TANB NM1 ; VARIABLE L NM1 ; VARIABLE NOM 1 ;
      VARIABLE XL 1 ; VARIABLE ZL 1 ; VARIABLE PL 1 ;
      PROCEDURE TRANS1 A B TANA TANB ; VARIABLE SCR NM1 ;
         SCR := ISRT(1-A*A-B*B) ; TANA := A*SCR ; TANB := B*SCR ; ENDPROCEDURE ;
      PROCEDURE TRANS2 TANA TANB A B ; VARIABLE SCR NM1 ;
         SCR := ISRT(1+TANA*TANA+TANB*TANB) ; A := TANA*SCR ; B := TANB*SCR ;
         ENDPROCEDURE ;
      PROCEDURE LL X TANA Y TANB P L IS ;                     {DRIFT TO SURFACE}
         VARIABLE C1 NM1 ; VARIABLE C2 NM1 ; VARIABLE C3 NM1 ;
         VARIABLE L1 NM1 ; VARIABLE L2 NM1 ; VARIABLE CS NM1 ;VARIABLE Z1 NM1 ;
         IF IS=0 ; C1 := 1+TANA*TANA+TANB*TANB ; C2 := TANA*X+TANB*Y-P ;{SPHERE}
            C3 := X*X+Y*Y ; CS := C2*C2-C1*C3 ; IF CONS(C2)*P>0 ;
            WRITE 6 ' @@@ COSY CODE ERROR in GLASS, contact programer' ; ENDIF ;
            IF CONS(CS)<0 ; WRITE 6 ' *** RAY CANNOT TOUCH THE LENS ' ; ENDIF ;
            L1 := (-C2-SQRT(CS))/C1 ; L2 := (-C2+SQRT(CS))/C1 ;
            L  := L1 ; IF ABS(CONS(L1))>ABS(CONS(L2)) ; L := L2 ; ENDIF ;
            X := X+TANA*L ; Y := Y+TANB*L ;
         ELSEIF IS>0 ; Z1 := 0 ; L := POLY(X,Y,P,IS) ;              {POLYNOMIAL}
            WHILE ABS(L-Z1)>1E-13 ; X := X+TANA*(L-Z1) ; Y := Y+TANB*(L-Z1) ;
            Z1 := L ; L := POLY(X,Y,P,IS) ; ENDWHILE ; ENDIF ; ENDPROCEDURE ;
      PROCEDURE ANG X TANA Y TANB N P L IS IS0 ; {BENDING OF PHI ON THE SURFACE}
         VARIABLE CA1 NM1 ; VARIABLE CA2 NM1 ; VARIABLE CA3 NM1 ;
         VARIABLE CB1 NM1 ; VARIABLE CB2 NM1 ; VARIABLE CB3 NM1 ;
         VARIABLE CC1 NM1 ; VARIABLE CC2 NM1 ; VARIABLE CC3 NM1 ;
        {CA,CB,CC ARE X,Y,Z COMPONENTS OF A NORMALIZED VECTOR}
         VARIABLE C1 NM1 ; VARIABLE C2 NM1 ; VARIABLE CD NM1 ;
         VARIABLE S1 NM1 ; VARIABLE S2 NM1 ; VARIABLE S3 NM1 ; VARIABLE S4 NM1 ;
         VARIABLE I 1 ;VARIABLE J 1 ; VARIABLE P0 1 IS IS ;
         IF IS=0 ;  CA1 := X/ABS(P) ; CB1 := Y/ABS(P) ; CC1 := (L-P)/ABS(P) ;
         ELSEIF IS>0 ;                                              {POLYNOMIAL}
            LOOP I 1 IS ; LOOP J 1 IS ; P0(I,J) := P(I+1,J)*I ;
            ENDLOOP ; ENDLOOP ; CA1 := POLY(X,Y,P0,IS-1) ;       {X-DER. OF POL}
            LOOP I 1 IS ; LOOP J 1 IS ; P0(I,J) := P(I,J+1)*J ;
            ENDLOOP ; ENDLOOP ; CB1 := POLY(X,Y,P0,IS-1) ;       {Y-DER. OF POL}
            C1 := ISRT(CA1*CA1+CB1*CB1+1) ; CC1 := -1*C1 ;
            CA1 := CA1*C1 ;  CB1 := CB1*C1 ; ENDIF ;
         CC2 := ISRT(TANA*TANA+TANB*TANB+1) ;
         CA2 := TANA*CC2 ; CB2 := TANB*CC2 ;
         S1 := CC1*CB2-CC2*CB1 ; S2 := CC1*CA2-CC2*CA1 ;
         C1 := (S1*CB1+S2*CA1)/N ; C2 := (S1*S1+S2*S2)/N/N-CC1*CC1 ;
         CD := C1*C1-C2 ;
         IF CONS(CD)<0 ; WRITE 6 ' *** TOT REFLECTION' ; ENDIF ;
         CC3 := -C1+SQRT(CD) ; CB3 := (S1/N+CB1*CC3)/CC1 ;
         CA3 := (S2/N+CA1*CC3)/CC1 ; S3 := CA2*CA3+CB2*CB3+CC2*CC3 ;
         TANA := CA3/CC3 ; TANB := CB3/CC3 ;
         CC3 := -C1-SQRT(CD) ; CB3 := (S1/N+CB1*CC3)/CC1 ;
         CA3 := (S2/N+CA1*CC3)/CC1 ; S4 := CA2*CA3+CB2*CB3+CC2*CC3 ;
         CA3 := CA3/CC3 ; CB3 := CB3/CC3 ;
         IF IS0<0 ;                                                     {MIRROR}
            IF CONS(S3)>CONS(S4) ; TANA := CA3 ; TANB := CB3 ; ENDIF ; ENDIF ;
         IF IS0>0 ;                                                       {LENS}
            IF CONS(S3)<CONS(S4) ; TANA := CA3 ; TANB := CB3 ; ENDIF ; ENDIF ;
         ENDPROCEDURE ;
      NOM := NOC ; IF IS1+IS2>0 ; CO NOM+1 ; ENDIF ;
      X := AA(1) ; A := AA(2) ; Y := AA(3) ; B := AA(4) ;
      TRANS1 A B TANA TANB ;
      LL X TANA Y TANB P1 L IS1 ; ANG X TANA Y TANB N P1 L IS1 IS0 ;
      IF IS0>0 ; X := X+TANA*(D-L) ; Y := Y+TANB*(D-L) ;
         LL X TANA Y TANB P2 L IS2 ;  ANG X TANA Y TANB 1/N P2 L IS2 IS0 ;
         PL := ATAN(CONS(TANA)) ; ZL := CONS(L) ; XL := CONS(X) ;
         X := (X-XL)-TANA*(L-ZL) ; Y := Y-TANB*(L-ZL) ;
      ELSEIF IS0<0 ; TANA := -TANA ; TANB := -TANB ;
         X := X+TANA*L ; Y := Y+TANB*L ;
         PL := ATAN(CONS(TANA)) ; ZL := CONS(L) ; ENDIF ;
      TRANS2 TANA TANB A B ; TANB := B*ISRT(1-SQR(B))/COS(ATAN(TANA)-PL) ;
      A := SQRT(1-SQR(B))*SIN(ATAN(TANA)-PL) ; Y := Y-X*SIN(PL)*TANB ;
      X := X*(COS(PL)-SIN(PL)*TAN(ATAN(TANA)-PL)) ;
      AA(1) := X ; AA(2) := A ; AA(3) := Y ; AA(4) := B ; CO NOM ;
      ENDPROCEDURE ;

   PROCEDURE GLS R1 R2 N L D ;                            {SPHERICAL GLASS LENS}
      VARIABLE I 1 ; GLASS 1 R1 0 R2 0 N L MAP ;
      IF NRAY#0 ; UMS ; GLASS 1 R1 0 R2 0 N L MSC ; ENDIF ;
      LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'GLS' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GL  P1 I1 P2 I2 N L D ;                        {GENERAL GLASS LENS}
      VARIABLE I 1 ; GLASS 1 P1 I1 P2 I2 N L MAP ;
      IF NRAY#0 ; UMS ; GLASS 1 P1 I1 P2 I2 N L MSC ; ENDIF ;
      LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'GL' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GP PHI1 PHI2 N L D ;                                  {GLASS PRISM}
      VARIABLE P 1 2 2 ; VARIABLE Q 1 2 2 ; VARIABLE I 1 ; VARIABLE J 1 ;
      LOOP I 1 2 ; LOOP J 1 2 ; P(I,J) := 0 ; Q(I,J) := 0 ; ENDLOOP ; ENDLOOP ;
      P(2,1) := TAN(PHI1*DEGRAD) ; Q(2,1) := TAN(PHI2*DEGRAD) ;
      GLASS 2 P 1 Q 1 N L MAP ;
      IF NRAY#0 ; UMS ; GLASS 2 P 1 Q 1 N L MSC ; ENDIF ;
      LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'GP' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GMS R D ;  VARIABLE I 1 ;                        {SPHERICAL MIRROR}
      GLASS -1 R 0 0 0 1 0 MAP ;
      IF NRAY#0 ; UMS ; GLASS -1 R 0 0 0 1 0 MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := D ; CE := 'GMS' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GMP R D ;                                        {PARABOLIC MIRROR}
      VARIABLE P 1 3 3 ;  VARIABLE I 1 ; VARIABLE J 1 ;
      LOOP I 1 3 ; LOOP J 1 3 ; P(I,J) := 0 ; ENDLOOP ; ENDLOOP ;
      P(3,1) := .5/R ; P(1,3) := .5/R ; GLASS -1 P 2 0 0 1 0 MAP ;
      IF NRAY#0 ;  UMS ; GLASS -1 P 2 0 0 1 0 MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := D ; CE := 'GMP' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GMF PHI D ;                                           {FLAT MIRROR}
      VARIABLE P 1 2 2 ;  VARIABLE I 1 ; VARIABLE J 1 ;
      LOOP I 1 2 ; LOOP J 1 2 ; P(I,J) := 0 ; ENDLOOP ; ENDLOOP ;
      P(2,1) := TAN((90-PHI)*DEGRAD) ; GLASS -1 P 1 0 0 1 0 MAP ;
      IF NRAY#0 ; UMS ; GLASS -1 P 1 0 0 1 0 MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := D ; CE := 'GMF' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE GM  P N D ;  VARIABLE I 1 ;                        {GENERAL MIRROR}
      GLASS -1 P N 0 0 1 0 MAP ;                 {P=POL OF COEF; N=ORDER OF POL}
      IF NRAY#0 ; UMS ; GLASS -1 P N 0 0 1 0 MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := D ; CE := 'GM' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE SA DX DY ;                                             {SHIFT AXIS}
      UMS ; MSC(1) := MSC(1) - DX ; MSC(3) := MSC(3) - DY ;
      LOCSET 0 0 0 0 0 0 ; DR := 0 ; CE := 'SA' ; UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE TA AX AY ;                                              {TILT AXIS}
      VARIABLE PF NM1 ; VARIABLE A NM1 ; VARIABLE AXR 1 ; VARIABLE AYR 1 ;
      VARIABLE SCR NM1 ;
      PROCEDURE TAX M ; A := ATAN(M(2)*ISRT(PF-SQR(M(2))-SQR(M(4)))) ;
         SCR := -SIN(AXR)/COS(A-AXR)*ISRT(PF-SQR(M(4)))*M(1) ;
         M(3) := M(3)+M(4)*SCR ;
         IF ND>2 ; M(5) := M(5)-SCR*(P0/CONS(P0))*(TFAC/V0) ; ENDIF ;
         M(2) := SQRT(PF-SQR(M(4)))*SIN(A-AXR) ;
         M(1) := M(1)*(COS(AXR)-SIN(AXR)*TAN(A-AXR)) ; ENDPROCEDURE ;
      PROCEDURE TAY M ; A := ATAN(M(4)*ISRT(PF-SQR(M(2))-SQR(M(4)))) ;
         SCR := -SIN(AYR)/COS(A-AYR)*ISRT(PF-SQR(M(2)))*M(3) ;
         M(1) := M(1)+M(2)*SCR ;
         IF ND>2 ; M(5) := M(5)-SCR*(P0/CONS(P0))*(TFAC/V0) ; ENDIF ;
         M(4) := SQRT(PF-SQR(M(2)))*SIN(A-AYR) ;
         M(3) := M(3)*(COS(AYR)-SIN(AYR)*TAN(A-AYR)) ; ENDPROCEDURE ;
      AXR := AX*DEGRAD ; AYR := AY*DEGRAD ; PF := SQR(P0/CONS(P0)) ;
      TAX MAP ; TAY MAP ; IF NRAY#0 ; UMS ; TAX MSC ; TAY MSC ; ENDIF ;
      LOCSET 0 0 0 0 0 0 ; DR := 0 ; CE := 'TA' ; UPDATE 0 1 ; ENDPROCEDURE ;

   PROCEDURE RA PHI ; VARIABLE ANG NM2 ;                           {ROTATE AXIS}
      IF LPG#0 ; WRITE 6 ' --- WARNING in RA, PTY # 0' ; ENDIF ;
      ANG := PHI*DEGRAD ; UMS ;
      MSC(1) :=  COS(ANG)*DD(1) + SIN(ANG)*DD(3) ;
      MSC(3) := -SIN(ANG)*DD(1) + COS(ANG)*DD(3) ;
      MSC(2) :=  COS(ANG)*DD(2) + SIN(ANG)*DD(4) ;
      MSC(4) := -SIN(ANG)*DD(2) + COS(ANG)*DD(4) ;
      LOCSET 0 0 0 0 0 0 ; LOCTRA 0 0 0 0 0 ANG LTRA ; DR := 0 ; CE := 'RA' ;
      UPDATE 1 1 ; ENDPROCEDURE ;

   PROCEDURE RSX PHI ; {*** rotate spin-map about x-axis @EV @AA}
     VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE ANG NM2;
     {Set rotation matrix}
     ANG := PHI*DEGRAD; UMS ;
     LOOP I 1 3 ; LOOP J 1 3 ; SSCR(I,J) := 0*DD(1) ;
     ENDLOOP ; ENDLOOP ;
     SSCR(1,1) := 1 + 0*DD(1) ;
     SSCR(2,2) := COS(ANG) + 0*DD(1) ;
     SSCR(3,2) := -SIN(ANG) + 0*DD(1) ;
     SSCR(2,3) := SIN(ANG) + 0*DD(1) ;
     SSCR(3,3) := COS(ANG) + 0*DD(1) ;
     LOCSET 0 0 0 0 0 0 ; CE:='RSX' ; DR:=0 ; {Dynamic Aperture}
     UPDATE 1 1 ; {Update}
   ENDPROCEDURE ;

   PROCEDURE RSY PHI ; {*** rotate spin-map about y-axis @EV @AA}
     VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE ANG NM2;
     {Set rotation matrix}
     ANG := PHI*DEGRAD; UMS ;
     LOOP I 1 3 ; LOOP J 1 3 ; SSCR(I,J) := 0*DD(1) ;
     ENDLOOP ; ENDLOOP ;
     SSCR(2,2) := 1 + 0*DD(1) ;
     SSCR(1,1) := COS(ANG) + 0*DD(1) ;
     SSCR(3,1) := -SIN(ANG) + 0*DD(1) ;
     SSCR(1,3) := SIN(ANG) + 0*DD(1) ;
     SSCR(3,3) := COS(ANG) + 0*DD(1) ;
     LOCSET 0 0 0 0 0 0 ; CE:='RSY' ; DR:=0 ; {Dynamic Aperture}
     UPDATE 1 1 ; {Update}
   ENDPROCEDURE ;

   PROCEDURE RSA PHI ; {*** rotate spin-map about z-axis @EV @AA}
     VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE ANG NM2;
     {Set rotation matrix}
     ANG := PHI*DEGRAD; UMS ;
     LOOP I 1 3 ; LOOP J 1 3 ; SSCR(I,J) := 0*DD(1) ;
     ENDLOOP ; ENDLOOP ;
     SSCR(3,3) := 1 + 0*DD(1) ;
     SSCR(2,2) := COS(ANG) + 0*DD(1) ;
     SSCR(2,1) :=-SIN(ANG) + 0*DD(1) ;
     SSCR(1,2) := SIN(ANG) + 0*DD(1) ;
     SSCR(1,1) := COS(ANG) + 0*DD(1) ;
     LOCSET 0 0 0 0 0 0 ; CE:='RSA' ; DR:=0 ; {Dynamic Aperture}
     UPDATE 1 1 ; {Update}
   ENDPROCEDURE ;

   PROCEDURE WSM IU L B A ;             {SAVE SYMPLECTIC REPRESENTATION IN UNIT}
      VARIABLE LIN 80 ; VARIABLE NAP NM1 NV ; VARIABLE C NM1 TWOND ;
      VARIABLE ML NM1 NV ; VARIABLE P NM1 ; VARIABLE F NM1 ; VARIABLE I 10 ;
      VARIABLE J 1 ; IF (ND>2)*(NP<1)+(ND<3)*(NP<2) ;
      WRITE 6 ' *** ERROR in WSM, too few parameters' ; QUIT 0 ; ENDIF ; {*}
     {IF DEPENDENCE ON B WORKS, * AND EDEP SHOULD BE CHANGED.}
      LOOP I 1 NV ; NAP(I) := MAP(I) ; ENDLOOP ; IF ND>2 ; EDEP NAP L PARA(1) ;
      ELSEIF ND<3 ; EDEP NAP L PARA(2) ; LOOP I 1 TWOND ;
      DAPLU NAP(I) TWOND+1 0 F ; NAP(I) := F ; ENDLOOP ; ENDIF ;
     {WRITE PARAMETERS}
      I := '(E23.16)' ; LIN := '     OV'&SF(NOC,'(I3)')&SF(ND,'(I3)')
      &SF(NP,'(I3)')&' ;' ; WRITE IU LIN ; LIN := '     RP'&SF(CONS(E0),I)
      &SF(CONS(M0),I)&SF(CONS(Z0),I)&' ;' ; WRITE IU LIN ; LIN := '     UM ; FR'
      &SF(LFR,'(I3)')&' ; ESET'&SF(EPS,I)&' ; WSET'&SF(WAF,I)&' ;' ;
      WRITE IU LIN ; LIN := '     CE'&SF(L,I)&SF(B,I)&SF(A,I)&' ;' ;
      WRITE IU LIN ; WRITE IU '  ' ;
     {COMPUTE SYMPLECTIC REPRESENTATION}
      MLF NAP C ML P -1 ; I := -1 ; MGF ML F I J ;
      IF J#0 ; WRITE 6 ' *** ERROR in WSM, no gen. f.' ; QUIT 0 ; ENDIF ;
      LIN := '     GENERATING FUNCTION OF TYPE  '&SF(I,'(I2)') ;  WRITE IU LIN ;
      LIN := '     LIE EXPONENT        OF TYPE  '&SF(-1,'(I2)') ; WRITE IU LIN ;
      WRITE IU '  ' ;
      CO NOC+1 ; IF ND=3 ; J := TWOND+1 ; ELSEIF ND<3 ; J := TWOND+2 ; ENDIF ;
      LOOP I 0 NOC ; DAPEW IU F J I ; DAPEW IU P J I ; ENDLOOP ; CO NOC-1 ;
      ENDPROCEDURE ;

   PROCEDURE CRSYSCA ;
     WRITE 6 ' This is going to take very long, do you really want to do this?'
             ' If you only need the fringe fields of selected multipoles, it'
             ' would be faster to compute and store them separately in a'
             ' reference file using WSM and RSM.' ; OPENF 99 'SYSCA.DAT' 'NEW' ;
     OV  5  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ;
     DI 2 30 .0254 0 0 0 0 ; WSM 99 0 (CONS(P0/Z0)/CLIGHT*1E6/2) .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ;
     DI 2 30 .0254 0 0 0 0 ; WSM 99 0 (CONS(P0/Z0)/CLIGHT*1E6/2) .0254 ;
     OV  6  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ; MQ 0 1 .0254 ; WSM 99 0 1 .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ; MQ 0 1 .0254 ; WSM 99 0 1 .0254 ;
     OV  6  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ; MH 0 .5 .0254 ; WSM 99 0 .5 .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ; MH 0 .5 .0254 ; WSM 99 0 .5 .0254 ;
     OV  6  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ; MO 0 .25 .0254 ; WSM 99 0 .25 .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ; MO 0 .25 .0254 ; WSM 99 0 .25 .0254 ;
     OV  6  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ; MD 0 .125 .0254 ; WSM 99 0 .125 .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ; MD 0 .125 .0254 ; WSM 99 0 .125 .0254 ;
     OV  6  3  1 ; RP 400 16 3 ;
     UM ; FR -1 ; ESET 1E-12 ; WSET 1 ; MZ 0 .25 .0254 ; WSM 99 0 .25 .0254 ;
     UM ; FR -2 ; ESET 1E-12 ; WSET 1 ; MZ 0 .25 .0254 ; WSM 99 0 .25 .0254 ;
     CLOSEF 99 ; ENDPROCEDURE ;

  {PROCEDURE GRREAD UNIT PIC ; VARIABLE L 3 ; VARIABLE LIN 160 ;  {READ GRAPHIC}
      VARIABLE PX 8000 3; VARIABLE PC 8000 4 ; VARIABLE I 1 ;
      FUNCTION DAPOW LIN ; VARIABLE K 1 ; DAPOW := R(LIN,11,34)+0*DA(1) ;
         LOOP K 1 R(LIN,5,6) ; DAPOW := DAPOW*DA(1) ; ENDLOOP ;
         LOOP K 1 R(LIN,8,9) ; DAPOW := DAPOW*DA(2) ; ENDLOOP ; ENDFUNCTION ;
      LIN := ' ' ; L := ' ' ; WHILE SS(LIN,1,3)#'BEG' ; READ UNIT LIN ;
      ENDWHILE ; WHILE L#'END' ;
         IF     L='PRJ' ; GRPROJ  R(LIN,5,28) R(LIN,29,52)              PIC ;
         ELSEIF L='ZOO' ; GRZOOM  R(LIN,5,28) R(LIN,29,52) R(LIN,53,76)
                            R(LIN,77,100) R(LIN,101,124) R(LIN,125,148) PIC ;
         ELSEIF L='MOV' ; GRMOVE  R(LIN,5,28) R(LIN,29,52) R(LIN,53,76) PIC ;
         ELSEIF L='DRA' ; GRDRAW  R(LIN,5,28) R(LIN,29,52) R(LIN,53,76) PIC ;
         ELSEIF L='DOT' ; GRDOT   R(LIN,5,28) R(LIN,29,52) R(LIN,53,76) PIC ;
         ELSEIF L='TRI' ; GRTRI   R(LIN,5,28) R(LIN,29,52) R(LIN,53,76) PIC ;
         ELSEIF L='CHA' ; GRCHAR  SS(LIN,5,LENGTH(LIN))                 PIC ;
         ELSEIF L='COL' ; GRCOLR  R(LIN,5,6)                            PIC ;
         ELSEIF L='RGB' ; GRCOLR  (R(LIN,5,7)&R(LIN,9,11)
                                  &R(LIN,13,15)&R(LIN,17,18))           PIC ;
         ELSEIF L='WID' ; GRWDTH  R(LIN,5,6)                            PIC ;
         ELSEIF L='PLE' ; GRPOLY  PX PC 1&2                             PIC ;
         ELSEIF L='PLY' ; LOOP I 1 3 ; PX(I) := 0*DA(1) ; PC(I) := PX(I) ;
                          ENDLOOP; PC(4) := PC(1) ;
         ELSEIF L='PL1' ; PX(1) := PX(1)+DAPOW(LIN) ;
         ELSEIF L='PL2' ; PX(2) := PX(2)+DAPOW(LIN) ;
         ELSEIF L='PL3' ; PX(3) := PX(3)+DAPOW(LIN) ;
         ELSEIF L='PL4' ; PC(1) := PC(1)+DAPOW(LIN) ;
         ELSEIF L='PL5' ; PC(2) := PC(2)+DAPOW(LIN) ;
         ELSEIF L='PL6' ; PC(3) := PC(3)+DAPOW(LIN) ;
         ELSEIF L='PL7' ; PC(4) := PC(4)+DAPOW(LIN) ;
         ENDIF ; READ UNIT LIN ; L := SS(LIN,1,3) ; ENDWHILE ; ENDPROCEDURE ;}

   PROCEDURE MAKEINV A E INV ;      {NORMAL FORM INVARIANT INV FOR EMITTANCES E}
      VARIABLE I 1 ; CO NOC+1 ; INV := 0 ;
      LOOP I 1 ND ; INV := INV + (SQR(A(2*I-1))+SQR(A(2*I)))/E(I) ;
      ENDLOOP ; CO NOC-1 ; ENDPROCEDURE ;

   PROCEDURE WL SS1 SS2 N S1 S2 LF ;
     {SS1,SS2:  COEF. ARRAYS DESCRIBING THE SURFACE. (I,J) FOR X^(I-1)*Y^(J-1)
                SS1: ENTRANCE,  SS2: EXIT
      N:        ORDER OF SS1 SS2 POLYNOMIALS
      S1,S2:    S POSITIONS OF THE ENTRANCE AND THE EXIT IN THE REFERENCE ORBIT
      LF: (OUT) SURFACE SHAPE DEPENDENT LENGTH}
      VARIABLE FLOW NM1 MAX(8,NV) ; VARIABLE ARG NM1 NV ; VARIABLE RES NM1 NV ;
      VARIABLE CSTR NM1 1 ; VARIABLE FNL NM1 2 3 ; VARIABLE SCR NM1 ;
      VARIABLE L 1 2 ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE IER 1 ;
      IF LWA#1 ; WRITE 6 ' *** ERROR in WL, call WAS 1 before OV' ; QUIT 0 ;
      ELSEIF LRP=0 ; WRITE 6 ' *** ERROR, call RP before WL' ; QUIT 0 ;
      ELSEIF (SS1(1,1)#0)+(SS2(1,1)#0) ; WRITE 6
         ' *** ERROR in WL, SS1(1,1) and SS2(1,1) must be 0' ; QUIT 0 ;
      ELSEIF ABS(S2-S1)<1.D-12 ; WRITE 6
         ' *** ERROR in WL, S2-S1 must be non zero' ; QUIT 0 ; ENDIF ;
      CO NO+1 ; IF LCO=0 ; LOOP I 1 8 ; FLOW(I) := XX(I)+0*DD(1) ; ENDLOOP ;
         DLACT FLOW DD(NV) ;
      ELSEIF LCO=1 ; LOOP I 1 8 ; FLOW(I) := XX(I)+0*DD(1) ; ENDLOOP ;
         FLOW(1) := FLOW(1)+FLOW(2)*DD(NV) ;
         FLOW(3) := FLOW(3)+FLOW(4)*DD(NV) ; ENDIF ;
      LOOP I MIN(9,NV) NV ; FLOW(I) := DD(I) ; ENDLOOP ;
      LOOP I 1 NV-1 ; ARG(I) := DD(I) ; ENDLOOP ;  L(1) := S1 ; L(2) := S2 ;
      LOOP J 1 2 ; ARG(NV) := DD(NV)+L(J) ; POLVAL 1 FLOW NV ARG NV RES NV ;
         IF     J=1 ; CSTR(1) :=  POLY(DD(1),DD(3),SS1,N) ;
         ELSEIF J=2 ; CSTR(1) := -POLY(DD(1),DD(3),SS2,N) ; ENDIF ;
         CSTR(1) := CSTR(1)-DD(NV)+L(J) ; POLVAL 1 CSTR 1 RES NV CSTR 1 ;
         ARG(NV) := CSTR(1) ; MI ARG RES NV IER NOC NV NM1 ; IF IER#0 ;
            WRITE 6 ' *** ERROR in WL, inversion failed' ; QUIT 0 ; ENDIF ;
         DAPLU RES(NV) NV 0 SCR ; ARG(NV) := SCR+L(J) ;
         RES(1) := FLOW(1) ; RES(2) := FLOW(3) ; RES(3) := FLOW(NV) ;
         POLVAL 1 RES 3 ARG NV RES 3 ;
         LOOP I 1 3 ; FNL(J,I) := RES(I) ; ENDLOOP ; ENDLOOP ;
      CO NO ; LF := 0 ; LOOP I 1 3 ; LF := LF+SQR(FNL(2,I)-FNL(1,I)) ; ENDLOOP ;
      LF := SQRT(LF) ; ENDPROCEDURE ;

   PROCEDURE BBC Z A RHO I DELTA C ;
     {Z, A:  ATOMIC NUMBER AND MASS OF ABSORBING MATERIAL
      RHO:   DENSITY OF ABSORBING MATERIAL IN GRAM/CM^3
      I:     MEAN EXCITATION POTENTIAL IN MEV
      DELTA: DENSITY CORRECTION PARAMETER
      C:     SHELL CORRECTION PARAMETER}
      BETHEBLOCHC(1) := Z ; BETHEBLOCHC(2) := A ;    BETHEBLOCHC(3) := RHO ;
      BETHEBLOCHC(4) := I ; BETHEBLOCHC(5) := DELTA ; BETHEBLOCHC(6) := C ;
      ENDPROCEDURE ;

   FUNCTION BETHEBLOCH ETOT ;
      VARIABLE BETA NM1 ; VARIABLE GAMMA NM1 ; VARIABLE MECC 1 ;
      VARIABLE MEM0 NM1 ; VARIABLE TMAXN NM1 ; VARIABLE TMAXD NM1 ;
      GAMMA := ETOT/(M0*AMUMEV) ; IF CONS(GAMMA)<1 ; WRITE 6
         ' *** ERROR in BETHEBLOCH, kinetic energy lost to negative' ; QUIT 0 ;
         ENDIF ;  BETA := SQRT((GAMMA+1)*(GAMMA-1))/GAMMA ;
      MECC := 0.510998918 ; MEM0 := MECC/(M0*AMUMEV) ;
      TMAXD := 1+2*GAMMA*MEM0+SQR(MEM0) ; TMAXN := 2*MECC*(GAMMA+1)*(GAMMA-1) ;
      BETHEBLOCH := -15.35375*BETHEBLOCHC(1)/BETHEBLOCHC(2)*BETHEBLOCHC(3)
         *SQR(Z0/BETA) * ( LOG(SQR(TMAXN/BETHEBLOCHC(4))/TMAXD)-2*SQR(BETA)
         -BETHEBLOCHC(5)-2*BETHEBLOCHC(6)/BETHEBLOCHC(1) ) ; ENDFUNCTION ;

   PROCEDURE EODE Y S YP ;
      YP(1) := BETHEBLOCH(Y(1)) ; YP(2) := ISRT(1-SQR(M0*AMUMEV/Y(1))) ;
      ENDPROCEDURE ;

   PROCEDURE RK4 N X0 X1 Y0 NS Z Y1 ;
     {FOURTH ORDER RUNGE KUTTA INTEGRATOR WITH FIXED STEP SIZE.
      INPUT PARAMETERS:
         N          NUMBER OF ODE'S
         X0, X1     INITIAL AND FINAL VALUES OF INDEPENDENT VARIABLE
         Y0         INITIAL VALUES OF ODE
         NS         NUMBER OF STEPS
         Z          2 DIMENSIONAL SCRATCH ARRAY WITH DIMENSIONS N AND 4
      OUTPUT PARAMETERS:
         Y1        SOLUTION ARRAY OF LENGTH N}
      VARIABLE H 1 ; VARIABLE HH 1 4 ; VARIABLE X 1 ; VARIABLE Y NM1 N ;
      VARIABLE YP NM1 N ; VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      LOOP J 1 N ; Y1(J) := Y0(J) ; ENDLOOP ; X := X0 ; H := (X1-X0)/NS ;
      HH(1) := 0 ; HH(2) := 0.5*H ; HH(3) := 0.5*H ; HH(4) := H ;
      LOOP I 1 NS ;
         EODE Y1 X+HH(1) YP ; LOOP J 1 N ; Z(J,1) := YP(J) ; ENDLOOP ;
         LOOP K 2 4 ; LOOP J 1 N ; Y(J) := Y1(J)+HH(K)*Z(J,K-1) ; ENDLOOP ;
            EODE Y X+HH(K) YP ;
            LOOP J 1 N ; Z(J,K) := YP(J) ; ENDLOOP ; ENDLOOP ;
         LOOP J 1 N ; Y1(J) := Y1(J)+H/6*(Z(J,1)+2*Z(J,2)+2*Z(J,3)+Z(J,4)) ;
            ENDLOOP ; X := X+H ; ENDLOOP ; ENDPROCEDURE ;

   PROCEDURE EL EI TI L EF TF ;
     {ENERGY LOSS INTEGRATION IN THICKNESS L MATERIAL
      E*   : KINETIC ENERGY,  T* : (TIME OF FLIGHT)*CLIGHT
      EI,TI: INITIAL CONDITIONS
      EF,TF: FINAL RESULT ALSO DEPENDING ON ARCLENGTH VARIABLE S}
      VARIABLE Y0 NM1 2 ; VARIABLE Y NM1 2 ; VARIABLE YP NM1 2 ;
      VARIABLE Z NM1 2 4 ; VARIABLE SCR NM1 ; VARIABLE I 1 ; VARIABLE J 1 ;
      IF LWA#1 ; WRITE 6 ' *** ERROR in EL, call WAS 1 before OV' ; QUIT 0 ;
      ELSEIF LRP=0 ; WRITE 6 ' *** ERROR, call RP before EL' ; QUIT 0 ;
      ELSEIF (BETHEBLOCHC(1)*BETHEBLOCHC(2)*BETHEBLOCHC(4))=0 ;
         WRITE 6 ' *** ERROR, call BBC properly before EL' ; QUIT 0 ; ENDIF ;
      Y0(1) := EI+M0*AMUMEV ; Y0(2) := TI ;
      RK4 2 0 L Y0 10 Z Y ;  LOOP J 1 2 ; Y0(J) := Y(J) ; ENDLOOP ;
      LOOP I 1 NO+1 ; EODE Y L YP ;
         LOOP J 1 2 ; DAINT NV YP(J) SCR ; Y(J) := Y0(J)+SCR ; ENDLOOP ;
         ENDLOOP ;  EF := Y(1)-M0*AMUMEV ; TF := Y(2) ;  ENDPROCEDURE ;

   FUNCTION VELC KE ; VARIABLE ETA0 NM1 ;
      ETA0 := KE/(M0*AMUMEV) ; VELC := SQRT(ETA0*(2+ETA0))/(1+ETA0) ;
      ENDFUNCTION ;

   PROCEDURE COSY2TR MC ;   {TRANSPORT LIKE COORDINATES EXPRESSED IN COSY COOR.}
      VARIABLE I 1 ; VARIABLE SCR NM1 ;
      SCR := ISRT( SQR(P0/CONS(P0))-SQR(XX(2))-SQR(XX(4)) ) ;
      LOOP I 1 TWOND ; MC(I) := XX(I) ; ENDLOOP ;
      LOOP I 2 4 2 ; MC(I) := MC(I)*SCR ; ENDLOOP ;
      MC(5) := -CONS(P0)/CONS(E0)*MC(5) ; ENDPROCEDURE ;

   PROCEDURE WA SS1 SS2 N L D ;                                 {WEDGE-ABSORBER}
     {SS1,SS2: COEF. ARRAYS DESCRIBING THE SURFACE. (I,J) FOR X^(I-1)*Y^(J-1)
               SS1: ENTRANCE,  SS2: EXIT
      N:       ORDER OF SS1 SS2 POLYNOMIALS
      L:       LENGTH OF THE REFERENCE ORBIT IN WA}
      VARIABLE SS0 1 N+1 N+1 ; VARIABLE XX0 NM1 NV ; VARIABLE MC NM1 NV ;
      VARIABLE LF NM1 ; VARIABLE LF1 NM1 ; VARIABLE LF2 NM1 ; VARIABLE IER 1 ;
      VARIABLE TF NM1 ; VARIABLE EF NM1 ; VARIABLE I 1 ; VARIABLE J 1 ;
      IF L<1.D-12 ;  WRITE 6  ' *** ERROR in WA, L must be positive' ; QUIT 0 ;
      ELSEIF LUM#1 ; WRITE 6  ' *** ERROR, call UM before WA' ; QUIT 0 ;
      ELSEIF ND#3 ;  WRITE 6 (' *** ERROR in WA, '&
         'call OV with phase space dimension 3') ; QUIT 0 ; ENDIF ;
     {COMPUTE EF (ENERGY) AND TF (TIME OF FLIGHT *CLIGHT) DEPENDING ON SS1, SS2}
      LOOP I 1 N+1 ; LOOP J 1 N+1 ; SS0(I,J) := 0 ; ENDLOOP ; ENDLOOP ;
      LCO := 1 ; WL SS1 SS0 MIN(N,NO) 0 0.5*L LF1 ;
                 WL SS0 SS2 MIN(N,NO) 0.5*L L LF2 ; LCO := 0 ;
      LF := LF1+LF2 ; EL E0 DD(5) L EF TF ; MC(1) := TF ; MC(2) := EF ;
      LOOP I 1 NV-1 ; XX0(I) := DD(I) ; ENDLOOP ; XX0(NV) := LF-CONS(LF) ;
      POLVAL 1 MC 2 XX0 NV MC 2 ; EF := MC(2) ; TF := MC(1) ;
      LF := 0.5*L*SQRT(1+SQR(XX(2))+SQR(XX(4))) ;
      TF := TF + (LF-LF1)/VELC(E0) + (LF-LF2)/VELC(EF) ;
     {MAP IN TRANSPORT LIKE COORDINATES: XX0()}
      XX0(1) := XX(1)+L*XX(2) ; XX0(2) := XX(2) ;
      XX0(3) := XX(3)+L*XX(4) ; XX0(4) := XX(4) ;
      XX0(5) := TF-CONS(TF) ;   XX0(6) := (EF-CONS(EF))/CONS(EF) ;
      LOOP I 7 NV ; XX0(I) := DD(I) ; ENDLOOP ;
     {TRANSFORM TRANSPORT LIKE MAP TO COSY COORDINATES: MSC()}
      COSY2TR MC ; LOOP I 7 NV ; MC(I) := DD(I) ; ENDLOOP ;
      POLVAL 1 XX0 NV MC NV XX0 NV ;   RP CONS(EF) M0 Z0 ;
      COSY2TR MC ; LOOP I 7 NV ; MC(I) := DD(I) ; ENDLOOP ;
      MI MC MC NV IER NOC NV NM1 ; IF IER#0 ;
         WRITE 6 ' *** ERROR in WA, MI inversion failed' ; QUIT 0 ; ENDIF ;
      POLVAL 1 MC NV XX0 NV XX0 NV ; LOOP I 1 6 ; MSC(I) := XX0(I) ; ENDLOOP ;
      LOOP I 7 8 ; MSC(I) := XX(I) ; ENDLOOP ;
      LOCSET 0 L 0 L 0 0 ; DR := D ; CE := 'WA' ; UPDATE 1 1 ; ENDPROCEDURE ;

{PLOT2D PROGRAM}
{**************}

   FUNCTION NUMEXP X ;  VARIABLE ABX 1 ; ABX := ABS(X) ;   {MAGNITUDE OF NUMBER}
      IF ABX=0 ;     NUMEXP := -300 ;
      ELSEIF ABX<1 ; NUMEXP := INT(LOG(ABX)/LOG(10))-1 ;
      ELSEIF LO(1) ; NUMEXP := INT(LOG(ABX)/LOG(10)) ; ENDIF ; ENDFUNCTION ;
   FUNCTION TICSINC XDIF ;                      {TICS INCREMENTAL SIZE FOR XDIF}
      VARIABLE SMP 1 ; VARIABLE NX 1 ; SMP := ABS(XDIF) ; NX := NUMEXP(SMP) ;
      IF     SMP<(2*10^NX+0.01*SMP) ; TICSINC := 2*10^(NX-1) ;
      ELSEIF SMP<(5*10^NX+0.01*SMP) ; TICSINC := 5*10^(NX-1) ;
      ELSEIF LO(1) ;                  TICSINC := 10^NX ; ENDIF ; ENDFUNCTION ;
   PROCEDURE TICSTR X TIC CHAR DIG ;          {TICS STRING CHAR WITH DIG DIGITS}
      VARIABLE STR 40 ;   {FOR THE TICS LABELING AT X WITH THE TICS SPACING TIC}
      VARIABLE FORM 40 ; VARIABLE NX 1 ; VARIABLE NTIC 1 ; VARIABLE WORD 2 2 ;
      VARIABLE NC 1 ; NX := NUMEXP(X) ; NTIC := NUMEXP(TIC) ;
      IF ABS(X)<1.D-300 ; STR := '0' ;
      ELSEIF ABS(NX)<5 ;                             {0.00001 < ABS(X) < 100000}
         IF NOT(NTIC<0) ; STR := SI(X) ;
         ELSEIF LO(1) ;
            IF NX<0 ;                                     {0.00001 < ABS(X) < 1}
               FORM := '(F'&SI(-NTIC+3)&'.'&SI(-NTIC)&')' ;
            ELSEIF LO(1) ;                                {1 =< ABS(X) < 100000}
               FORM := '(F'&SI(NX-NTIC+3)&'.'&SI(-NTIC)&')' ; ENDIF ;
            STR := SF(X,FORM) ; ENDIF ;
      ELSEIF LO(1) ;                                                      {ELSE}
         FORM := '(G'&SI(NX-NTIC+8)&'.'&SI(NX-NTIC+1)&')' ;
         STR := SF(X,FORM) ; ENDIF ;
      WORDS STR NC WORD ' ' ; CHAR := STR|WORD(1) ;
      DIG := LENGTH(CHAR) ; ENDPROCEDURE ;

  {PROCEDURE LINECUT X1 Y1 X2 Y2 FX1 FX2 FY1 FY2 IER XB YB XE YE ;
   PROCEDURE PLOT2D TITLE NDT DT DTSTY DTCOL DTITLE RANGE RTITLE PL ;}

{OTHERS USING PLOT2D}
{*******************}

   PROCEDURE FILE2VE FN NC C VEC ;     {EXTRACTS COLUMNS IN THE FILE TO VECTORS}
     {FN:     FILE NAME.
      NC:     THE NUMBER OF COLUMNS TO BE EXTRACTED.
      C(I):   COLUMN NUMBERS TO BE EXTRACTED.
      VEC(I): VECTORS CONTAINING THE NUMBERS IN THE C(I)-TH COLUMN.
      NOTE: THE LINES STARTING WITH '#" IS OMITTED.}
      VARIABLE LIN 1000 ; VARIABLE WORD 2 20 ; VARIABLE NW 1 ;
      VARIABLE N 1 ; VARIABLE I 1 ;
      OPENF 77 FN 'OLD' ; LIN := 'start' ; N := 0 ;
      WHILE LIN#'' ; READS 77 LIN ; IF LIN#'' ; IF ((LIN|1)#'#')*(LIN#' ') ;
         WORDS LIN NW WORD ' ' ; IF NW>0 ;
         IF N=0 ; N := MIN(NC,NW) ;
            LOOP I 1 N ; VEC(I) := RE(LIN|WORD(C(I))) ; ENDLOOP ;
         ELSEIF LO(1) ;
            LOOP I 1 N ; VEC(I) := VEC(I)&RE(LIN|WORD(C(I))) ; ENDLOOP ; ENDIF ;
         ENDIF ; ENDIF ; ENDIF ; ENDWHILE ;
      CLOSEF 77 ; ENDPROCEDURE ;

   PROCEDURE RFILT RMAX FN FNF ;     {FILTERS TO KEEP ONLY LINES WITH R =< RMAX}
     {LINES SATISFYING R=SQRT(X^2+Y^2) =< RMAX IN THE FILE FN ARE COPIED TO FNF.
      THE 1ST AND THE 2ND COLUMNS ARE X AND Y.
      OMIT EMPTY LINES, AND LINES STARTING WITH '#" IS COPIED OVER.}
      VARIABLE LIN 1000 ; VARIABLE WORD 2 20 ; VARIABLE NW 1 ;
      VARIABLE X 1 ; VARIABLE Y 1 ; VARIABLE RMAX2 1 ;
      OPENF 77 FN 'OLD' ; OPENF 78 FNF 'UNKNOWN' ;
      WRITE 78 '# The original file: '&FN
               '# Filter to stay inside the radius RMAX = '&S(RMAX) ;
      RMAX2 := SQR(RMAX*(1+1D-8)) ; LIN := 'start' ;
      WHILE LIN#'' ; READS 77 LIN ; IF LIN#'' ;
         IF (LIN|1)='#' ; WRITE 78 LIN ;
         ELSEIF LIN#' ' ; WORDS LIN NW WORD ' ' ;
            IF NW>0 ; X := RE(LIN|WORD(1)) ; Y := RE(LIN|WORD(2)) ;
               IF (SQR(X)+SQR(Y))<RMAX2 ; WRITE 78 LIN ; ENDIF ; ENDIF ;
         ENDIF ; ENDIF ; ENDWHILE ;
      CLOSEF 77 ; CLOSEF 78 ; ENDPROCEDURE ;

   PROCEDURE TSC WX WY NX NY DELTA FN ;                        {SCANS THE TUNES}
     {THE X, Y TUNES ARE SCANNED IN THE AREA [-WX,WX]x[-WY,WY] BY NX*NY POINTS.
      FN: THE OUTPUT FILE.  DELTA: THE ENERGY DEVIATION.}
      VARIABLE MU NM1 3 ; VARIABLE MA 2*NM1 8 ; VARIABLE DX 1 ; VARIABLE DY 1 ;
      VARIABLE X 1 MAX(5,NV) ; VARIABLE R 1 MAX(5,NV) ; VARIABLE T 1 MAX(5,NV) ;
      VARIABLE I 1 ; VARIABLE J 1 ; VARIABLE K 1 ;
      TS MU ; NF 1D-7 MA ;
      WRITE 6 'TUNESCAN, ORBITAL TUNES FROM TS: ' MU(1) MU(2) ;
      LOOP I 1 NV ; X(I) := 0 ; R(I) := 0 ; T(I) := 0 ; ENDLOOP ;
      X(5) := DELTA ; R(5) := DELTA ; DX := 2*WX/(NX-1) ; DY := 2*WY/(NY-1) ;
      OPENF 77 FN 'UNKNOWN' ;
      WRITE 77 ('#   x                        y                        '&
                'x-tnue                   y-tune') ;
      LOOP I 1 NX ; X(1) := DX*(I-1)-WX ; LOOP J 1 NY ; X(3) := DY*(J-1)-WY ;
         POLVAL 1 MA TWOND X NV T TWOND ;
         LOOP K 1 ND ; R(2*K-1) := SQRT(SQR(T(2*K-1))+SQR(T(2*K))) ; ENDLOOP ;
         POLVAL 1 MU ND R NV T ND ;
         WRITE 77 (SF(X(1),'(E25.17)')&SF(X(3),'(E25.17)')&
                   SF(T(1),'(E25.17)')&SF(T(2),'(E25.17)')) ;
         ENDLOOP ; ENDLOOP ;
      CLOSEF 77 ; ENDPROCEDURE ;

  {PROCEDURE TFP WX WY RMAX NX NY DELTA IU TL ;            {DRAW TUNE FOOTPRINT}
     {SEE TSC. IF RMAX>0, IT IS LIMITED INSIDE THE RADIUS RMAX. TL: TITLE}
      VARIABLE PIC 4*NX*NY+2000 ; VARIABLE FN 100 ; VARIABLE CL 1 2 ;
      VARIABLE SCAN NX*NY 2 ; VARIABLE DT NX*NY 1 2 ;
      VARIABLE DTSTY 1 1 ; VARIABLE DTCOL 1 1 ; VARIABLE DTITLE 10 1 ;
      VARIABLE RANGE 1 2 ; VARIABLE RTITLE 1 2 ;
      FN := 'tunescan.dat' ; TSC WX WY NX NY DELTA FN ;
      IF RMAX>0 ; RFILT RMAX FN 'f-'&FN ; FN := 'f-'&FN ; ENDIF ;
      CL(1) := 3 ; CL(2) := 4 ; FILE2VE FN 2 CL SCAN ;
      DTSTY(1) := '*' ; DTCOL(1) := 3 ; DTITLE(1) := 'TUNE' ;
      RANGE(1) := 0 ; RANGE(2) := 0 ; RTITLE(1) := 'x' ; RTITLE(2) := 'y' ;
      DT(1,1) := SCAN(1) ; DT(1,2) := SCAN(2) ;
      CLEAR PIC ; PLOT2D TL 1 DT DTSTY DTCOL DTITLE RANGE RTITLE PIC ;
      WRITE IU PIC ; ENDPROCEDURE ;}

   SAVE 'cosy' ;
