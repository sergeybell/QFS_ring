INCLUDE 'cosy';

{ ## ******************** ORGANIZATIONAL TOOLS ******************** ## }
PROCEDURE DIRSET_AUTO VAL; {VAL=1 <=> ON, VAL=0 <=> OFF}
  VARIABLE DIRSETFLAG 1;
  DIRSETFLAG := VAL;
ENDPROCEDURE;

PROCEDURE DIRSET VAR PATH;
  VARIABLE ANS 1;
  VARIABLE DIRSETFLAG 1;
  VAR := PATH;
  OS 'mkdir -p '&PATH; WRITE 6 'WRITING TO: '&PATH;
  IF DIRSETFLAG=0;
    WRITE 6 '********** DIRECTORY GOOD? [Y/N]';
      READ 5 ANS;
    IF (ANS#'Y')*(ANS#'y'); WRITE 6 'QUITTING ... '; QUIT 1; ENDIF;
    WRITE 6 '***** REMOVE EXISTING FILES? [Y/N]';
      READ 5 ANS;
    IF (ANS='Y')+(ANS='y');
      OS 'rm -vf '&PATH&'*';
    ENDIF;
  ENDIF;
ENDPROCEDURE;

FUNCTION FILENAME WHERE NAME MARKER;
  VARIABLE SEP 1;
  SEP := ':'; IF MARKER=''; SEP:=''; ENDIF;
  FILENAME := WHERE&NAME&SEP&MARKER&'.dat';
ENDFUNCTION;

FUNCTION MRK I; MRK := LTRIM(SF(I, '(I10)')); ENDFUNCTION;

FUNCTION FORM VEC;
  VARIABLE FMT 10; VARIABLE I 1;
  FMT := '(E15.7)'; FORM:='';
  LOOP I 1 LENGTH(VEC);
    FORM := FORM&SF(VEC|I, FMT);
  ENDLOOP;
ENDFUNCTION;

PROCEDURE WRITETBL OU ARR NARR MARKER; {writes ar array of vectors in table (matrix) form}
  VARIABLE NVEC 1; VARIABLE I 1; VARIABLE J 1;
  VARIABLE ROW 101;
  NVEC := LENGTH(ARR(1));
  LOOP I 1 NVEC;
    ROW := ARR(1)|I;
    LOOP J 2 NARR; ROW := ROW&(ARR(J)|I); ENDLOOP;
    WRITE OU MARKER&' '&MRK(I-1)&' '&FORM(ROW);
  ENDLOOP;
ENDPROCEDURE;



{ ## ******************** PROCEDURES ACTIVELY USED IN SCRIPTS  ******************** ## }
FUNCTION ZEROS NUM; {CREATES A VECTOR OF ZEROS}
  VARIABLE I 1; VARIABLE RES NUM;
  RES := 0;
  LOOP I 2 NUM; RES := RES&0; ENDLOOP;
  ZEROS:=RES;
ENDFUNCTION;

FUNCTION ONES NUM; {CREATES A VECTOR OF ONES}
  VARIABLE I 1; VARIABLE RES NUM;
  RES := 1;
  LOOP I 2 NUM; RES := RES&1; ENDLOOP;
  ONES:=RES;
ENDFUNCTION;

PROCEDURE EYE MAT M; {COMPUTES THE IDENTITY MATRIX}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 M;
    LOOP J 1 M;
      MAT(I,J) := 0*DD(1);
      ENDLOOP;
    MAT(I,I) := 1 + 0*DD(1);
    ENDLOOP;
ENDPROCEDURE; {EYE}

FUNCTION LINSPACE LOW HIGH NUM;
  VARIABLE I 1; VARIABLE DELTA 1; VARIABLE RES NUM;
  RES := LOW;
  IF NUM>1;
    DELTA := (HIGH-LOW)/(NUM-1);
    LOOP I 2 NUM; RES := RES&(LOW + DELTA*(I-1));  ENDLOOP;
  ENDIF;
  LINSPACE := RES;
ENDFUNCTION;

FUNCTION RAD2DEG ANGLE;
  RAD2DEG := ANGLE/DEGRAD;
ENDFUNCTION;

FUNCTION DEG2RAD ANGLE;
  DEG2RAD := ANGLE*DEGRAD;
ENDFUNCTION;

FUNCTION VEGAUSS MEAN SIGMA NUM PATH; {generate a vector of normally distributed random numbers}
  {PATH --- path to the data file containing the sequence of random numbers}
  VARIABLE VAL 1;
  OS 'python gauss.py '&ST(MEAN)&' '&ST(SIGMA)&SF(NUM,'(I10)')&' '&PATH&'.in';
  OPENF 100500 PATH&'.in' 'OLD';
  READ 100500 VAL;
  WHILE ST(VAL)#'';
    VEGAUSS:=VEGAUSS&VAL;
    READ 100500 VAL;
  ENDWHILE;
  CLOSEF 100500;
  VEGAUSS := VEGAUSS|(2&LENGTH(VEGAUSS));
ENDFUNCTION;

FUNCTION COV X Y;
  VARIABLE N 1; VARIABLE MUX 1; VARIABLE MUY 1;
  IF LENGTH(X)=LENGTH(Y);
    N := LENGTH(X);
  ELSEIF TRUE;
    WRITE 6 'DIFFERENT VECTOR LENGTHS!!!';
  ENDIF;
  MUX := RE(X); MUY := RE(Y);
  COV := RE((X-MUX)*(Y-MUY));
ENDFUNCTION;

FUNCTION EMITTANCE X1 X2;
  VARIABLE COVS 1 2 2;
  VARIABLE I 1; VARIABLE J 1; VARIABLE DET 1;
  COVS(1,1) := COV(X1,X2);
  COVS(1,2) := COV(X1,X2);
  COVS(2,1) := COVS(1,2);
  COVS(2,2) := COV(X2,X2);
  DET := COVS(1,1)*COVS(2,2) - COVS(2,1)*COVS(1,2);
  EMITTANCE := SQRT(DET);
ENDFUNCTION;

PROCEDURE GET_TUNE_ENSEMBLE MUARR; {COMPUTES THE ENSEMBLE OF SPIN TUNES FOR GIVEN RAYS, LATTICE}
  VARIABLE K 1; VARIABLE MU 5000; VARIABLE NBAR 5000 3;
  TSS MU NBAR 0;
  MUARR(1) := MU; LOOP K 1 3; MUARR(K+1) := NBAR(K); ENDLOOP;
  POLVAL 1 MUARR 4 RAY TWOND MUARR 4;
ENDPROCEDURE; {GET_TUNE_ENSEMBLE}

FUNCTION REVFREQ Lcir; { Computes the particle REVOLUTION FREQUENCY;
                          to be called AFTER RP }
  REVFREQ := CONS(V0)/Lcir;
ENDFUNCTION;

FUNCTION STD VEC;
  VARIABLE MEAN 1; VARIABLE N 1;
  MEAN := RE(VEC); N := LENGTH(VEC) - 1; {if 1 is not removed, the std estimator is biased}
  STD := SQRT(ABS(SQR(VEC-MEAN))/N);
ENDFUNCTION;

FUNCTION beta gamma;
  beta := SQRT(gamma*gamma - 1)/gamma;
ENDFUNCTION;

{ ## ******************** PLOTTING TOOLS ******************** ## }
PROCEDURE GET_BOUNDS X Y XMIN XMAX YMIN YMAX DX DY;
  VARIABLE N 1;
  N := LENGTH(X);
  XMIN := VMIN(X); XMAX := VMAX(X);
  YMIN := VMIN(Y); YMAX := VMAX(Y);
  DX := (XMAX-XMIN)/(NRAY-2);
  DY := (YMAX-YMIN)/(NRAY-2);
ENDPROCEDURE; {GET_BOUNDS}

PROCEDURE FRAME_SETUP X Y PLOT TITLE;
  VARIABLE FMT 10;
  VARIABLE XMIN 1; VARIABLE XMAX 1;
  VARIABLE YMIN 1; VARIABLE YMAX 1;
  VARIABLE DX 1; VARIABLE DY 1;
  FMT := '(E9.3)';
  GET_BOUNDS X Y XMIN XMAX YMIN YMAX DX DY;
  FG PLOT XMIN XMAX YMIN YMAX DX DY TITLE 0;
  GRMOVE (XMIN-1.2*DX) YMIN 0 PLOT; GRCHAR SF(XMIN, FMT) PLOT;
  GRMOVE XMIN (YMIN-DY*.5)  0 PLOT; GRCHAR SF(YMIN, FMT) PLOT;
  GRMOVE (XMAX-DX) YMIN 0 PLOT; GRCHAR SF(XMAX, FMT) PLOT;
  GRMOVE XMAX YMAX  0 PLOT; GRCHAR SF(YMAX, FMT) PLOT;
ENDPROCEDURE; {FRAME SETUP}

PROCEDURE DRAW_LAYER XVEC YVEC PLOT;
  VARIABLE N 1; VARIABLE X 1 1000; VARIABLE Y 1 1000;
  VARIABLE I 1;
  N := LENGTH(XVEC);
  LOOP I 1 N;
    X(I) := XVEC|I;
    Y(I) := YVEC|I;
    GRDOT X(I) Y(I) 0 PLOT;
  ENDLOOP;
  { CG PLOT X Y N; }
ENDPROCEDURE; {DRAW_LAYER}

{ ## *************** FORMAL METHODS *************** ## }
PROCEDURE AM1 M S; {LETS M ACT ON MAP, S ON SPNR; THE FULL VERSION OF AM FROM COSY.FOX}
  VARIABLE I 1 ; VARIABLE J 1;
  UMS;
  LOOP I 1 TWOND ; MSC(I) := M(I) ; ENDLOOP ;
  LOOP I 1 3; LOOP J 1 3; SSCR(I,J) := S(I,J);
  ENDLOOP; ENDLOOP;
  LOCSET 0 0 0 0 0 0 ; UPDATE 1 1 ;
ENDPROCEDURE;
PROCEDURE MATPROD N M O;
  {computes the MATRIX PRODUCT: N * M -> O}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 3;
    LOOP J 1 3;
      O(I,J) := N(I,1)*M(1,J) + N(I,2)*M(2,J) + N(I,3)*M(3,J);
    ENDLOOP;
  ENDLOOP;
ENDPROCEDURE;

PROCEDURE S3NM N M; {write N -> M}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 3; LOOP J 1 3; M(I,J) := N(I,J); ENDLOOP; ENDLOOP;
ENDPROCEDURE;

FUNCTION VEREV VEC; {reverses vector element order}
  VARIABLE N 1; VARIABLE NMID 1;
  VARIABLE I 1; VARIABLE DUM 1;
  VARIABLE RES LENGTH(VEC);
  N := LENGTH(VEC); RES := VEC;
  IF MOD(N, 2)=0; NMID := N/2;
  ELSEIF LO(1); NMID := INT(N/2); ENDIF;
  LOOP I 1 NMID;
    VELGET RES (N-I+1) DUM;
    VELSET RES (N-I+1) RES|I;
    VELSET RES I DUM;
  ENDLOOP;
  VEREV := RES;
ENDFUNCTION;

{ EREMEYs PROCEUDRES TO REVERSE THE SPIN MAP }
PROCEDURE MATINV M1 M2;
   VARIABLE MDET 4000;
      MDET:=0;
      MDET:=MDET+M1(1,1)*(M1(2,2)*M1(3,3)-M1(2,3)*M1(3,2));
      MDET:=MDET-M1(2,1)*(M1(1,2)*M1(3,3)-M1(1,3)*M1(3,2));
      MDET:=MDET+M1(3,1)*(M1(1,2)*M1(2,3)-M1(1,3)*M1(2,2));
      M2(1,1):=(M1(2,2)*M1(3,3)-M1(2,3)*M1(3,2))/MDET;
      M2(2,2):=(M1(1,1)*M1(3,3)-M1(1,3)*M1(3,1))/MDET;
      M2(3,3):=(M1(1,1)*M1(2,2)-M1(1,2)*M1(2,1))/MDET;
      M2(1,3):=(M1(1,2)*M1(2,3)-M1(1,3)*M1(2,2))/MDET;
      M2(3,1):=(M1(2,1)*M1(3,2)-M1(2,2)*M1(3,1))/MDET;
      M2(1,2):=-(M1(1,2)*M1(3,3)-M1(1,3)*M1(3,2))/MDET;
      M2(2,1):=-(M1(2,1)*M1(3,3)-M1(2,3)*M1(3,1))/MDET;
      M2(2,3):=-(M1(1,1)*M1(2,3)-M1(1,3)*M1(2,1))/MDET;
      M2(3,2):=-(M1(1,1)*M1(3,2)-M1(1,2)*M1(3,1))/MDET;
   ENDPROCEDURE;

PROCEDURE SMR NAP LAP ; {REVERSES SPIN MAP NAP TO LAP}
      VARIABLE COD 1 NV ; VARIABLE NUM 1 ; VARIABLE I 1 ; VARIABLE J 1 ;
      VARIABLE MM NM1 3 3 ;
      VARIABLE T1 NM1 1 ; VARIABLE T2 NM1 1 ;
      VARIABLE FLG 1 ;
      NUM := MIN(TWOND,4) ;
      MATINV NAP MM ;
      MM(1,3) := -MM(1,3) ; MM(2,3) := -MM(2,3) ;
      MM(3,1) := -MM(3,1) ; MM(3,2) := -MM(3,2) ;
      LOOP I 2 NUM 2 ; COD(I-1) := DD(I-1) ; COD(I) := -DD(I) ; ENDLOOP ;
      LOOP I NUM+1 NV ; COD(I) := DD(I) ; ENDLOOP ;
      IF ND>2 ; COD(5) := -DD(5) ; ENDIF ;
      LOOP I 1 3 ; LOOP J 1 3 ;
         T1(1) := MM(I,J) ;
         POLVAL 1 T1 1 COD NV T2 1 ;
         LAP(I,J) := T2(1) ;
      ENDLOOP ; ENDLOOP ;
   ENDPROCEDURE ;
{## ************************************************** ##}


PROCEDURE TRACK PNTNUM STEP FILEDIR MARK TY;
  VARIABLE TURN 1; VARIABLE PNT 1; VARIABLE PCT 1;
  VARIABLE SYMPE 1; VARIABLE SNRME 1;

  WRITE 6 'RUNNING COSYINF-CORE/UTILITIES.FOX: TRACK';

  OPENF 100500 FILENAME(FILEDIR, 'PRAY', 'TR'&MARK) 'REPLACE';
  PRAY 100500; CLOSEF 100500;
  WRITE 6 SI(0)&' %';
  OPENF 100501 FILENAME(FILEDIR, 'TRPSPI', 'TR'&MARK) 'REPLACE';
  WRITE 100501 '# TRACKING OUTPUT';
  WRITE 100501 'TURN PID S_X S_Y S_Z';
  WRITETBL 100501 SPI 3 SF(0, '(I15)');
  OPENF 100502 FILENAME(FILEDIR, 'TRPRAY', 'TR'&MARK) 'REPLACE';
  WRITE 100502 '# TRACKING OUTPUT';
  WRITE 100502 'TURN PID X A Y B T D';
  WRITETBL 100502 RAY 6 SF(0, '(I15)');

  TRR 1;
  OPENF 101239 'tmp/ERROR:TRACK.txt' 'REPLACE';
  WRITE 101239 '# NUM SYMPE SNRME';
  LOOP PNT 1 PNTNUM; TURN := STEP*PNT;
    TR STEP -STEP -1 -3 1.1 1.1 TY 0 -12; {NEED TO TURN OFF *** SYMPLECTIFICATION *** (-21) FOR NICA_FULL}
    WRITETBL 100501 SPI 3 SF(TURN, '(I15)');
    WRITETBL 100502 RAY 6 SF(TURN, '(I15)');
    PCT := 100*PNT/PNTNUM;
    IF MOD(PCT, 10)=0; WRITE 6 SI(PCT)&' %'; ENDIF;
    TRSC SYMPE; TRNC SNRME;
    WRITE 6 '   TR SYMPLECTIFICATION ERROR' SYMPE;
    WRITE 6 '   TR SPIN NORMALIZATON ERROR' SNRME;
    WRITE 101239 SF(TURN, '(I10)')&SF(SYMPE, '(E15.7)')&SF(SNRME, '(E15.7)');
    IF (SYMPE > 1e-3);
      WRITE 6 'SYMPLECTIFICATION ERROR TOO LARGE; ABORTING...';
      QUIT TURN;
    ELSEIF (SNRME > 1E-3);
      WRITE 6 'SPIN NORMALIZATION ERROR TOO LARGE; ABORTING...';
      QUIT TURN;
    ENDIF;
  ENDLOOP;
  CLOSEF 101239;
  CLOSEF 100500; CLOSEF 100501; CLOSEF 100502;
ENDPROCEDURE; {TRACK}

PROCEDURE SMAPS POS MAPARR SPNRARR; {SAVE SEGMENT TRANSFER MAPS TO ARRAY ELEMENT}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 TWOND; MAPARR(I, POS) := MAP(I); ENDLOOP;
  LOOP I 1 3;
    LOOP J 1 3; SPNRARR(I,J,POS) := SPNR(I,J); ENDLOOP;
  ENDLOOP;
ENDPROCEDURE;
PROCEDURE LMAPS POS MAPARR SPNRARR; {LOAD SEGMENT TRANSFER MAPS FROM ARRAYS}
  VARIABLE I 1; VARIABLE J 1;
  UM;
  LOOP I 1 TWOND; MSC(I) := MAPARR(I, POS); ENDLOOP;
  LOOP I 1 3;
    LOOP J 1 3; SSCR(I,J) := SPNRARR(I,J,POS) + 0*DD(1); ENDLOOP;
  ENDLOOP;
  LOCSET 0 0 0 0 0 0; UPDATE 1 1;
  {old version}
  { LOOP I 1 TWOND; MAP(I) := MAPARR(I, POS); ENDLOOP; }
  { LOOP I 1 3; }
  {   LOOP J 1 3; SPNR(I,J) := SPNRARR(I,J,POS); ENDLOOP; }
  { ENDLOOP; }
ENDPROCEDURE;

PROCEDURE TREL MAPARR SPNRARR IEL LEL NTRN PRAYOU PSPIOU;
  {Element-by-element tracking}
  {OEID is Out Element ID; used to control whether data output is done after all elements or only specific ones}
  VARIABLE TRN 1; VARIABLE EL 1;
  VARIABLE NR 1; VARIABLE NS 1;
  VARIABLE DUM 1; VARIABLE I 1;
  VARIABLE SYMPE 1; VARIABLE SNRME 1; VARIABLE MAPSE 1;
  VARIABLE RAYH 1000 8; VARIABLE SPIH 1000 3;
  PROCEDURE WTRPRAY IT ELN;
    VARIABLE STR 500;
    VARIABLE J 1; VARIABLE I 1;
    IF PRAYOU#0;
      IF IT=0 ; NR := LENGTH(RAY(1)); IF NR=1; NR:=0; ENDIF;
        WRITE PRAYOU '# number of rays:'&SF(NR,'(I8)') ;
        IF NR>0 ; STR := '# iteration   EID   ray    X              A' ;
           IF TWOND>2 ; STR := STR&'              Y              B' ;
              ENDIF ;
           IF TWOND>4 ; STR := STR&'              T              D' ;
              ENDIF ;
           IF TWOND>6 ; STR := STR&'              G              Z' ;
              ENDIF ;
           WRITE PRAYOU STR ;
        ENDIF ;
      ELSEIF TRUE ; WRITE PRAYOU '' ; ENDIF ;
      LOOP J 1 NR ; STR := SF(IT,'(I10)')&SF(ELN,'(I6)')&' '&SF(J-1,'(I6)') ;
        LOOP I 1 TWOND ; STR := STR&SF((RAY(I)|J),'(E15.7)') ; ENDLOOP ;
        WRITE PRAYOU STR ;
      ENDLOOP ;
    ENDIF; {PRINT OR NOT}
  ENDPROCEDURE; {WTRPRAY}
  PROCEDURE WTRPSPI IT ELN;
    VARIABLE STR 500;
    VARIABLE I 1; VARIABLE J 1;
    IF PSPIOU#0;
      IF IT=0 ; NS := LENGTH(SPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;
        WRITE PSPIOU '# number of spin vectors:'&SF(NS,'(I8)') ;
        IF NS>0 ; WRITE PSPIOU ('# iteration   EID vector   S_X'&
                        '            S_Y            S_Z') ; ENDIF ;
      ELSEIF TRUE ; WRITE PSPIOU '' ; ENDIF ;
      LOOP J 1 NS ; STR := SF(IT,'(I10)')&SF(ELN, '(I6)')&' '&SF(J-1,'(I6)') ;
        LOOP I 1 3 ; STR := STR&SF((SPI(I)|J),'(E15.7)') ; ENDLOOP ;
        WRITE PSPIOU STR ;
      ENDLOOP ;
    ENDIF; {PRINT OR NOT}
  ENDPROCEDURE; {WTRPSPI}

  TRR 1; {enable resuming mode for element-by element tracking}
  LTRPRAY := 0; LTRPSPI := 0; { make sure that TR doesnt output data on its own}
  WTRPRAY 0 0; {WRITE INITIAL STATE TO TRPRAY}
  WTRPSPI 0 0; {TRPSPI}
  SRAY RAYH; SSPI SPIH; {saving here b/c clearing at **}
  OPENF 101239 'tmp/ERROR:TREL.txt' 'REPLACE';
  WRITE 101239 '# TRN EL SYMPE SNRME MAPSE';
  LOOP TRN 1 NTRN;
    LOOP EL IEL LEL; WRITE 6 'ELEMENT NUMBER '&ST(EL);
      UM; CR; { ** }
      LMAPS EL MAPARR SPNRARR;
      LRAY RAYH; LSPI SPIH;
      TRSC SYMPE; TRNC SNRME; MAPSE := SE(MAP);
      TR 1 -1 -1 -3 1.2 1.2 0 0 -12;
      WTRPRAY TRN EL; WTRPSPI TRN EL;
      SRAY RAYH; SSPI SPIH; {saving the RAY and SPI vectors in order to call CR **}
      { WRITE 6 '   TR SYMPLECTIFICATION ERROR' SYMPE; }
      { WRITE 6 '   TR SPIN NORMALIZATON ERROR' SNRME; }
      { WRITE 6 '   MAP SYMPLECTIFICATION ERROR' MAPSE; }
      WRITE 101239 SF(TRN, '(I10)')&SF(EL, '(I10)')&SF(SYMPE, '(E15.7)')&SF(SNRME, '(E15.7)')&SF(MAPSE, '(E15.7)');
      { IF (SYMPE > 1e-3); }
      {   WRITE 6 'SYMPLECTIFICATION ERROR TOO LARGE; ABORTING...'; }
        { QUIT EL; }
      { ELSEIF (SNRME > 1E-3); }
      {   WRITE 6 'SPIN NORMALIZATION ERROR TOO LARGE; ABORTING...'; }
        { QUIT EL; }
      { ENDIF; }
    ENDLOOP;
  ENDLOOP;
  CLOSEF 101239;
ENDPROCEDURE; {TREL}

PROCEDURE COLWRITE OU VEC;
  VARIABLE N 1; VARIABLE I 1;
  N := LENGTH(VEC);
  LOOP I 1 N; WRITE OU VEC|I; ENDLOOP;
ENDPROCEDURE;

PROCEDURE INSERT POS MAPARR SPNRARR NFILLED;
           {inserts MAP, SPNR into lattice MAPARR, SPNRARR at POS; NFILLED elements in arrays}
  VARIABLE I 1; VARIABLE J 1; VARIABLE K 1;
  LOOP I NFILLED POS -1; WRITE 6 I;
    LOOP J 1 TWOND; MAPARR(J, I+1) := MAPARR(J, I); ENDLOOP;
    LOOP J 1 3;
      LOOP K 1 3;
        SPNRARR(J, K, I+1) := SPNRARR(J, K, I);
      ENDLOOP;
    ENDLOOP;
  ENDLOOP;
  SMAPS POS MAPARR SPNRARR;
ENDPROCEDURE;

SAVE 'utilities';
